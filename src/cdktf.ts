/**
 * CDKTF utilities - keep this module self-contained.
 *
 * Avoid importing from `@cdktf/*` outside this module to prevent dependency on
 * CDKTF internals. The goal is to keep this layer replaceable with plain
 * Terraform + JSII in the future.
 */
import {
  Language as CdktfLanguage,
  TerraformProviderConstraint
} from '@cdktf/commons'
import { ConstructsMaker } from '@cdktf/provider-generator'
import { readFile } from 'node:fs/promises'
import { join } from 'node:path'
import { z } from 'zod'

export type Language = `${CdktfLanguage}`

export type ProviderConstructionOption = Readonly<{
  language: Language
  name: string
  source: string
  directory: string
}>

/**
 * Generates constructs for the given provider.
 */
export async function generateProviderConstruct(
  option: ProviderConstructionOption
): Promise<{ version: string }> {
  const { language, name, source, directory } = option
  const constraint = new TerraformProviderConstraint({
    name,
    source
  })
  const constructsMaker = new ConstructsMaker({
    targetLanguage: language as CdktfLanguage,
    codeMakerOutput: directory
  })

  await constructsMaker.removeFoldersThatShouldNotExist([constraint])
  const filtered = await constructsMaker.filterAlreadyGenerated([constraint])
  await constructsMaker.generate([constraint], filtered)

  return {
    version: await readVersionsFile(directory, source)
  }
}

/**
 * Reads the version of the provider from the versions.json file.
 * versions.json is generated by CDKTF, and follows the format:
 *
 * ```json
 * {
 *   "registry.terraform.io/hashicorp/null": "0.0.0"
 * }
 * ```
 */
async function readVersionsFile(
  directory: string,
  source: string
): Promise<string> {
  const file = join(directory, 'versions.json')
  const content = await readFile(file, 'utf-8')
  const versions = JSON.parse(content)
  const version = versions[`registry.terraform.io/${source.toLowerCase()}`]
  return z.string().parse(version)
}
