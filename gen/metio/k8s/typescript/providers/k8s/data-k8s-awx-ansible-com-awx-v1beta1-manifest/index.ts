// https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestConfig extends cdktf.TerraformMetaArguments {
  /**
  * Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metadata DataK8SAwxAnsibleComAwxV1Beta1Manifest#metadata}
  */
  readonly metadata: DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#spec DataK8SAwxAnsibleComAwxV1Beta1Manifest#spec}
  */
  readonly spec?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec;
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#name DataK8SAwxAnsibleComAwxV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestMetadataToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestMetadataToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_fields DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preference DataK8SAwxAnsibleComAwxV1Beta1Manifest#preference}
  */
  readonly preference: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preference: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct!.preference),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preference: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preference.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preference.internalValue = value.preference;
      this._weight = value.weight;
    }
  }

  // preference - computed: false, optional: false, required: true
  private _preference = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) {
    this._preference.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_fields DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#node_selector_terms DataK8SAwxAnsibleComAwxV1Beta1Manifest#node_selector_terms}
  */
  readonly nodeSelectorTerms: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, false)(struct!.nodeSelectorTerms),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, false)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: false, required: true
  private _nodeSelectorTerms = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity_term DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity_term DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#node_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#node_affinity}
  */
  readonly nodeAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity}
  */
  readonly podAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_anti_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_anti_affinity}
  */
  readonly podAntiAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    pod_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityToTerraform(struct!.podAffinity),
    pod_anti_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityToTerraform(struct!.podAntiAffinity),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity",
    },
    pod_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityToHclTerraform(struct!.podAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity",
    },
    pod_anti_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityToHclTerraform(struct!.podAntiAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._podAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinity = this._podAffinity?.internalValue;
    }
    if (this._podAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinity = this._podAntiAffinity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = undefined;
      this._podAffinity.internalValue = undefined;
      this._podAntiAffinity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._podAffinity.internalValue = value.podAffinity;
      this._podAntiAffinity.internalValue = value.podAntiAffinity;
    }
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // pod_affinity - computed: false, optional: true, required: false
  private _podAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinityOutputReference(this, "pod_affinity");
  public get podAffinity() {
    return this._podAffinity;
  }
  public putPodAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAffinity) {
    this._podAffinity.internalValue = value;
  }
  public resetPodAffinity() {
    this._podAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityInput() {
    return this._podAffinity.internalValue;
  }

  // pod_anti_affinity - computed: false, optional: true, required: false
  private _podAntiAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinityOutputReference(this, "pod_anti_affinity");
  public get podAntiAffinity() {
    return this._podAntiAffinity;
  }
  public putPodAntiAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityPodAntiAffinity) {
    this._podAntiAffinity.internalValue = value;
  }
  public resetPodAntiAffinity() {
    this._podAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityInput() {
    return this._podAntiAffinity.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#image DataK8SAwxAnsibleComAwxV1Beta1Manifest#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#name DataK8SAwxAnsibleComAwxV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image: cdktf.stringToTerraform(struct!.image),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._image = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._image = value.image;
      this._name = value.name;
    }
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#setting DataK8SAwxAnsibleComAwxV1Beta1Manifest#setting}
  */
  readonly setting?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#value DataK8SAwxAnsibleComAwxV1Beta1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    setting: cdktf.stringToTerraform(struct!.setting),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    setting: {
      value: cdktf.stringToHclTerraform(struct!.setting),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._setting !== undefined) {
      hasAnyValues = true;
      internalValueResult.setting = this._setting;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._setting = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._setting = value.setting;
      this._value = value.value;
    }
  }

  // setting - computed: false, optional: true, required: false
  private _setting?: string; 
  public get setting() {
    return this.getStringAttribute('setting');
  }
  public set setting(value: string) {
    this._setting = value;
  }
  public resetSetting() {
    this._setting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get settingInput() {
    return this._setting;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#name DataK8SAwxAnsibleComAwxV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#name DataK8SAwxAnsibleComAwxV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#configmaps DataK8SAwxAnsibleComAwxV1Beta1Manifest#configmaps}
  */
  readonly configmaps?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#secrets DataK8SAwxAnsibleComAwxV1Beta1Manifest#secrets}
  */
  readonly secrets?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configmaps: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsToTerraform, false)(struct!.configmaps),
    secrets: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsToTerraform, false)(struct!.secrets),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configmaps: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsToHclTerraform, false)(struct!.configmaps),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsList",
    },
    secrets: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsToHclTerraform, false)(struct!.secrets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configmaps?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configmaps = this._configmaps?.internalValue;
    }
    if (this._secrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secrets = this._secrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configmaps.internalValue = undefined;
      this._secrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configmaps.internalValue = value.configmaps;
      this._secrets.internalValue = value.secrets;
    }
  }

  // configmaps - computed: false, optional: true, required: false
  private _configmaps = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmapsList(this, "configmaps", false);
  public get configmaps() {
    return this._configmaps;
  }
  public putConfigmaps(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesConfigmaps[] | cdktf.IResolvable) {
    this._configmaps.internalValue = value;
  }
  public resetConfigmaps() {
    this._configmaps.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configmapsInput() {
    return this._configmaps.internalValue;
  }

  // secrets - computed: false, optional: true, required: false
  private _secrets = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecretsList(this, "secrets", false);
  public get secrets() {
    return this._secrets;
  }
  public putSecrets(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesSecrets[] | cdktf.IResolvable) {
    this._secrets.internalValue = value;
  }
  public resetSecrets() {
    this._secrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsInput() {
    return this._secrets.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#hostnames DataK8SAwxAnsibleComAwxV1Beta1Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ip DataK8SAwxAnsibleComAwxV1Beta1Manifest#ip}
  */
  readonly ip?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    ip: cdktf.stringToTerraform(struct!.ip),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    ip: {
      value: cdktf.stringToHclTerraform(struct!.ip),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._ip !== undefined) {
      hasAnyValues = true;
      internalValueResult.ip = this._ip;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._ip = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._ip = value.ip;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // ip - computed: false, optional: true, required: false
  private _ip?: string; 
  public get ip() {
    return this.getStringAttribute('ip');
  }
  public set ip(value: string) {
    this._ip = value;
  }
  public resetIp() {
    this._ip = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipInput() {
    return this._ip;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts {
  /**
  * Hostname of the instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#hostname DataK8SAwxAnsibleComAwxV1Beta1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * Secret where the Ingress TLS secret can be found
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#tls_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#tls_secret}
  */
  readonly tlsSecret?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostname: cdktf.stringToTerraform(struct!.hostname),
    tls_secret: cdktf.stringToTerraform(struct!.tlsSecret),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_secret: {
      value: cdktf.stringToHclTerraform(struct!.tlsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._tlsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSecret = this._tlsSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostname = undefined;
      this._tlsSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostname = value.hostname;
      this._tlsSecret = value.tlsSecret;
    }
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // tls_secret - computed: false, optional: true, required: false
  private _tlsSecret?: string; 
  public get tlsSecret() {
    return this.getStringAttribute('tls_secret');
  }
  public set tlsSecret(value: string) {
    this._tlsSecret = value;
  }
  public resetTlsSecret() {
    this._tlsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSecretInput() {
    return this._tlsSecret;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._storage = value.storage;
    }
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._storage = value.storage;
    }
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_fields DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preference DataK8SAwxAnsibleComAwxV1Beta1Manifest#preference}
  */
  readonly preference: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preference: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct!.preference),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preference: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preference.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preference.internalValue = value.preference;
      this._weight = value.weight;
    }
  }

  // preference - computed: false, optional: false, required: true
  private _preference = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) {
    this._preference.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_fields DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#node_selector_terms DataK8SAwxAnsibleComAwxV1Beta1Manifest#node_selector_terms}
  */
  readonly nodeSelectorTerms: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, false)(struct!.nodeSelectorTerms),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, false)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: false, required: true
  private _nodeSelectorTerms = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity_term DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity_term DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#node_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#node_affinity}
  */
  readonly nodeAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity}
  */
  readonly podAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_anti_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_anti_affinity}
  */
  readonly podAntiAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    pod_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityToTerraform(struct!.podAffinity),
    pod_anti_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityToTerraform(struct!.podAntiAffinity),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity",
    },
    pod_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityToHclTerraform(struct!.podAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity",
    },
    pod_anti_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityToHclTerraform(struct!.podAntiAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._podAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinity = this._podAffinity?.internalValue;
    }
    if (this._podAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinity = this._podAntiAffinity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = undefined;
      this._podAffinity.internalValue = undefined;
      this._podAntiAffinity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._podAffinity.internalValue = value.podAffinity;
      this._podAntiAffinity.internalValue = value.podAntiAffinity;
    }
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // pod_affinity - computed: false, optional: true, required: false
  private _podAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinityOutputReference(this, "pod_affinity");
  public get podAffinity() {
    return this._podAffinity;
  }
  public putPodAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAffinity) {
    this._podAffinity.internalValue = value;
  }
  public resetPodAffinity() {
    this._podAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityInput() {
    return this._podAffinity.internalValue;
  }

  // pod_anti_affinity - computed: false, optional: true, required: false
  private _podAntiAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinityOutputReference(this, "pod_anti_affinity");
  public get podAntiAffinity() {
    return this._podAntiAffinity;
  }
  public putPodAntiAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityPodAntiAffinity) {
    this._podAntiAffinity.internalValue = value;
  }
  public resetPodAntiAffinity() {
    this._podAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityInput() {
    return this._podAntiAffinity.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_fields DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preference DataK8SAwxAnsibleComAwxV1Beta1Manifest#preference}
  */
  readonly preference: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preference: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct!.preference),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preference: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preference.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preference.internalValue = value.preference;
      this._weight = value.weight;
    }
  }

  // preference - computed: false, optional: false, required: true
  private _preference = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) {
    this._preference.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_fields DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#node_selector_terms DataK8SAwxAnsibleComAwxV1Beta1Manifest#node_selector_terms}
  */
  readonly nodeSelectorTerms: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, false)(struct!.nodeSelectorTerms),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, false)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: false, required: true
  private _nodeSelectorTerms = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity_term DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity_term DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#weight DataK8SAwxAnsibleComAwxV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#key DataK8SAwxAnsibleComAwxV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#operator DataK8SAwxAnsibleComAwxV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#values DataK8SAwxAnsibleComAwxV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_expressions DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#match_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespace_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#namespaces DataK8SAwxAnsibleComAwxV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_key DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SAwxAnsibleComAwxV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#node_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#node_affinity}
  */
  readonly nodeAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_affinity}
  */
  readonly podAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pod_anti_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#pod_anti_affinity}
  */
  readonly podAntiAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    pod_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityToTerraform(struct!.podAffinity),
    pod_anti_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityToTerraform(struct!.podAntiAffinity),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity",
    },
    pod_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityToHclTerraform(struct!.podAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity",
    },
    pod_anti_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityToHclTerraform(struct!.podAntiAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._podAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinity = this._podAffinity?.internalValue;
    }
    if (this._podAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinity = this._podAntiAffinity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = undefined;
      this._podAffinity.internalValue = undefined;
      this._podAntiAffinity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._podAffinity.internalValue = value.podAffinity;
      this._podAntiAffinity.internalValue = value.podAntiAffinity;
    }
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // pod_affinity - computed: false, optional: true, required: false
  private _podAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinityOutputReference(this, "pod_affinity");
  public get podAffinity() {
    return this._podAffinity;
  }
  public putPodAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAffinity) {
    this._podAffinity.internalValue = value;
  }
  public resetPodAffinity() {
    this._podAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityInput() {
    return this._podAffinity.internalValue;
  }

  // pod_anti_affinity - computed: false, optional: true, required: false
  private _podAntiAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinityOutputReference(this, "pod_anti_affinity");
  public get podAntiAffinity() {
    return this._podAntiAffinity;
  }
  public putPodAntiAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityPodAntiAffinity) {
    this._podAntiAffinity.internalValue = value;
  }
  public resetPodAntiAffinity() {
    this._podAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityInput() {
    return this._podAntiAffinity.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimitsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimitsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#cpu DataK8SAwxAnsibleComAwxV1Beta1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ephemeral_storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#ephemeral_storage}
  */
  readonly ephemeralStorage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#memory DataK8SAwxAnsibleComAwxV1Beta1Manifest#memory}
  */
  readonly memory?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#storage DataK8SAwxAnsibleComAwxV1Beta1Manifest#storage}
  */
  readonly storage?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequestsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    ephemeral_storage: cdktf.stringToTerraform(struct!.ephemeralStorage),
    memory: cdktf.stringToTerraform(struct!.memory),
    storage: cdktf.stringToTerraform(struct!.storage),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequestsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ephemeral_storage: {
      value: cdktf.stringToHclTerraform(struct!.ephemeralStorage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage: {
      value: cdktf.stringToHclTerraform(struct!.storage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequestsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._ephemeralStorage !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeralStorage = this._ephemeralStorage;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    if (this._storage !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._ephemeralStorage = undefined;
      this._memory = undefined;
      this._storage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._ephemeralStorage = value.ephemeralStorage;
      this._memory = value.memory;
      this._storage = value.storage;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // ephemeral_storage - computed: false, optional: true, required: false
  private _ephemeralStorage?: string; 
  public get ephemeralStorage() {
    return this.getStringAttribute('ephemeral_storage');
  }
  public set ephemeralStorage(value: string) {
    this._ephemeralStorage = value;
  }
  public resetEphemeralStorage() {
    this._ephemeralStorage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralStorageInput() {
    return this._ephemeralStorage;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }

  // storage - computed: false, optional: true, required: false
  private _storage?: string; 
  public get storage() {
    return this.getStringAttribute('storage');
  }
  public set storage(value: string) {
    this._storage = value;
  }
  public resetStorage() {
    this._storage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#limits DataK8SAwxAnsibleComAwxV1Beta1Manifest#limits}
  */
  readonly limits?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#requests DataK8SAwxAnsibleComAwxV1Beta1Manifest#requests}
  */
  readonly requests?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimitsToTerraform(struct!.limits),
    requests: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequestsToTerraform(struct!.requests),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits",
    },
    requests: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequestsToHclTerraform(struct!.requests),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._requests?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._requests.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._requests.internalValue = value.requests;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // requests - computed: false, optional: true, required: false
  private _requests = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequestsOutputReference(this, "requests");
  public get requests() {
    return this._requests;
  }
  public putRequests(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsRequests) {
    this._requests.internalValue = value;
  }
  public resetRequests() {
    this._requests.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests.internalValue;
  }
}
export interface DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec {
  /**
  * Additional labels defined on the resource, which should be propagated to child resources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#additional_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#additional_labels}
  */
  readonly additionalLabels?: string[];
  /**
  * The admin user email
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#admin_email DataK8SAwxAnsibleComAwxV1Beta1Manifest#admin_email}
  */
  readonly adminEmail?: string;
  /**
  * Secret where the admin password can be found
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#admin_password_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#admin_password_secret}
  */
  readonly adminPasswordSecret?: string;
  /**
  * Username to use for the admin account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#admin_user DataK8SAwxAnsibleComAwxV1Beta1Manifest#admin_user}
  */
  readonly adminUser?: string;
  /**
  * If specified, the pod's scheduling constraints
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#affinity}
  */
  readonly affinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity;
  /**
  * Common annotations for both Web and Task deployments.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#annotations}
  */
  readonly annotations?: string;
  /**
  * An optional configuration to add a prefix in the API URL path
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#api_urlpattern_prefix DataK8SAwxAnsibleComAwxV1Beta1Manifest#api_urlpattern_prefix}
  */
  readonly apiUrlpatternPrefix?: string;
  /**
  * apiVersion of the deployment type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#api_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Should AWX instances be automatically upgraded when operator gets upgraded
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#auto_upgrade DataK8SAwxAnsibleComAwxV1Beta1Manifest#auto_upgrade}
  */
  readonly autoUpgrade?: boolean | cdktf.IResolvable;
  /**
  * Secret where the broadcast websocket secret can be found
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#broadcast_websocket_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#broadcast_websocket_secret}
  */
  readonly broadcastWebsocketSecret?: string;
  /**
  * Secret where can be found the trusted Certificate Authority Bundle
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#bundle_cacert_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#bundle_cacert_secret}
  */
  readonly bundleCacertSecret?: string;
  /**
  * Path where the trusted CA bundle is available
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ca_trust_bundle DataK8SAwxAnsibleComAwxV1Beta1Manifest#ca_trust_bundle}
  */
  readonly caTrustBundle?: string;
  /**
  * Registry path to the Execution Environment container image to use on control plane pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#control_plane_ee_image DataK8SAwxAnsibleComAwxV1Beta1Manifest#control_plane_ee_image}
  */
  readonly controlPlaneEeImage?: string;
  /**
  * Assign a preexisting priority class to the control plane pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#control_plane_priority_class DataK8SAwxAnsibleComAwxV1Beta1Manifest#control_plane_priority_class}
  */
  readonly controlPlanePriorityClass?: string;
  /**
  * Whether or not to preload data upon instance creation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#create_preload_data DataK8SAwxAnsibleComAwxV1Beta1Manifest#create_preload_data}
  */
  readonly createPreloadData?: boolean | cdktf.IResolvable;
  /**
  * Set csrf cookie secure mode for web
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#csrf_cookie_secure DataK8SAwxAnsibleComAwxV1Beta1Manifest#csrf_cookie_secure}
  */
  readonly csrfCookieSecure?: string;
  /**
  * Name of the deployment type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#deployment_type DataK8SAwxAnsibleComAwxV1Beta1Manifest#deployment_type}
  */
  readonly deploymentType?: string;
  /**
  * If the deployment should be done in development mode
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#development_mode DataK8SAwxAnsibleComAwxV1Beta1Manifest#development_mode}
  */
  readonly developmentMode?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ee_extra_env DataK8SAwxAnsibleComAwxV1Beta1Manifest#ee_extra_env}
  */
  readonly eeExtraEnv?: string;
  /**
  * Specify volume mounts to be added to Execution container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ee_extra_volume_mounts DataK8SAwxAnsibleComAwxV1Beta1Manifest#ee_extra_volume_mounts}
  */
  readonly eeExtraVolumeMounts?: string;
  /**
  * Registry path to the Execution Environment container to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ee_images DataK8SAwxAnsibleComAwxV1Beta1Manifest#ee_images}
  */
  readonly eeImages?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages[] | cdktf.IResolvable;
  /**
  * Secret where pull credentials for registered ees can be found
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ee_pull_credentials_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#ee_pull_credentials_secret}
  */
  readonly eePullCredentialsSecret?: string;
  /**
  * Resource requirements for the ee container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ee_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#ee_resource_requirements}
  */
  readonly eeResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements;
  /**
  * Extra settings to specify for AWX
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#extra_settings DataK8SAwxAnsibleComAwxV1Beta1Manifest#extra_settings}
  */
  readonly extraSettings?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings[] | cdktf.IResolvable;
  /**
  * Extra ConfigMaps or Secrets of settings files to specify for AWX
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#extra_settings_files DataK8SAwxAnsibleComAwxV1Beta1Manifest#extra_settings_files}
  */
  readonly extraSettingsFiles?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles;
  /**
  * Specify extra volumes to add to the application pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#extra_volumes DataK8SAwxAnsibleComAwxV1Beta1Manifest#extra_volumes}
  */
  readonly extraVolumes?: string;
  /**
  * Whether or not to remove secrets upon instance removal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#garbage_collect_secrets DataK8SAwxAnsibleComAwxV1Beta1Manifest#garbage_collect_secrets}
  */
  readonly garbageCollectSecrets?: boolean | cdktf.IResolvable;
  /**
  * HostAliases for app containers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#host_aliases DataK8SAwxAnsibleComAwxV1Beta1Manifest#host_aliases}
  */
  readonly hostAliases?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases[] | cdktf.IResolvable;
  /**
  * (Deprecated) The hostname of the instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#hostname DataK8SAwxAnsibleComAwxV1Beta1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * Registry path to the application container to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#image DataK8SAwxAnsibleComAwxV1Beta1Manifest#image}
  */
  readonly image?: string;
  /**
  * The image pull policy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#image_pull_policy DataK8SAwxAnsibleComAwxV1Beta1Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * (Deprecated) Image pull secret for app and database containers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#image_pull_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#image_pull_secret}
  */
  readonly imagePullSecret?: string;
  /**
  * Image pull secrets for app and database containers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#image_pull_secrets DataK8SAwxAnsibleComAwxV1Beta1Manifest#image_pull_secrets}
  */
  readonly imagePullSecrets?: string[];
  /**
  * Application container image version to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#image_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#image_version}
  */
  readonly imageVersion?: string;
  /**
  * Annotations to add to the Ingress Controller
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_annotations}
  */
  readonly ingressAnnotations?: string;
  /**
  * The Ingress API version to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_api_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_api_version}
  */
  readonly ingressApiVersion?: string;
  /**
  * The name of ingress class to use instead of the cluster default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_class_name DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_class_name}
  */
  readonly ingressClassName?: string;
  /**
  * Special configuration for specific Ingress Controllers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_controller DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_controller}
  */
  readonly ingressController?: string;
  /**
  * Ingress hostnames of the instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_hosts DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_hosts}
  */
  readonly ingressHosts?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts[] | cdktf.IResolvable;
  /**
  * The ingress path used to reach the deployed service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_path DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_path}
  */
  readonly ingressPath?: string;
  /**
  * The ingress path type for the deployed service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_path_type DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_path_type}
  */
  readonly ingressPathType?: string;
  /**
  * (Deprecated) Secret where the Ingress TLS secret can be found
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_tls_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_tls_secret}
  */
  readonly ingressTlsSecret?: string;
  /**
  * The ingress type to use to reach the deployed instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ingress_type DataK8SAwxAnsibleComAwxV1Beta1Manifest#ingress_type}
  */
  readonly ingressType?: string;
  /**
  * Extra commands for the init container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#init_container_extra_commands DataK8SAwxAnsibleComAwxV1Beta1Manifest#init_container_extra_commands}
  */
  readonly initContainerExtraCommands?: string;
  /**
  * Specify volume mounts to be added to the init container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#init_container_extra_volume_mounts DataK8SAwxAnsibleComAwxV1Beta1Manifest#init_container_extra_volume_mounts}
  */
  readonly initContainerExtraVolumeMounts?: string;
  /**
  * Registry path to the init container to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#init_container_image DataK8SAwxAnsibleComAwxV1Beta1Manifest#init_container_image}
  */
  readonly initContainerImage?: string;
  /**
  * Init container image version to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#init_container_image_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#init_container_image_version}
  */
  readonly initContainerImageVersion?: string;
  /**
  * Resource requirements for the init container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#init_container_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#init_container_resource_requirements}
  */
  readonly initContainerResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements;
  /**
  * Registry path to the init projects container to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#init_projects_container_image DataK8SAwxAnsibleComAwxV1Beta1Manifest#init_projects_container_image}
  */
  readonly initProjectsContainerImage?: string;
  /**
  * Disable web container's nginx ipv6 listener
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ipv6_disabled DataK8SAwxAnsibleComAwxV1Beta1Manifest#ipv6_disabled}
  */
  readonly ipv6Disabled?: boolean | cdktf.IResolvable;
  /**
  * Kind of the deployment type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#kind DataK8SAwxAnsibleComAwxV1Beta1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * (Deprecated) Secret where can be found the LDAP trusted Certificate Authority Bundle
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ldap_cacert_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#ldap_cacert_secret}
  */
  readonly ldapCacertSecret?: string;
  /**
  * (Deprecated) Secret where can be found the LDAP bind password
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#ldap_password_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#ldap_password_secret}
  */
  readonly ldapPasswordSecret?: string;
  /**
  * Class of LoadBalancer to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#loadbalancer_class DataK8SAwxAnsibleComAwxV1Beta1Manifest#loadbalancer_class}
  */
  readonly loadbalancerClass?: string;
  /**
  * Assign LoadBalancer IP address
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#loadbalancer_ip DataK8SAwxAnsibleComAwxV1Beta1Manifest#loadbalancer_ip}
  */
  readonly loadbalancerIp?: string;
  /**
  * Port to use for the loadbalancer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#loadbalancer_port DataK8SAwxAnsibleComAwxV1Beta1Manifest#loadbalancer_port}
  */
  readonly loadbalancerPort?: number;
  /**
  * Protocol to use for the loadbalancer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#loadbalancer_protocol DataK8SAwxAnsibleComAwxV1Beta1Manifest#loadbalancer_protocol}
  */
  readonly loadbalancerProtocol?: string;
  /**
  * Metrics-Utility ConfigMap
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_configmap DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_configmap}
  */
  readonly metricsUtilityConfigmap?: string;
  /**
  * Enable metrics utility shipping to Red Hat Hybrid Cloud Console
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_console_enabled DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_console_enabled}
  */
  readonly metricsUtilityConsoleEnabled?: boolean | cdktf.IResolvable;
  /**
  * Metrics-Utility Gather Data CronJob Schedule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_cronjob_gather_schedule DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_cronjob_gather_schedule}
  */
  readonly metricsUtilityCronjobGatherSchedule?: string;
  /**
  * Metrics-Utility Report CronJob Schedule
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_cronjob_report_schedule DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_cronjob_report_schedule}
  */
  readonly metricsUtilityCronjobReportSchedule?: string;
  /**
  * Enable metrics utility
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_enabled DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_enabled}
  */
  readonly metricsUtilityEnabled?: boolean | cdktf.IResolvable;
  /**
  * Metrics-Utility Image
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_image DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_image}
  */
  readonly metricsUtilityImage?: string;
  /**
  * Metrics-Utility Image PullPolicy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_image_pull_policy DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_image_pull_policy}
  */
  readonly metricsUtilityImagePullPolicy?: string;
  /**
  * Metrics-Utility Image Version
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_image_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_image_version}
  */
  readonly metricsUtilityImageVersion?: string;
  /**
  * Metrics-Utility PVC Claim
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_pvc_claim DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_pvc_claim}
  */
  readonly metricsUtilityPvcClaim?: string;
  /**
  * Metrics-Utility PVC Claim Size
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_pvc_claim_size DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_pvc_claim_size}
  */
  readonly metricsUtilityPvcClaimSize?: string;
  /**
  * Metrics-Utility PVC Claim Storage Class
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_pvc_claim_storage_class DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_pvc_claim_storage_class}
  */
  readonly metricsUtilityPvcClaimStorageClass?: string;
  /**
  * Metrics-Utility Secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_secret}
  */
  readonly metricsUtilitySecret?: string;
  /**
  * Metrics-Utility Ship Target
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#metrics_utility_ship_target DataK8SAwxAnsibleComAwxV1Beta1Manifest#metrics_utility_ship_target}
  */
  readonly metricsUtilityShipTarget?: string;
  /**
  * Set the socket listen queue size for nginx (defaults to same as uwsgi)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#nginx_listen_queue_size DataK8SAwxAnsibleComAwxV1Beta1Manifest#nginx_listen_queue_size}
  */
  readonly nginxListenQueueSize?: number;
  /**
  * Set the number of connections per worker for nginx
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#nginx_worker_connections DataK8SAwxAnsibleComAwxV1Beta1Manifest#nginx_worker_connections}
  */
  readonly nginxWorkerConnections?: number;
  /**
  * Set the CPU affinity for nginx workers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#nginx_worker_cpu_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#nginx_worker_cpu_affinity}
  */
  readonly nginxWorkerCpuAffinity?: string;
  /**
  * Set the number of workers for nginx
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#nginx_worker_processes DataK8SAwxAnsibleComAwxV1Beta1Manifest#nginx_worker_processes}
  */
  readonly nginxWorkerProcesses?: number;
  /**
  * Configure no_log for no_log tasks
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#no_log DataK8SAwxAnsibleComAwxV1Beta1Manifest#no_log}
  */
  readonly noLog?: boolean | cdktf.IResolvable;
  /**
  * nodeSelector for the pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#node_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#node_selector}
  */
  readonly nodeSelector?: string;
  /**
  * Port to use for the nodeport
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#nodeport_port DataK8SAwxAnsibleComAwxV1Beta1Manifest#nodeport_port}
  */
  readonly nodeportPort?: number;
  /**
  * Secret where the old database configuration can be found for data migration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#old_postgres_configuration_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#old_postgres_configuration_secret}
  */
  readonly oldPostgresConfigurationSecret?: string;
  /**
  * Additional parameters for the pg_dump command during a migration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#pg_dump_suffix DataK8SAwxAnsibleComAwxV1Beta1Manifest#pg_dump_suffix}
  */
  readonly pgDumpSuffix?: string;
  /**
  * Annotations to add to the Postgres deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_annotations}
  */
  readonly postgresAnnotations?: string;
  /**
  * Secret where the database configuration can be found
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_configuration_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_configuration_secret}
  */
  readonly postgresConfigurationSecret?: string;
  /**
  * Sets permissions on the /var/lib/pgdata/data for postgres container using an init container (not Openshift)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_data_volume_init DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_data_volume_init}
  */
  readonly postgresDataVolumeInit?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_extra_args DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_extra_args}
  */
  readonly postgresExtraArgs?: string[];
  /**
  * Specify volume mounts to be added to Postgres container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_extra_volume_mounts DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_extra_volume_mounts}
  */
  readonly postgresExtraVolumeMounts?: string;
  /**
  * Specify extra volumes to add to the application pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_extra_volumes DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_extra_volumes}
  */
  readonly postgresExtraVolumes?: string;
  /**
  * Registry path to the PostgreSQL container to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_image DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_image}
  */
  readonly postgresImage?: string;
  /**
  * PostgreSQL container image version to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_image_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_image_version}
  */
  readonly postgresImageVersion?: string;
  /**
  * Customize the postgres init container commands (Non Openshift)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_init_container_commands DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_init_container_commands}
  */
  readonly postgresInitContainerCommands?: string;
  /**
  * (Deprecated, use postgres_resource_requirements parameter) Resource requirements for the postgres init container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_init_container_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_init_container_resource_requirements}
  */
  readonly postgresInitContainerResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements;
  /**
  * Specify whether or not to keep the old PVC after PostgreSQL upgrades
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_keep_pvc_after_upgrade DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_keep_pvc_after_upgrade}
  */
  readonly postgresKeepPvcAfterUpgrade?: boolean | cdktf.IResolvable;
  /**
  * Controls whether client-side TCP keepalives are used for Postgres connections.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_keepalives DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_keepalives}
  */
  readonly postgresKeepalives?: boolean | cdktf.IResolvable;
  /**
  * Controls the number of TCP keepalives that can be lost before the client's connection to the server is considered dead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_keepalives_count DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_keepalives_count}
  */
  readonly postgresKeepalivesCount?: number;
  /**
  * Controls the number of seconds of inactivity after which TCP should send a keepalive message to the server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_keepalives_idle DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_keepalives_idle}
  */
  readonly postgresKeepalivesIdle?: number;
  /**
  * Controls the number of seconds after which a TCP keepalive message that is not acknowledged by the server should be retransmitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_keepalives_interval DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_keepalives_interval}
  */
  readonly postgresKeepalivesInterval?: number;
  /**
  * Label selector used to identify postgres pod for data migration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_label_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_label_selector}
  */
  readonly postgresLabelSelector?: string;
  /**
  * Assign a preexisting priority class to the postgres pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_priority_class DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_priority_class}
  */
  readonly postgresPriorityClass?: string;
  /**
  * Resource requirements for the PostgreSQL container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_resource_requirements}
  */
  readonly postgresResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements;
  /**
  * Key/values that will be set under the pod-level securityContext field
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_security_context_settings DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_security_context_settings}
  */
  readonly postgresSecurityContextSettings?: { [key: string]: string };
  /**
  * nodeSelector for the Postgres pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_selector}
  */
  readonly postgresSelector?: string;
  /**
  * Storage class to use for the PostgreSQL PVC
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_storage_class DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_storage_class}
  */
  readonly postgresStorageClass?: string;
  /**
  * Storage requirements for the PostgreSQL container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_storage_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_storage_requirements}
  */
  readonly postgresStorageRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements;
  /**
  * node tolerations for the Postgres pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#postgres_tolerations DataK8SAwxAnsibleComAwxV1Beta1Manifest#postgres_tolerations}
  */
  readonly postgresTolerations?: string;
  /**
  * PersistentVolumeClaim to mount /var/lib/projects directory
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#projects_existing_claim DataK8SAwxAnsibleComAwxV1Beta1Manifest#projects_existing_claim}
  */
  readonly projectsExistingClaim?: string;
  /**
  * Whether or not the /var/lib/projects directory will be persistent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#projects_persistence DataK8SAwxAnsibleComAwxV1Beta1Manifest#projects_persistence}
  */
  readonly projectsPersistence?: boolean | cdktf.IResolvable;
  /**
  * AccessMode for the /var/lib/projects PersistentVolumeClaim
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#projects_storage_access_mode DataK8SAwxAnsibleComAwxV1Beta1Manifest#projects_storage_access_mode}
  */
  readonly projectsStorageAccessMode?: string;
  /**
  * Storage class for the /var/lib/projects PersistentVolumeClaim
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#projects_storage_class DataK8SAwxAnsibleComAwxV1Beta1Manifest#projects_storage_class}
  */
  readonly projectsStorageClass?: string;
  /**
  * Size for the /var/lib/projects PersistentVolumeClaim
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#projects_storage_size DataK8SAwxAnsibleComAwxV1Beta1Manifest#projects_storage_size}
  */
  readonly projectsStorageSize?: string;
  /**
  * Using existing PersistentVolumeClaim
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#projects_use_existing_claim DataK8SAwxAnsibleComAwxV1Beta1Manifest#projects_use_existing_claim}
  */
  readonly projectsUseExistingClaim?: string;
  /**
  * Set log level of receptor service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#receptor_log_level DataK8SAwxAnsibleComAwxV1Beta1Manifest#receptor_log_level}
  */
  readonly receptorLogLevel?: string;
  /**
  * Redis container capabilities
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#redis_capabilities DataK8SAwxAnsibleComAwxV1Beta1Manifest#redis_capabilities}
  */
  readonly redisCapabilities?: string[];
  /**
  * Registry path to the redis container to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#redis_image DataK8SAwxAnsibleComAwxV1Beta1Manifest#redis_image}
  */
  readonly redisImage?: string;
  /**
  * Redis container image version to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#redis_image_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#redis_image_version}
  */
  readonly redisImageVersion?: string;
  /**
  * Resource requirements for the redis container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#redis_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#redis_resource_requirements}
  */
  readonly redisResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements;
  /**
  * Number of instance replicas
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#replicas DataK8SAwxAnsibleComAwxV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * The route API version to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#route_api_version DataK8SAwxAnsibleComAwxV1Beta1Manifest#route_api_version}
  */
  readonly routeApiVersion?: string;
  /**
  * The DNS to use to points to the instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#route_host DataK8SAwxAnsibleComAwxV1Beta1Manifest#route_host}
  */
  readonly routeHost?: string;
  /**
  * Secret where the TLS related credentials are stored
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#route_tls_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#route_tls_secret}
  */
  readonly routeTlsSecret?: string;
  /**
  * The secure TLS termination mechanism to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#route_tls_termination_mechanism DataK8SAwxAnsibleComAwxV1Beta1Manifest#route_tls_termination_mechanism}
  */
  readonly routeTlsTerminationMechanism?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#rsyslog_args DataK8SAwxAnsibleComAwxV1Beta1Manifest#rsyslog_args}
  */
  readonly rsyslogArgs?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#rsyslog_command DataK8SAwxAnsibleComAwxV1Beta1Manifest#rsyslog_command}
  */
  readonly rsyslogCommand?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#rsyslog_extra_env DataK8SAwxAnsibleComAwxV1Beta1Manifest#rsyslog_extra_env}
  */
  readonly rsyslogExtraEnv?: string;
  /**
  * Specify volume mounts to be added to the Rsyslog container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#rsyslog_extra_volume_mounts DataK8SAwxAnsibleComAwxV1Beta1Manifest#rsyslog_extra_volume_mounts}
  */
  readonly rsyslogExtraVolumeMounts?: string;
  /**
  * Resource requirements for the rsyslog container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#rsyslog_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#rsyslog_resource_requirements}
  */
  readonly rsyslogResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements;
  /**
  * Secret where the secret key can be found
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#secret_key_secret DataK8SAwxAnsibleComAwxV1Beta1Manifest#secret_key_secret}
  */
  readonly secretKeySecret?: string;
  /**
  * Key/values that will be set under the pod-level securityContext field
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#security_context_settings DataK8SAwxAnsibleComAwxV1Beta1Manifest#security_context_settings}
  */
  readonly securityContextSettings?: { [key: string]: string };
  /**
  * ServiceAccount annotations
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#service_account_annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#service_account_annotations}
  */
  readonly serviceAccountAnnotations?: string;
  /**
  * Annotations to add to the service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#service_annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#service_annotations}
  */
  readonly serviceAnnotations?: string;
  /**
  * Additional labels to apply to the service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#service_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#service_labels}
  */
  readonly serviceLabels?: string;
  /**
  * The service type to be used on the deployed instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#service_type DataK8SAwxAnsibleComAwxV1Beta1Manifest#service_type}
  */
  readonly serviceType?: string;
  /**
  * Set session cookie secure mode for web
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#session_cookie_secure DataK8SAwxAnsibleComAwxV1Beta1Manifest#session_cookie_secure}
  */
  readonly sessionCookieSecure?: string;
  /**
  * Maintain some of the recommended 'app.kubernetes.io/*' labels on the resource (self)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#set_self_labels DataK8SAwxAnsibleComAwxV1Beta1Manifest#set_self_labels}
  */
  readonly setSelfLabels?: boolean | cdktf.IResolvable;
  /**
  * If specified, the pod's scheduling constraints
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_affinity}
  */
  readonly taskAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity;
  /**
  * Task deployment annotations. This will override the general annotations parameter for the Task deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_annotations}
  */
  readonly taskAnnotations?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_args DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_args}
  */
  readonly taskArgs?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_command DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_command}
  */
  readonly taskCommand?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_extra_env DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_extra_env}
  */
  readonly taskExtraEnv?: string;
  /**
  * Specify volume mounts to be added to Task container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_extra_volume_mounts DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_extra_volume_mounts}
  */
  readonly taskExtraVolumeMounts?: string;
  /**
  * Number of consecutive failure events to identify failure of task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_liveness_failure_threshold DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_liveness_failure_threshold}
  */
  readonly taskLivenessFailureThreshold?: number;
  /**
  * Initial delay before starting liveness checks on task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_liveness_initial_delay DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_liveness_initial_delay}
  */
  readonly taskLivenessInitialDelay?: number;
  /**
  * Time period in seconds between each liveness check for the task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_liveness_period DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_liveness_period}
  */
  readonly taskLivenessPeriod?: number;
  /**
  * Number of seconds to wait for a probe response from task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_liveness_timeout DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_liveness_timeout}
  */
  readonly taskLivenessTimeout?: number;
  /**
  * Enables operator control of replicas count for the task deployment when set to 'true'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_manage_replicas DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_manage_replicas}
  */
  readonly taskManageReplicas?: boolean | cdktf.IResolvable;
  /**
  * nodeSelector for the task pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_node_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_node_selector}
  */
  readonly taskNodeSelector?: string;
  /**
  * If a privileged security context should be enabled
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_privileged DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_privileged}
  */
  readonly taskPrivileged?: boolean | cdktf.IResolvable;
  /**
  * Number of consecutive failure events to identify failure of task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_readiness_failure_threshold DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_readiness_failure_threshold}
  */
  readonly taskReadinessFailureThreshold?: number;
  /**
  * Initial delay before starting readiness checks on task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_readiness_initial_delay DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_readiness_initial_delay}
  */
  readonly taskReadinessInitialDelay?: number;
  /**
  * Time period in seconds between each readiness check for the task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_readiness_period DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_readiness_period}
  */
  readonly taskReadinessPeriod?: number;
  /**
  * Number of seconds to wait for a probe response from task pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_readiness_timeout DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_readiness_timeout}
  */
  readonly taskReadinessTimeout?: number;
  /**
  * Number of task instance replicas
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_replicas DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_replicas}
  */
  readonly taskReplicas?: number;
  /**
  * Resource requirements for the task container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_resource_requirements}
  */
  readonly taskResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements;
  /**
  * node tolerations for the task pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_tolerations DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_tolerations}
  */
  readonly taskTolerations?: string;
  /**
  * topology rule(s) for the task pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#task_topology_spread_constraints DataK8SAwxAnsibleComAwxV1Beta1Manifest#task_topology_spread_constraints}
  */
  readonly taskTopologySpreadConstraints?: string;
  /**
  * Optional duration in seconds pods needs to terminate gracefully
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#termination_grace_period_seconds DataK8SAwxAnsibleComAwxV1Beta1Manifest#termination_grace_period_seconds}
  */
  readonly terminationGracePeriodSeconds?: number;
  /**
  * node tolerations for the pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#tolerations DataK8SAwxAnsibleComAwxV1Beta1Manifest#tolerations}
  */
  readonly tolerations?: string;
  /**
  * topology rule(s) for the pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#topology_spread_constraints DataK8SAwxAnsibleComAwxV1Beta1Manifest#topology_spread_constraints}
  */
  readonly topologySpreadConstraints?: string;
  /**
  * Set the socket listen queue size for uwsgi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#uwsgi_listen_queue_size DataK8SAwxAnsibleComAwxV1Beta1Manifest#uwsgi_listen_queue_size}
  */
  readonly uwsgiListenQueueSize?: number;
  /**
  * Set the number of uwsgi processes to run in a web container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#uwsgi_processes DataK8SAwxAnsibleComAwxV1Beta1Manifest#uwsgi_processes}
  */
  readonly uwsgiProcesses?: number;
  /**
  * If specified, the pod's scheduling constraints
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_affinity DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_affinity}
  */
  readonly webAffinity?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity;
  /**
  * Web deployment annotations. This will override the general annotations parameter for the Web deployment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_annotations DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_annotations}
  */
  readonly webAnnotations?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_args DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_args}
  */
  readonly webArgs?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_command DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_command}
  */
  readonly webCommand?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_extra_env DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_extra_env}
  */
  readonly webExtraEnv?: string;
  /**
  * Specify volume mounts to be added to the Web container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_extra_volume_mounts DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_extra_volume_mounts}
  */
  readonly webExtraVolumeMounts?: string;
  /**
  * Number of consecutive failure events to identify failure of web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_liveness_failure_threshold DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_liveness_failure_threshold}
  */
  readonly webLivenessFailureThreshold?: number;
  /**
  * Initial delay before starting liveness checks on web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_liveness_initial_delay DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_liveness_initial_delay}
  */
  readonly webLivenessInitialDelay?: number;
  /**
  * Time period in seconds between each liveness check for the web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_liveness_period DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_liveness_period}
  */
  readonly webLivenessPeriod?: number;
  /**
  * Number of seconds to wait for a probe response from web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_liveness_timeout DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_liveness_timeout}
  */
  readonly webLivenessTimeout?: number;
  /**
  * Enables operator control of replicas count for the web deployment when set to 'true'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_manage_replicas DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_manage_replicas}
  */
  readonly webManageReplicas?: boolean | cdktf.IResolvable;
  /**
  * nodeSelector for the web pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_node_selector DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_node_selector}
  */
  readonly webNodeSelector?: string;
  /**
  * Number of consecutive failure events to identify failure of web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_readiness_failure_threshold DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_readiness_failure_threshold}
  */
  readonly webReadinessFailureThreshold?: number;
  /**
  * Initial delay before starting readiness checks on web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_readiness_initial_delay DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_readiness_initial_delay}
  */
  readonly webReadinessInitialDelay?: number;
  /**
  * Time period in seconds between each readiness check for the web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_readiness_period DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_readiness_period}
  */
  readonly webReadinessPeriod?: number;
  /**
  * Number of seconds to wait for a probe response from web pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_readiness_timeout DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_readiness_timeout}
  */
  readonly webReadinessTimeout?: number;
  /**
  * Number of web instance replicas
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_replicas DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_replicas}
  */
  readonly webReplicas?: number;
  /**
  * Resource requirements for the web container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_resource_requirements DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_resource_requirements}
  */
  readonly webResourceRequirements?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements;
  /**
  * node tolerations for the web pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_tolerations DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_tolerations}
  */
  readonly webTolerations?: string;
  /**
  * topology rule(s) for the web pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#web_topology_spread_constraints DataK8SAwxAnsibleComAwxV1Beta1Manifest#web_topology_spread_constraints}
  */
  readonly webTopologySpreadConstraints?: string;
}

export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecToTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalLabels),
    admin_email: cdktf.stringToTerraform(struct!.adminEmail),
    admin_password_secret: cdktf.stringToTerraform(struct!.adminPasswordSecret),
    admin_user: cdktf.stringToTerraform(struct!.adminUser),
    affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityToTerraform(struct!.affinity),
    annotations: cdktf.stringToTerraform(struct!.annotations),
    api_urlpattern_prefix: cdktf.stringToTerraform(struct!.apiUrlpatternPrefix),
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auto_upgrade: cdktf.booleanToTerraform(struct!.autoUpgrade),
    broadcast_websocket_secret: cdktf.stringToTerraform(struct!.broadcastWebsocketSecret),
    bundle_cacert_secret: cdktf.stringToTerraform(struct!.bundleCacertSecret),
    ca_trust_bundle: cdktf.stringToTerraform(struct!.caTrustBundle),
    control_plane_ee_image: cdktf.stringToTerraform(struct!.controlPlaneEeImage),
    control_plane_priority_class: cdktf.stringToTerraform(struct!.controlPlanePriorityClass),
    create_preload_data: cdktf.booleanToTerraform(struct!.createPreloadData),
    csrf_cookie_secure: cdktf.stringToTerraform(struct!.csrfCookieSecure),
    deployment_type: cdktf.stringToTerraform(struct!.deploymentType),
    development_mode: cdktf.booleanToTerraform(struct!.developmentMode),
    ee_extra_env: cdktf.stringToTerraform(struct!.eeExtraEnv),
    ee_extra_volume_mounts: cdktf.stringToTerraform(struct!.eeExtraVolumeMounts),
    ee_images: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesToTerraform, false)(struct!.eeImages),
    ee_pull_credentials_secret: cdktf.stringToTerraform(struct!.eePullCredentialsSecret),
    ee_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsToTerraform(struct!.eeResourceRequirements),
    extra_settings: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsToTerraform, false)(struct!.extraSettings),
    extra_settings_files: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesToTerraform(struct!.extraSettingsFiles),
    extra_volumes: cdktf.stringToTerraform(struct!.extraVolumes),
    garbage_collect_secrets: cdktf.booleanToTerraform(struct!.garbageCollectSecrets),
    host_aliases: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesToTerraform, false)(struct!.hostAliases),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    image_pull_secret: cdktf.stringToTerraform(struct!.imagePullSecret),
    image_pull_secrets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.imagePullSecrets),
    image_version: cdktf.stringToTerraform(struct!.imageVersion),
    ingress_annotations: cdktf.stringToTerraform(struct!.ingressAnnotations),
    ingress_api_version: cdktf.stringToTerraform(struct!.ingressApiVersion),
    ingress_class_name: cdktf.stringToTerraform(struct!.ingressClassName),
    ingress_controller: cdktf.stringToTerraform(struct!.ingressController),
    ingress_hosts: cdktf.listMapper(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsToTerraform, false)(struct!.ingressHosts),
    ingress_path: cdktf.stringToTerraform(struct!.ingressPath),
    ingress_path_type: cdktf.stringToTerraform(struct!.ingressPathType),
    ingress_tls_secret: cdktf.stringToTerraform(struct!.ingressTlsSecret),
    ingress_type: cdktf.stringToTerraform(struct!.ingressType),
    init_container_extra_commands: cdktf.stringToTerraform(struct!.initContainerExtraCommands),
    init_container_extra_volume_mounts: cdktf.stringToTerraform(struct!.initContainerExtraVolumeMounts),
    init_container_image: cdktf.stringToTerraform(struct!.initContainerImage),
    init_container_image_version: cdktf.stringToTerraform(struct!.initContainerImageVersion),
    init_container_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsToTerraform(struct!.initContainerResourceRequirements),
    init_projects_container_image: cdktf.stringToTerraform(struct!.initProjectsContainerImage),
    ipv6_disabled: cdktf.booleanToTerraform(struct!.ipv6Disabled),
    kind: cdktf.stringToTerraform(struct!.kind),
    ldap_cacert_secret: cdktf.stringToTerraform(struct!.ldapCacertSecret),
    ldap_password_secret: cdktf.stringToTerraform(struct!.ldapPasswordSecret),
    loadbalancer_class: cdktf.stringToTerraform(struct!.loadbalancerClass),
    loadbalancer_ip: cdktf.stringToTerraform(struct!.loadbalancerIp),
    loadbalancer_port: cdktf.numberToTerraform(struct!.loadbalancerPort),
    loadbalancer_protocol: cdktf.stringToTerraform(struct!.loadbalancerProtocol),
    metrics_utility_configmap: cdktf.stringToTerraform(struct!.metricsUtilityConfigmap),
    metrics_utility_console_enabled: cdktf.booleanToTerraform(struct!.metricsUtilityConsoleEnabled),
    metrics_utility_cronjob_gather_schedule: cdktf.stringToTerraform(struct!.metricsUtilityCronjobGatherSchedule),
    metrics_utility_cronjob_report_schedule: cdktf.stringToTerraform(struct!.metricsUtilityCronjobReportSchedule),
    metrics_utility_enabled: cdktf.booleanToTerraform(struct!.metricsUtilityEnabled),
    metrics_utility_image: cdktf.stringToTerraform(struct!.metricsUtilityImage),
    metrics_utility_image_pull_policy: cdktf.stringToTerraform(struct!.metricsUtilityImagePullPolicy),
    metrics_utility_image_version: cdktf.stringToTerraform(struct!.metricsUtilityImageVersion),
    metrics_utility_pvc_claim: cdktf.stringToTerraform(struct!.metricsUtilityPvcClaim),
    metrics_utility_pvc_claim_size: cdktf.stringToTerraform(struct!.metricsUtilityPvcClaimSize),
    metrics_utility_pvc_claim_storage_class: cdktf.stringToTerraform(struct!.metricsUtilityPvcClaimStorageClass),
    metrics_utility_secret: cdktf.stringToTerraform(struct!.metricsUtilitySecret),
    metrics_utility_ship_target: cdktf.stringToTerraform(struct!.metricsUtilityShipTarget),
    nginx_listen_queue_size: cdktf.numberToTerraform(struct!.nginxListenQueueSize),
    nginx_worker_connections: cdktf.numberToTerraform(struct!.nginxWorkerConnections),
    nginx_worker_cpu_affinity: cdktf.stringToTerraform(struct!.nginxWorkerCpuAffinity),
    nginx_worker_processes: cdktf.numberToTerraform(struct!.nginxWorkerProcesses),
    no_log: cdktf.booleanToTerraform(struct!.noLog),
    node_selector: cdktf.stringToTerraform(struct!.nodeSelector),
    nodeport_port: cdktf.numberToTerraform(struct!.nodeportPort),
    old_postgres_configuration_secret: cdktf.stringToTerraform(struct!.oldPostgresConfigurationSecret),
    pg_dump_suffix: cdktf.stringToTerraform(struct!.pgDumpSuffix),
    postgres_annotations: cdktf.stringToTerraform(struct!.postgresAnnotations),
    postgres_configuration_secret: cdktf.stringToTerraform(struct!.postgresConfigurationSecret),
    postgres_data_volume_init: cdktf.booleanToTerraform(struct!.postgresDataVolumeInit),
    postgres_extra_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.postgresExtraArgs),
    postgres_extra_volume_mounts: cdktf.stringToTerraform(struct!.postgresExtraVolumeMounts),
    postgres_extra_volumes: cdktf.stringToTerraform(struct!.postgresExtraVolumes),
    postgres_image: cdktf.stringToTerraform(struct!.postgresImage),
    postgres_image_version: cdktf.stringToTerraform(struct!.postgresImageVersion),
    postgres_init_container_commands: cdktf.stringToTerraform(struct!.postgresInitContainerCommands),
    postgres_init_container_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsToTerraform(struct!.postgresInitContainerResourceRequirements),
    postgres_keep_pvc_after_upgrade: cdktf.booleanToTerraform(struct!.postgresKeepPvcAfterUpgrade),
    postgres_keepalives: cdktf.booleanToTerraform(struct!.postgresKeepalives),
    postgres_keepalives_count: cdktf.numberToTerraform(struct!.postgresKeepalivesCount),
    postgres_keepalives_idle: cdktf.numberToTerraform(struct!.postgresKeepalivesIdle),
    postgres_keepalives_interval: cdktf.numberToTerraform(struct!.postgresKeepalivesInterval),
    postgres_label_selector: cdktf.stringToTerraform(struct!.postgresLabelSelector),
    postgres_priority_class: cdktf.stringToTerraform(struct!.postgresPriorityClass),
    postgres_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsToTerraform(struct!.postgresResourceRequirements),
    postgres_security_context_settings: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.postgresSecurityContextSettings),
    postgres_selector: cdktf.stringToTerraform(struct!.postgresSelector),
    postgres_storage_class: cdktf.stringToTerraform(struct!.postgresStorageClass),
    postgres_storage_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsToTerraform(struct!.postgresStorageRequirements),
    postgres_tolerations: cdktf.stringToTerraform(struct!.postgresTolerations),
    projects_existing_claim: cdktf.stringToTerraform(struct!.projectsExistingClaim),
    projects_persistence: cdktf.booleanToTerraform(struct!.projectsPersistence),
    projects_storage_access_mode: cdktf.stringToTerraform(struct!.projectsStorageAccessMode),
    projects_storage_class: cdktf.stringToTerraform(struct!.projectsStorageClass),
    projects_storage_size: cdktf.stringToTerraform(struct!.projectsStorageSize),
    projects_use_existing_claim: cdktf.stringToTerraform(struct!.projectsUseExistingClaim),
    receptor_log_level: cdktf.stringToTerraform(struct!.receptorLogLevel),
    redis_capabilities: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.redisCapabilities),
    redis_image: cdktf.stringToTerraform(struct!.redisImage),
    redis_image_version: cdktf.stringToTerraform(struct!.redisImageVersion),
    redis_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsToTerraform(struct!.redisResourceRequirements),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    route_api_version: cdktf.stringToTerraform(struct!.routeApiVersion),
    route_host: cdktf.stringToTerraform(struct!.routeHost),
    route_tls_secret: cdktf.stringToTerraform(struct!.routeTlsSecret),
    route_tls_termination_mechanism: cdktf.stringToTerraform(struct!.routeTlsTerminationMechanism),
    rsyslog_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.rsyslogArgs),
    rsyslog_command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.rsyslogCommand),
    rsyslog_extra_env: cdktf.stringToTerraform(struct!.rsyslogExtraEnv),
    rsyslog_extra_volume_mounts: cdktf.stringToTerraform(struct!.rsyslogExtraVolumeMounts),
    rsyslog_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsToTerraform(struct!.rsyslogResourceRequirements),
    secret_key_secret: cdktf.stringToTerraform(struct!.secretKeySecret),
    security_context_settings: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.securityContextSettings),
    service_account_annotations: cdktf.stringToTerraform(struct!.serviceAccountAnnotations),
    service_annotations: cdktf.stringToTerraform(struct!.serviceAnnotations),
    service_labels: cdktf.stringToTerraform(struct!.serviceLabels),
    service_type: cdktf.stringToTerraform(struct!.serviceType),
    session_cookie_secure: cdktf.stringToTerraform(struct!.sessionCookieSecure),
    set_self_labels: cdktf.booleanToTerraform(struct!.setSelfLabels),
    task_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityToTerraform(struct!.taskAffinity),
    task_annotations: cdktf.stringToTerraform(struct!.taskAnnotations),
    task_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.taskArgs),
    task_command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.taskCommand),
    task_extra_env: cdktf.stringToTerraform(struct!.taskExtraEnv),
    task_extra_volume_mounts: cdktf.stringToTerraform(struct!.taskExtraVolumeMounts),
    task_liveness_failure_threshold: cdktf.numberToTerraform(struct!.taskLivenessFailureThreshold),
    task_liveness_initial_delay: cdktf.numberToTerraform(struct!.taskLivenessInitialDelay),
    task_liveness_period: cdktf.numberToTerraform(struct!.taskLivenessPeriod),
    task_liveness_timeout: cdktf.numberToTerraform(struct!.taskLivenessTimeout),
    task_manage_replicas: cdktf.booleanToTerraform(struct!.taskManageReplicas),
    task_node_selector: cdktf.stringToTerraform(struct!.taskNodeSelector),
    task_privileged: cdktf.booleanToTerraform(struct!.taskPrivileged),
    task_readiness_failure_threshold: cdktf.numberToTerraform(struct!.taskReadinessFailureThreshold),
    task_readiness_initial_delay: cdktf.numberToTerraform(struct!.taskReadinessInitialDelay),
    task_readiness_period: cdktf.numberToTerraform(struct!.taskReadinessPeriod),
    task_readiness_timeout: cdktf.numberToTerraform(struct!.taskReadinessTimeout),
    task_replicas: cdktf.numberToTerraform(struct!.taskReplicas),
    task_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsToTerraform(struct!.taskResourceRequirements),
    task_tolerations: cdktf.stringToTerraform(struct!.taskTolerations),
    task_topology_spread_constraints: cdktf.stringToTerraform(struct!.taskTopologySpreadConstraints),
    termination_grace_period_seconds: cdktf.numberToTerraform(struct!.terminationGracePeriodSeconds),
    tolerations: cdktf.stringToTerraform(struct!.tolerations),
    topology_spread_constraints: cdktf.stringToTerraform(struct!.topologySpreadConstraints),
    uwsgi_listen_queue_size: cdktf.numberToTerraform(struct!.uwsgiListenQueueSize),
    uwsgi_processes: cdktf.numberToTerraform(struct!.uwsgiProcesses),
    web_affinity: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityToTerraform(struct!.webAffinity),
    web_annotations: cdktf.stringToTerraform(struct!.webAnnotations),
    web_args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.webArgs),
    web_command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.webCommand),
    web_extra_env: cdktf.stringToTerraform(struct!.webExtraEnv),
    web_extra_volume_mounts: cdktf.stringToTerraform(struct!.webExtraVolumeMounts),
    web_liveness_failure_threshold: cdktf.numberToTerraform(struct!.webLivenessFailureThreshold),
    web_liveness_initial_delay: cdktf.numberToTerraform(struct!.webLivenessInitialDelay),
    web_liveness_period: cdktf.numberToTerraform(struct!.webLivenessPeriod),
    web_liveness_timeout: cdktf.numberToTerraform(struct!.webLivenessTimeout),
    web_manage_replicas: cdktf.booleanToTerraform(struct!.webManageReplicas),
    web_node_selector: cdktf.stringToTerraform(struct!.webNodeSelector),
    web_readiness_failure_threshold: cdktf.numberToTerraform(struct!.webReadinessFailureThreshold),
    web_readiness_initial_delay: cdktf.numberToTerraform(struct!.webReadinessInitialDelay),
    web_readiness_period: cdktf.numberToTerraform(struct!.webReadinessPeriod),
    web_readiness_timeout: cdktf.numberToTerraform(struct!.webReadinessTimeout),
    web_replicas: cdktf.numberToTerraform(struct!.webReplicas),
    web_resource_requirements: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsToTerraform(struct!.webResourceRequirements),
    web_tolerations: cdktf.stringToTerraform(struct!.webTolerations),
    web_topology_spread_constraints: cdktf.stringToTerraform(struct!.webTopologySpreadConstraints),
  }
}


export function dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecToHclTerraform(struct?: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalLabels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    admin_email: {
      value: cdktf.stringToHclTerraform(struct!.adminEmail),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    admin_password_secret: {
      value: cdktf.stringToHclTerraform(struct!.adminPasswordSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    admin_user: {
      value: cdktf.stringToHclTerraform(struct!.adminUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityToHclTerraform(struct!.affinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity",
    },
    annotations: {
      value: cdktf.stringToHclTerraform(struct!.annotations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_urlpattern_prefix: {
      value: cdktf.stringToHclTerraform(struct!.apiUrlpatternPrefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auto_upgrade: {
      value: cdktf.booleanToHclTerraform(struct!.autoUpgrade),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    broadcast_websocket_secret: {
      value: cdktf.stringToHclTerraform(struct!.broadcastWebsocketSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bundle_cacert_secret: {
      value: cdktf.stringToHclTerraform(struct!.bundleCacertSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_trust_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caTrustBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    control_plane_ee_image: {
      value: cdktf.stringToHclTerraform(struct!.controlPlaneEeImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    control_plane_priority_class: {
      value: cdktf.stringToHclTerraform(struct!.controlPlanePriorityClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create_preload_data: {
      value: cdktf.booleanToHclTerraform(struct!.createPreloadData),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    csrf_cookie_secure: {
      value: cdktf.stringToHclTerraform(struct!.csrfCookieSecure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deployment_type: {
      value: cdktf.stringToHclTerraform(struct!.deploymentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    development_mode: {
      value: cdktf.booleanToHclTerraform(struct!.developmentMode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ee_extra_env: {
      value: cdktf.stringToHclTerraform(struct!.eeExtraEnv),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ee_extra_volume_mounts: {
      value: cdktf.stringToHclTerraform(struct!.eeExtraVolumeMounts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ee_images: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesToHclTerraform, false)(struct!.eeImages),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesList",
    },
    ee_pull_credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.eePullCredentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ee_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsToHclTerraform(struct!.eeResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements",
    },
    extra_settings: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsToHclTerraform, false)(struct!.extraSettings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsList",
    },
    extra_settings_files: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesToHclTerraform(struct!.extraSettingsFiles),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles",
    },
    extra_volumes: {
      value: cdktf.stringToHclTerraform(struct!.extraVolumes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    garbage_collect_secrets: {
      value: cdktf.booleanToHclTerraform(struct!.garbageCollectSecrets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host_aliases: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesToHclTerraform, false)(struct!.hostAliases),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesList",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secret: {
      value: cdktf.stringToHclTerraform(struct!.imagePullSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secrets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.imagePullSecrets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    image_version: {
      value: cdktf.stringToHclTerraform(struct!.imageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_annotations: {
      value: cdktf.stringToHclTerraform(struct!.ingressAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_api_version: {
      value: cdktf.stringToHclTerraform(struct!.ingressApiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_class_name: {
      value: cdktf.stringToHclTerraform(struct!.ingressClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_controller: {
      value: cdktf.stringToHclTerraform(struct!.ingressController),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_hosts: {
      value: cdktf.listMapperHcl(dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsToHclTerraform, false)(struct!.ingressHosts),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsList",
    },
    ingress_path: {
      value: cdktf.stringToHclTerraform(struct!.ingressPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_path_type: {
      value: cdktf.stringToHclTerraform(struct!.ingressPathType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_tls_secret: {
      value: cdktf.stringToHclTerraform(struct!.ingressTlsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_type: {
      value: cdktf.stringToHclTerraform(struct!.ingressType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_container_extra_commands: {
      value: cdktf.stringToHclTerraform(struct!.initContainerExtraCommands),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_container_extra_volume_mounts: {
      value: cdktf.stringToHclTerraform(struct!.initContainerExtraVolumeMounts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_container_image: {
      value: cdktf.stringToHclTerraform(struct!.initContainerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_container_image_version: {
      value: cdktf.stringToHclTerraform(struct!.initContainerImageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    init_container_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsToHclTerraform(struct!.initContainerResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements",
    },
    init_projects_container_image: {
      value: cdktf.stringToHclTerraform(struct!.initProjectsContainerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ipv6_disabled: {
      value: cdktf.booleanToHclTerraform(struct!.ipv6Disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ldap_cacert_secret: {
      value: cdktf.stringToHclTerraform(struct!.ldapCacertSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ldap_password_secret: {
      value: cdktf.stringToHclTerraform(struct!.ldapPasswordSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loadbalancer_class: {
      value: cdktf.stringToHclTerraform(struct!.loadbalancerClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loadbalancer_ip: {
      value: cdktf.stringToHclTerraform(struct!.loadbalancerIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    loadbalancer_port: {
      value: cdktf.numberToHclTerraform(struct!.loadbalancerPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    loadbalancer_protocol: {
      value: cdktf.stringToHclTerraform(struct!.loadbalancerProtocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_configmap: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityConfigmap),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_console_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.metricsUtilityConsoleEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metrics_utility_cronjob_gather_schedule: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityCronjobGatherSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_cronjob_report_schedule: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityCronjobReportSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.metricsUtilityEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metrics_utility_image: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityImagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_image_version: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityImageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_pvc_claim: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityPvcClaim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_pvc_claim_size: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityPvcClaimSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_pvc_claim_storage_class: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityPvcClaimStorageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_secret: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilitySecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_utility_ship_target: {
      value: cdktf.stringToHclTerraform(struct!.metricsUtilityShipTarget),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nginx_listen_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.nginxListenQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nginx_worker_connections: {
      value: cdktf.numberToHclTerraform(struct!.nginxWorkerConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    nginx_worker_cpu_affinity: {
      value: cdktf.stringToHclTerraform(struct!.nginxWorkerCpuAffinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nginx_worker_processes: {
      value: cdktf.numberToHclTerraform(struct!.nginxWorkerProcesses),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    no_log: {
      value: cdktf.booleanToHclTerraform(struct!.noLog),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    node_selector: {
      value: cdktf.stringToHclTerraform(struct!.nodeSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nodeport_port: {
      value: cdktf.numberToHclTerraform(struct!.nodeportPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    old_postgres_configuration_secret: {
      value: cdktf.stringToHclTerraform(struct!.oldPostgresConfigurationSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pg_dump_suffix: {
      value: cdktf.stringToHclTerraform(struct!.pgDumpSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_annotations: {
      value: cdktf.stringToHclTerraform(struct!.postgresAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_configuration_secret: {
      value: cdktf.stringToHclTerraform(struct!.postgresConfigurationSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_data_volume_init: {
      value: cdktf.booleanToHclTerraform(struct!.postgresDataVolumeInit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    postgres_extra_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.postgresExtraArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    postgres_extra_volume_mounts: {
      value: cdktf.stringToHclTerraform(struct!.postgresExtraVolumeMounts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_extra_volumes: {
      value: cdktf.stringToHclTerraform(struct!.postgresExtraVolumes),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_image: {
      value: cdktf.stringToHclTerraform(struct!.postgresImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_image_version: {
      value: cdktf.stringToHclTerraform(struct!.postgresImageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_init_container_commands: {
      value: cdktf.stringToHclTerraform(struct!.postgresInitContainerCommands),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_init_container_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsToHclTerraform(struct!.postgresInitContainerResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements",
    },
    postgres_keep_pvc_after_upgrade: {
      value: cdktf.booleanToHclTerraform(struct!.postgresKeepPvcAfterUpgrade),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    postgres_keepalives: {
      value: cdktf.booleanToHclTerraform(struct!.postgresKeepalives),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    postgres_keepalives_count: {
      value: cdktf.numberToHclTerraform(struct!.postgresKeepalivesCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    postgres_keepalives_idle: {
      value: cdktf.numberToHclTerraform(struct!.postgresKeepalivesIdle),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    postgres_keepalives_interval: {
      value: cdktf.numberToHclTerraform(struct!.postgresKeepalivesInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    postgres_label_selector: {
      value: cdktf.stringToHclTerraform(struct!.postgresLabelSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_priority_class: {
      value: cdktf.stringToHclTerraform(struct!.postgresPriorityClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsToHclTerraform(struct!.postgresResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements",
    },
    postgres_security_context_settings: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.postgresSecurityContextSettings),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    postgres_selector: {
      value: cdktf.stringToHclTerraform(struct!.postgresSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_storage_class: {
      value: cdktf.stringToHclTerraform(struct!.postgresStorageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_storage_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsToHclTerraform(struct!.postgresStorageRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements",
    },
    postgres_tolerations: {
      value: cdktf.stringToHclTerraform(struct!.postgresTolerations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    projects_existing_claim: {
      value: cdktf.stringToHclTerraform(struct!.projectsExistingClaim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    projects_persistence: {
      value: cdktf.booleanToHclTerraform(struct!.projectsPersistence),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    projects_storage_access_mode: {
      value: cdktf.stringToHclTerraform(struct!.projectsStorageAccessMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    projects_storage_class: {
      value: cdktf.stringToHclTerraform(struct!.projectsStorageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    projects_storage_size: {
      value: cdktf.stringToHclTerraform(struct!.projectsStorageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    projects_use_existing_claim: {
      value: cdktf.stringToHclTerraform(struct!.projectsUseExistingClaim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    receptor_log_level: {
      value: cdktf.stringToHclTerraform(struct!.receptorLogLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    redis_capabilities: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.redisCapabilities),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    redis_image: {
      value: cdktf.stringToHclTerraform(struct!.redisImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    redis_image_version: {
      value: cdktf.stringToHclTerraform(struct!.redisImageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    redis_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsToHclTerraform(struct!.redisResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    route_api_version: {
      value: cdktf.stringToHclTerraform(struct!.routeApiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_host: {
      value: cdktf.stringToHclTerraform(struct!.routeHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_tls_secret: {
      value: cdktf.stringToHclTerraform(struct!.routeTlsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    route_tls_termination_mechanism: {
      value: cdktf.stringToHclTerraform(struct!.routeTlsTerminationMechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rsyslog_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.rsyslogArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    rsyslog_command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.rsyslogCommand),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    rsyslog_extra_env: {
      value: cdktf.stringToHclTerraform(struct!.rsyslogExtraEnv),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rsyslog_extra_volume_mounts: {
      value: cdktf.stringToHclTerraform(struct!.rsyslogExtraVolumeMounts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rsyslog_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsToHclTerraform(struct!.rsyslogResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements",
    },
    secret_key_secret: {
      value: cdktf.stringToHclTerraform(struct!.secretKeySecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    security_context_settings: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.securityContextSettings),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service_account_annotations: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_annotations: {
      value: cdktf.stringToHclTerraform(struct!.serviceAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_labels: {
      value: cdktf.stringToHclTerraform(struct!.serviceLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_type: {
      value: cdktf.stringToHclTerraform(struct!.serviceType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_cookie_secure: {
      value: cdktf.stringToHclTerraform(struct!.sessionCookieSecure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    set_self_labels: {
      value: cdktf.booleanToHclTerraform(struct!.setSelfLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    task_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityToHclTerraform(struct!.taskAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity",
    },
    task_annotations: {
      value: cdktf.stringToHclTerraform(struct!.taskAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.taskArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    task_command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.taskCommand),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    task_extra_env: {
      value: cdktf.stringToHclTerraform(struct!.taskExtraEnv),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_extra_volume_mounts: {
      value: cdktf.stringToHclTerraform(struct!.taskExtraVolumeMounts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_liveness_failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.taskLivenessFailureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_liveness_initial_delay: {
      value: cdktf.numberToHclTerraform(struct!.taskLivenessInitialDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_liveness_period: {
      value: cdktf.numberToHclTerraform(struct!.taskLivenessPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_liveness_timeout: {
      value: cdktf.numberToHclTerraform(struct!.taskLivenessTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_manage_replicas: {
      value: cdktf.booleanToHclTerraform(struct!.taskManageReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    task_node_selector: {
      value: cdktf.stringToHclTerraform(struct!.taskNodeSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_privileged: {
      value: cdktf.booleanToHclTerraform(struct!.taskPrivileged),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    task_readiness_failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.taskReadinessFailureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_readiness_initial_delay: {
      value: cdktf.numberToHclTerraform(struct!.taskReadinessInitialDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_readiness_period: {
      value: cdktf.numberToHclTerraform(struct!.taskReadinessPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_readiness_timeout: {
      value: cdktf.numberToHclTerraform(struct!.taskReadinessTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_replicas: {
      value: cdktf.numberToHclTerraform(struct!.taskReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    task_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsToHclTerraform(struct!.taskResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements",
    },
    task_tolerations: {
      value: cdktf.stringToHclTerraform(struct!.taskTolerations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    task_topology_spread_constraints: {
      value: cdktf.stringToHclTerraform(struct!.taskTopologySpreadConstraints),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    termination_grace_period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.terminationGracePeriodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tolerations: {
      value: cdktf.stringToHclTerraform(struct!.tolerations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topology_spread_constraints: {
      value: cdktf.stringToHclTerraform(struct!.topologySpreadConstraints),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uwsgi_listen_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.uwsgiListenQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    uwsgi_processes: {
      value: cdktf.numberToHclTerraform(struct!.uwsgiProcesses),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_affinity: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityToHclTerraform(struct!.webAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity",
    },
    web_annotations: {
      value: cdktf.stringToHclTerraform(struct!.webAnnotations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    web_args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.webArgs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    web_command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.webCommand),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    web_extra_env: {
      value: cdktf.stringToHclTerraform(struct!.webExtraEnv),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    web_extra_volume_mounts: {
      value: cdktf.stringToHclTerraform(struct!.webExtraVolumeMounts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    web_liveness_failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.webLivenessFailureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_liveness_initial_delay: {
      value: cdktf.numberToHclTerraform(struct!.webLivenessInitialDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_liveness_period: {
      value: cdktf.numberToHclTerraform(struct!.webLivenessPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_liveness_timeout: {
      value: cdktf.numberToHclTerraform(struct!.webLivenessTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_manage_replicas: {
      value: cdktf.booleanToHclTerraform(struct!.webManageReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    web_node_selector: {
      value: cdktf.stringToHclTerraform(struct!.webNodeSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    web_readiness_failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.webReadinessFailureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_readiness_initial_delay: {
      value: cdktf.numberToHclTerraform(struct!.webReadinessInitialDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_readiness_period: {
      value: cdktf.numberToHclTerraform(struct!.webReadinessPeriod),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_readiness_timeout: {
      value: cdktf.numberToHclTerraform(struct!.webReadinessTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_replicas: {
      value: cdktf.numberToHclTerraform(struct!.webReplicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    web_resource_requirements: {
      value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsToHclTerraform(struct!.webResourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements",
    },
    web_tolerations: {
      value: cdktf.stringToHclTerraform(struct!.webTolerations),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    web_topology_spread_constraints: {
      value: cdktf.stringToHclTerraform(struct!.webTopologySpreadConstraints),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalLabels = this._additionalLabels;
    }
    if (this._adminEmail !== undefined) {
      hasAnyValues = true;
      internalValueResult.adminEmail = this._adminEmail;
    }
    if (this._adminPasswordSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.adminPasswordSecret = this._adminPasswordSecret;
    }
    if (this._adminUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.adminUser = this._adminUser;
    }
    if (this._affinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.affinity = this._affinity?.internalValue;
    }
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._apiUrlpatternPrefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrlpatternPrefix = this._apiUrlpatternPrefix;
    }
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._autoUpgrade !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoUpgrade = this._autoUpgrade;
    }
    if (this._broadcastWebsocketSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.broadcastWebsocketSecret = this._broadcastWebsocketSecret;
    }
    if (this._bundleCacertSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.bundleCacertSecret = this._bundleCacertSecret;
    }
    if (this._caTrustBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caTrustBundle = this._caTrustBundle;
    }
    if (this._controlPlaneEeImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.controlPlaneEeImage = this._controlPlaneEeImage;
    }
    if (this._controlPlanePriorityClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.controlPlanePriorityClass = this._controlPlanePriorityClass;
    }
    if (this._createPreloadData !== undefined) {
      hasAnyValues = true;
      internalValueResult.createPreloadData = this._createPreloadData;
    }
    if (this._csrfCookieSecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.csrfCookieSecure = this._csrfCookieSecure;
    }
    if (this._deploymentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentType = this._deploymentType;
    }
    if (this._developmentMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.developmentMode = this._developmentMode;
    }
    if (this._eeExtraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.eeExtraEnv = this._eeExtraEnv;
    }
    if (this._eeExtraVolumeMounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.eeExtraVolumeMounts = this._eeExtraVolumeMounts;
    }
    if (this._eeImages?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.eeImages = this._eeImages?.internalValue;
    }
    if (this._eePullCredentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.eePullCredentialsSecret = this._eePullCredentialsSecret;
    }
    if (this._eeResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.eeResourceRequirements = this._eeResourceRequirements?.internalValue;
    }
    if (this._extraSettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraSettings = this._extraSettings?.internalValue;
    }
    if (this._extraSettingsFiles?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraSettingsFiles = this._extraSettingsFiles?.internalValue;
    }
    if (this._extraVolumes !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraVolumes = this._extraVolumes;
    }
    if (this._garbageCollectSecrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.garbageCollectSecrets = this._garbageCollectSecrets;
    }
    if (this._hostAliases?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostAliases = this._hostAliases?.internalValue;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._imagePullSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecret = this._imagePullSecret;
    }
    if (this._imagePullSecrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecrets = this._imagePullSecrets;
    }
    if (this._imageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageVersion = this._imageVersion;
    }
    if (this._ingressAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressAnnotations = this._ingressAnnotations;
    }
    if (this._ingressApiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressApiVersion = this._ingressApiVersion;
    }
    if (this._ingressClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressClassName = this._ingressClassName;
    }
    if (this._ingressController !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressController = this._ingressController;
    }
    if (this._ingressHosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressHosts = this._ingressHosts?.internalValue;
    }
    if (this._ingressPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressPath = this._ingressPath;
    }
    if (this._ingressPathType !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressPathType = this._ingressPathType;
    }
    if (this._ingressTlsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressTlsSecret = this._ingressTlsSecret;
    }
    if (this._ingressType !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressType = this._ingressType;
    }
    if (this._initContainerExtraCommands !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainerExtraCommands = this._initContainerExtraCommands;
    }
    if (this._initContainerExtraVolumeMounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainerExtraVolumeMounts = this._initContainerExtraVolumeMounts;
    }
    if (this._initContainerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainerImage = this._initContainerImage;
    }
    if (this._initContainerImageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainerImageVersion = this._initContainerImageVersion;
    }
    if (this._initContainerResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initContainerResourceRequirements = this._initContainerResourceRequirements?.internalValue;
    }
    if (this._initProjectsContainerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.initProjectsContainerImage = this._initProjectsContainerImage;
    }
    if (this._ipv6Disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipv6Disabled = this._ipv6Disabled;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._ldapCacertSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldapCacertSecret = this._ldapCacertSecret;
    }
    if (this._ldapPasswordSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldapPasswordSecret = this._ldapPasswordSecret;
    }
    if (this._loadbalancerClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadbalancerClass = this._loadbalancerClass;
    }
    if (this._loadbalancerIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadbalancerIp = this._loadbalancerIp;
    }
    if (this._loadbalancerPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadbalancerPort = this._loadbalancerPort;
    }
    if (this._loadbalancerProtocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadbalancerProtocol = this._loadbalancerProtocol;
    }
    if (this._metricsUtilityConfigmap !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityConfigmap = this._metricsUtilityConfigmap;
    }
    if (this._metricsUtilityConsoleEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityConsoleEnabled = this._metricsUtilityConsoleEnabled;
    }
    if (this._metricsUtilityCronjobGatherSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityCronjobGatherSchedule = this._metricsUtilityCronjobGatherSchedule;
    }
    if (this._metricsUtilityCronjobReportSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityCronjobReportSchedule = this._metricsUtilityCronjobReportSchedule;
    }
    if (this._metricsUtilityEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityEnabled = this._metricsUtilityEnabled;
    }
    if (this._metricsUtilityImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityImage = this._metricsUtilityImage;
    }
    if (this._metricsUtilityImagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityImagePullPolicy = this._metricsUtilityImagePullPolicy;
    }
    if (this._metricsUtilityImageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityImageVersion = this._metricsUtilityImageVersion;
    }
    if (this._metricsUtilityPvcClaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityPvcClaim = this._metricsUtilityPvcClaim;
    }
    if (this._metricsUtilityPvcClaimSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityPvcClaimSize = this._metricsUtilityPvcClaimSize;
    }
    if (this._metricsUtilityPvcClaimStorageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityPvcClaimStorageClass = this._metricsUtilityPvcClaimStorageClass;
    }
    if (this._metricsUtilitySecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilitySecret = this._metricsUtilitySecret;
    }
    if (this._metricsUtilityShipTarget !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsUtilityShipTarget = this._metricsUtilityShipTarget;
    }
    if (this._nginxListenQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.nginxListenQueueSize = this._nginxListenQueueSize;
    }
    if (this._nginxWorkerConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.nginxWorkerConnections = this._nginxWorkerConnections;
    }
    if (this._nginxWorkerCpuAffinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.nginxWorkerCpuAffinity = this._nginxWorkerCpuAffinity;
    }
    if (this._nginxWorkerProcesses !== undefined) {
      hasAnyValues = true;
      internalValueResult.nginxWorkerProcesses = this._nginxWorkerProcesses;
    }
    if (this._noLog !== undefined) {
      hasAnyValues = true;
      internalValueResult.noLog = this._noLog;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._nodeportPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeportPort = this._nodeportPort;
    }
    if (this._oldPostgresConfigurationSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.oldPostgresConfigurationSecret = this._oldPostgresConfigurationSecret;
    }
    if (this._pgDumpSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.pgDumpSuffix = this._pgDumpSuffix;
    }
    if (this._postgresAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresAnnotations = this._postgresAnnotations;
    }
    if (this._postgresConfigurationSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresConfigurationSecret = this._postgresConfigurationSecret;
    }
    if (this._postgresDataVolumeInit !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresDataVolumeInit = this._postgresDataVolumeInit;
    }
    if (this._postgresExtraArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresExtraArgs = this._postgresExtraArgs;
    }
    if (this._postgresExtraVolumeMounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresExtraVolumeMounts = this._postgresExtraVolumeMounts;
    }
    if (this._postgresExtraVolumes !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresExtraVolumes = this._postgresExtraVolumes;
    }
    if (this._postgresImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresImage = this._postgresImage;
    }
    if (this._postgresImageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresImageVersion = this._postgresImageVersion;
    }
    if (this._postgresInitContainerCommands !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresInitContainerCommands = this._postgresInitContainerCommands;
    }
    if (this._postgresInitContainerResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresInitContainerResourceRequirements = this._postgresInitContainerResourceRequirements?.internalValue;
    }
    if (this._postgresKeepPvcAfterUpgrade !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresKeepPvcAfterUpgrade = this._postgresKeepPvcAfterUpgrade;
    }
    if (this._postgresKeepalives !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresKeepalives = this._postgresKeepalives;
    }
    if (this._postgresKeepalivesCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresKeepalivesCount = this._postgresKeepalivesCount;
    }
    if (this._postgresKeepalivesIdle !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresKeepalivesIdle = this._postgresKeepalivesIdle;
    }
    if (this._postgresKeepalivesInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresKeepalivesInterval = this._postgresKeepalivesInterval;
    }
    if (this._postgresLabelSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresLabelSelector = this._postgresLabelSelector;
    }
    if (this._postgresPriorityClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresPriorityClass = this._postgresPriorityClass;
    }
    if (this._postgresResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresResourceRequirements = this._postgresResourceRequirements?.internalValue;
    }
    if (this._postgresSecurityContextSettings !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresSecurityContextSettings = this._postgresSecurityContextSettings;
    }
    if (this._postgresSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresSelector = this._postgresSelector;
    }
    if (this._postgresStorageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresStorageClass = this._postgresStorageClass;
    }
    if (this._postgresStorageRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresStorageRequirements = this._postgresStorageRequirements?.internalValue;
    }
    if (this._postgresTolerations !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresTolerations = this._postgresTolerations;
    }
    if (this._projectsExistingClaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectsExistingClaim = this._projectsExistingClaim;
    }
    if (this._projectsPersistence !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectsPersistence = this._projectsPersistence;
    }
    if (this._projectsStorageAccessMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectsStorageAccessMode = this._projectsStorageAccessMode;
    }
    if (this._projectsStorageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectsStorageClass = this._projectsStorageClass;
    }
    if (this._projectsStorageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectsStorageSize = this._projectsStorageSize;
    }
    if (this._projectsUseExistingClaim !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectsUseExistingClaim = this._projectsUseExistingClaim;
    }
    if (this._receptorLogLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.receptorLogLevel = this._receptorLogLevel;
    }
    if (this._redisCapabilities !== undefined) {
      hasAnyValues = true;
      internalValueResult.redisCapabilities = this._redisCapabilities;
    }
    if (this._redisImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.redisImage = this._redisImage;
    }
    if (this._redisImageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.redisImageVersion = this._redisImageVersion;
    }
    if (this._redisResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redisResourceRequirements = this._redisResourceRequirements?.internalValue;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._routeApiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeApiVersion = this._routeApiVersion;
    }
    if (this._routeHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeHost = this._routeHost;
    }
    if (this._routeTlsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTlsSecret = this._routeTlsSecret;
    }
    if (this._routeTlsTerminationMechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeTlsTerminationMechanism = this._routeTlsTerminationMechanism;
    }
    if (this._rsyslogArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.rsyslogArgs = this._rsyslogArgs;
    }
    if (this._rsyslogCommand !== undefined) {
      hasAnyValues = true;
      internalValueResult.rsyslogCommand = this._rsyslogCommand;
    }
    if (this._rsyslogExtraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.rsyslogExtraEnv = this._rsyslogExtraEnv;
    }
    if (this._rsyslogExtraVolumeMounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.rsyslogExtraVolumeMounts = this._rsyslogExtraVolumeMounts;
    }
    if (this._rsyslogResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rsyslogResourceRequirements = this._rsyslogResourceRequirements?.internalValue;
    }
    if (this._secretKeySecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeySecret = this._secretKeySecret;
    }
    if (this._securityContextSettings !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityContextSettings = this._securityContextSettings;
    }
    if (this._serviceAccountAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountAnnotations = this._serviceAccountAnnotations;
    }
    if (this._serviceAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAnnotations = this._serviceAnnotations;
    }
    if (this._serviceLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceLabels = this._serviceLabels;
    }
    if (this._serviceType !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceType = this._serviceType;
    }
    if (this._sessionCookieSecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionCookieSecure = this._sessionCookieSecure;
    }
    if (this._setSelfLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.setSelfLabels = this._setSelfLabels;
    }
    if (this._taskAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskAffinity = this._taskAffinity?.internalValue;
    }
    if (this._taskAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskAnnotations = this._taskAnnotations;
    }
    if (this._taskArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskArgs = this._taskArgs;
    }
    if (this._taskCommand !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskCommand = this._taskCommand;
    }
    if (this._taskExtraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskExtraEnv = this._taskExtraEnv;
    }
    if (this._taskExtraVolumeMounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskExtraVolumeMounts = this._taskExtraVolumeMounts;
    }
    if (this._taskLivenessFailureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskLivenessFailureThreshold = this._taskLivenessFailureThreshold;
    }
    if (this._taskLivenessInitialDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskLivenessInitialDelay = this._taskLivenessInitialDelay;
    }
    if (this._taskLivenessPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskLivenessPeriod = this._taskLivenessPeriod;
    }
    if (this._taskLivenessTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskLivenessTimeout = this._taskLivenessTimeout;
    }
    if (this._taskManageReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskManageReplicas = this._taskManageReplicas;
    }
    if (this._taskNodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskNodeSelector = this._taskNodeSelector;
    }
    if (this._taskPrivileged !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskPrivileged = this._taskPrivileged;
    }
    if (this._taskReadinessFailureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskReadinessFailureThreshold = this._taskReadinessFailureThreshold;
    }
    if (this._taskReadinessInitialDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskReadinessInitialDelay = this._taskReadinessInitialDelay;
    }
    if (this._taskReadinessPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskReadinessPeriod = this._taskReadinessPeriod;
    }
    if (this._taskReadinessTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskReadinessTimeout = this._taskReadinessTimeout;
    }
    if (this._taskReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskReplicas = this._taskReplicas;
    }
    if (this._taskResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskResourceRequirements = this._taskResourceRequirements?.internalValue;
    }
    if (this._taskTolerations !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskTolerations = this._taskTolerations;
    }
    if (this._taskTopologySpreadConstraints !== undefined) {
      hasAnyValues = true;
      internalValueResult.taskTopologySpreadConstraints = this._taskTopologySpreadConstraints;
    }
    if (this._terminationGracePeriodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminationGracePeriodSeconds = this._terminationGracePeriodSeconds;
    }
    if (this._tolerations !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations;
    }
    if (this._topologySpreadConstraints !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologySpreadConstraints = this._topologySpreadConstraints;
    }
    if (this._uwsgiListenQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.uwsgiListenQueueSize = this._uwsgiListenQueueSize;
    }
    if (this._uwsgiProcesses !== undefined) {
      hasAnyValues = true;
      internalValueResult.uwsgiProcesses = this._uwsgiProcesses;
    }
    if (this._webAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webAffinity = this._webAffinity?.internalValue;
    }
    if (this._webAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.webAnnotations = this._webAnnotations;
    }
    if (this._webArgs !== undefined) {
      hasAnyValues = true;
      internalValueResult.webArgs = this._webArgs;
    }
    if (this._webCommand !== undefined) {
      hasAnyValues = true;
      internalValueResult.webCommand = this._webCommand;
    }
    if (this._webExtraEnv !== undefined) {
      hasAnyValues = true;
      internalValueResult.webExtraEnv = this._webExtraEnv;
    }
    if (this._webExtraVolumeMounts !== undefined) {
      hasAnyValues = true;
      internalValueResult.webExtraVolumeMounts = this._webExtraVolumeMounts;
    }
    if (this._webLivenessFailureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.webLivenessFailureThreshold = this._webLivenessFailureThreshold;
    }
    if (this._webLivenessInitialDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.webLivenessInitialDelay = this._webLivenessInitialDelay;
    }
    if (this._webLivenessPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.webLivenessPeriod = this._webLivenessPeriod;
    }
    if (this._webLivenessTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.webLivenessTimeout = this._webLivenessTimeout;
    }
    if (this._webManageReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.webManageReplicas = this._webManageReplicas;
    }
    if (this._webNodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.webNodeSelector = this._webNodeSelector;
    }
    if (this._webReadinessFailureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.webReadinessFailureThreshold = this._webReadinessFailureThreshold;
    }
    if (this._webReadinessInitialDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.webReadinessInitialDelay = this._webReadinessInitialDelay;
    }
    if (this._webReadinessPeriod !== undefined) {
      hasAnyValues = true;
      internalValueResult.webReadinessPeriod = this._webReadinessPeriod;
    }
    if (this._webReadinessTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.webReadinessTimeout = this._webReadinessTimeout;
    }
    if (this._webReplicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.webReplicas = this._webReplicas;
    }
    if (this._webResourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webResourceRequirements = this._webResourceRequirements?.internalValue;
    }
    if (this._webTolerations !== undefined) {
      hasAnyValues = true;
      internalValueResult.webTolerations = this._webTolerations;
    }
    if (this._webTopologySpreadConstraints !== undefined) {
      hasAnyValues = true;
      internalValueResult.webTopologySpreadConstraints = this._webTopologySpreadConstraints;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalLabels = undefined;
      this._adminEmail = undefined;
      this._adminPasswordSecret = undefined;
      this._adminUser = undefined;
      this._affinity.internalValue = undefined;
      this._annotations = undefined;
      this._apiUrlpatternPrefix = undefined;
      this._apiVersion = undefined;
      this._autoUpgrade = undefined;
      this._broadcastWebsocketSecret = undefined;
      this._bundleCacertSecret = undefined;
      this._caTrustBundle = undefined;
      this._controlPlaneEeImage = undefined;
      this._controlPlanePriorityClass = undefined;
      this._createPreloadData = undefined;
      this._csrfCookieSecure = undefined;
      this._deploymentType = undefined;
      this._developmentMode = undefined;
      this._eeExtraEnv = undefined;
      this._eeExtraVolumeMounts = undefined;
      this._eeImages.internalValue = undefined;
      this._eePullCredentialsSecret = undefined;
      this._eeResourceRequirements.internalValue = undefined;
      this._extraSettings.internalValue = undefined;
      this._extraSettingsFiles.internalValue = undefined;
      this._extraVolumes = undefined;
      this._garbageCollectSecrets = undefined;
      this._hostAliases.internalValue = undefined;
      this._hostname = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._imagePullSecret = undefined;
      this._imagePullSecrets = undefined;
      this._imageVersion = undefined;
      this._ingressAnnotations = undefined;
      this._ingressApiVersion = undefined;
      this._ingressClassName = undefined;
      this._ingressController = undefined;
      this._ingressHosts.internalValue = undefined;
      this._ingressPath = undefined;
      this._ingressPathType = undefined;
      this._ingressTlsSecret = undefined;
      this._ingressType = undefined;
      this._initContainerExtraCommands = undefined;
      this._initContainerExtraVolumeMounts = undefined;
      this._initContainerImage = undefined;
      this._initContainerImageVersion = undefined;
      this._initContainerResourceRequirements.internalValue = undefined;
      this._initProjectsContainerImage = undefined;
      this._ipv6Disabled = undefined;
      this._kind = undefined;
      this._ldapCacertSecret = undefined;
      this._ldapPasswordSecret = undefined;
      this._loadbalancerClass = undefined;
      this._loadbalancerIp = undefined;
      this._loadbalancerPort = undefined;
      this._loadbalancerProtocol = undefined;
      this._metricsUtilityConfigmap = undefined;
      this._metricsUtilityConsoleEnabled = undefined;
      this._metricsUtilityCronjobGatherSchedule = undefined;
      this._metricsUtilityCronjobReportSchedule = undefined;
      this._metricsUtilityEnabled = undefined;
      this._metricsUtilityImage = undefined;
      this._metricsUtilityImagePullPolicy = undefined;
      this._metricsUtilityImageVersion = undefined;
      this._metricsUtilityPvcClaim = undefined;
      this._metricsUtilityPvcClaimSize = undefined;
      this._metricsUtilityPvcClaimStorageClass = undefined;
      this._metricsUtilitySecret = undefined;
      this._metricsUtilityShipTarget = undefined;
      this._nginxListenQueueSize = undefined;
      this._nginxWorkerConnections = undefined;
      this._nginxWorkerCpuAffinity = undefined;
      this._nginxWorkerProcesses = undefined;
      this._noLog = undefined;
      this._nodeSelector = undefined;
      this._nodeportPort = undefined;
      this._oldPostgresConfigurationSecret = undefined;
      this._pgDumpSuffix = undefined;
      this._postgresAnnotations = undefined;
      this._postgresConfigurationSecret = undefined;
      this._postgresDataVolumeInit = undefined;
      this._postgresExtraArgs = undefined;
      this._postgresExtraVolumeMounts = undefined;
      this._postgresExtraVolumes = undefined;
      this._postgresImage = undefined;
      this._postgresImageVersion = undefined;
      this._postgresInitContainerCommands = undefined;
      this._postgresInitContainerResourceRequirements.internalValue = undefined;
      this._postgresKeepPvcAfterUpgrade = undefined;
      this._postgresKeepalives = undefined;
      this._postgresKeepalivesCount = undefined;
      this._postgresKeepalivesIdle = undefined;
      this._postgresKeepalivesInterval = undefined;
      this._postgresLabelSelector = undefined;
      this._postgresPriorityClass = undefined;
      this._postgresResourceRequirements.internalValue = undefined;
      this._postgresSecurityContextSettings = undefined;
      this._postgresSelector = undefined;
      this._postgresStorageClass = undefined;
      this._postgresStorageRequirements.internalValue = undefined;
      this._postgresTolerations = undefined;
      this._projectsExistingClaim = undefined;
      this._projectsPersistence = undefined;
      this._projectsStorageAccessMode = undefined;
      this._projectsStorageClass = undefined;
      this._projectsStorageSize = undefined;
      this._projectsUseExistingClaim = undefined;
      this._receptorLogLevel = undefined;
      this._redisCapabilities = undefined;
      this._redisImage = undefined;
      this._redisImageVersion = undefined;
      this._redisResourceRequirements.internalValue = undefined;
      this._replicas = undefined;
      this._routeApiVersion = undefined;
      this._routeHost = undefined;
      this._routeTlsSecret = undefined;
      this._routeTlsTerminationMechanism = undefined;
      this._rsyslogArgs = undefined;
      this._rsyslogCommand = undefined;
      this._rsyslogExtraEnv = undefined;
      this._rsyslogExtraVolumeMounts = undefined;
      this._rsyslogResourceRequirements.internalValue = undefined;
      this._secretKeySecret = undefined;
      this._securityContextSettings = undefined;
      this._serviceAccountAnnotations = undefined;
      this._serviceAnnotations = undefined;
      this._serviceLabels = undefined;
      this._serviceType = undefined;
      this._sessionCookieSecure = undefined;
      this._setSelfLabels = undefined;
      this._taskAffinity.internalValue = undefined;
      this._taskAnnotations = undefined;
      this._taskArgs = undefined;
      this._taskCommand = undefined;
      this._taskExtraEnv = undefined;
      this._taskExtraVolumeMounts = undefined;
      this._taskLivenessFailureThreshold = undefined;
      this._taskLivenessInitialDelay = undefined;
      this._taskLivenessPeriod = undefined;
      this._taskLivenessTimeout = undefined;
      this._taskManageReplicas = undefined;
      this._taskNodeSelector = undefined;
      this._taskPrivileged = undefined;
      this._taskReadinessFailureThreshold = undefined;
      this._taskReadinessInitialDelay = undefined;
      this._taskReadinessPeriod = undefined;
      this._taskReadinessTimeout = undefined;
      this._taskReplicas = undefined;
      this._taskResourceRequirements.internalValue = undefined;
      this._taskTolerations = undefined;
      this._taskTopologySpreadConstraints = undefined;
      this._terminationGracePeriodSeconds = undefined;
      this._tolerations = undefined;
      this._topologySpreadConstraints = undefined;
      this._uwsgiListenQueueSize = undefined;
      this._uwsgiProcesses = undefined;
      this._webAffinity.internalValue = undefined;
      this._webAnnotations = undefined;
      this._webArgs = undefined;
      this._webCommand = undefined;
      this._webExtraEnv = undefined;
      this._webExtraVolumeMounts = undefined;
      this._webLivenessFailureThreshold = undefined;
      this._webLivenessInitialDelay = undefined;
      this._webLivenessPeriod = undefined;
      this._webLivenessTimeout = undefined;
      this._webManageReplicas = undefined;
      this._webNodeSelector = undefined;
      this._webReadinessFailureThreshold = undefined;
      this._webReadinessInitialDelay = undefined;
      this._webReadinessPeriod = undefined;
      this._webReadinessTimeout = undefined;
      this._webReplicas = undefined;
      this._webResourceRequirements.internalValue = undefined;
      this._webTolerations = undefined;
      this._webTopologySpreadConstraints = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalLabels = value.additionalLabels;
      this._adminEmail = value.adminEmail;
      this._adminPasswordSecret = value.adminPasswordSecret;
      this._adminUser = value.adminUser;
      this._affinity.internalValue = value.affinity;
      this._annotations = value.annotations;
      this._apiUrlpatternPrefix = value.apiUrlpatternPrefix;
      this._apiVersion = value.apiVersion;
      this._autoUpgrade = value.autoUpgrade;
      this._broadcastWebsocketSecret = value.broadcastWebsocketSecret;
      this._bundleCacertSecret = value.bundleCacertSecret;
      this._caTrustBundle = value.caTrustBundle;
      this._controlPlaneEeImage = value.controlPlaneEeImage;
      this._controlPlanePriorityClass = value.controlPlanePriorityClass;
      this._createPreloadData = value.createPreloadData;
      this._csrfCookieSecure = value.csrfCookieSecure;
      this._deploymentType = value.deploymentType;
      this._developmentMode = value.developmentMode;
      this._eeExtraEnv = value.eeExtraEnv;
      this._eeExtraVolumeMounts = value.eeExtraVolumeMounts;
      this._eeImages.internalValue = value.eeImages;
      this._eePullCredentialsSecret = value.eePullCredentialsSecret;
      this._eeResourceRequirements.internalValue = value.eeResourceRequirements;
      this._extraSettings.internalValue = value.extraSettings;
      this._extraSettingsFiles.internalValue = value.extraSettingsFiles;
      this._extraVolumes = value.extraVolumes;
      this._garbageCollectSecrets = value.garbageCollectSecrets;
      this._hostAliases.internalValue = value.hostAliases;
      this._hostname = value.hostname;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._imagePullSecret = value.imagePullSecret;
      this._imagePullSecrets = value.imagePullSecrets;
      this._imageVersion = value.imageVersion;
      this._ingressAnnotations = value.ingressAnnotations;
      this._ingressApiVersion = value.ingressApiVersion;
      this._ingressClassName = value.ingressClassName;
      this._ingressController = value.ingressController;
      this._ingressHosts.internalValue = value.ingressHosts;
      this._ingressPath = value.ingressPath;
      this._ingressPathType = value.ingressPathType;
      this._ingressTlsSecret = value.ingressTlsSecret;
      this._ingressType = value.ingressType;
      this._initContainerExtraCommands = value.initContainerExtraCommands;
      this._initContainerExtraVolumeMounts = value.initContainerExtraVolumeMounts;
      this._initContainerImage = value.initContainerImage;
      this._initContainerImageVersion = value.initContainerImageVersion;
      this._initContainerResourceRequirements.internalValue = value.initContainerResourceRequirements;
      this._initProjectsContainerImage = value.initProjectsContainerImage;
      this._ipv6Disabled = value.ipv6Disabled;
      this._kind = value.kind;
      this._ldapCacertSecret = value.ldapCacertSecret;
      this._ldapPasswordSecret = value.ldapPasswordSecret;
      this._loadbalancerClass = value.loadbalancerClass;
      this._loadbalancerIp = value.loadbalancerIp;
      this._loadbalancerPort = value.loadbalancerPort;
      this._loadbalancerProtocol = value.loadbalancerProtocol;
      this._metricsUtilityConfigmap = value.metricsUtilityConfigmap;
      this._metricsUtilityConsoleEnabled = value.metricsUtilityConsoleEnabled;
      this._metricsUtilityCronjobGatherSchedule = value.metricsUtilityCronjobGatherSchedule;
      this._metricsUtilityCronjobReportSchedule = value.metricsUtilityCronjobReportSchedule;
      this._metricsUtilityEnabled = value.metricsUtilityEnabled;
      this._metricsUtilityImage = value.metricsUtilityImage;
      this._metricsUtilityImagePullPolicy = value.metricsUtilityImagePullPolicy;
      this._metricsUtilityImageVersion = value.metricsUtilityImageVersion;
      this._metricsUtilityPvcClaim = value.metricsUtilityPvcClaim;
      this._metricsUtilityPvcClaimSize = value.metricsUtilityPvcClaimSize;
      this._metricsUtilityPvcClaimStorageClass = value.metricsUtilityPvcClaimStorageClass;
      this._metricsUtilitySecret = value.metricsUtilitySecret;
      this._metricsUtilityShipTarget = value.metricsUtilityShipTarget;
      this._nginxListenQueueSize = value.nginxListenQueueSize;
      this._nginxWorkerConnections = value.nginxWorkerConnections;
      this._nginxWorkerCpuAffinity = value.nginxWorkerCpuAffinity;
      this._nginxWorkerProcesses = value.nginxWorkerProcesses;
      this._noLog = value.noLog;
      this._nodeSelector = value.nodeSelector;
      this._nodeportPort = value.nodeportPort;
      this._oldPostgresConfigurationSecret = value.oldPostgresConfigurationSecret;
      this._pgDumpSuffix = value.pgDumpSuffix;
      this._postgresAnnotations = value.postgresAnnotations;
      this._postgresConfigurationSecret = value.postgresConfigurationSecret;
      this._postgresDataVolumeInit = value.postgresDataVolumeInit;
      this._postgresExtraArgs = value.postgresExtraArgs;
      this._postgresExtraVolumeMounts = value.postgresExtraVolumeMounts;
      this._postgresExtraVolumes = value.postgresExtraVolumes;
      this._postgresImage = value.postgresImage;
      this._postgresImageVersion = value.postgresImageVersion;
      this._postgresInitContainerCommands = value.postgresInitContainerCommands;
      this._postgresInitContainerResourceRequirements.internalValue = value.postgresInitContainerResourceRequirements;
      this._postgresKeepPvcAfterUpgrade = value.postgresKeepPvcAfterUpgrade;
      this._postgresKeepalives = value.postgresKeepalives;
      this._postgresKeepalivesCount = value.postgresKeepalivesCount;
      this._postgresKeepalivesIdle = value.postgresKeepalivesIdle;
      this._postgresKeepalivesInterval = value.postgresKeepalivesInterval;
      this._postgresLabelSelector = value.postgresLabelSelector;
      this._postgresPriorityClass = value.postgresPriorityClass;
      this._postgresResourceRequirements.internalValue = value.postgresResourceRequirements;
      this._postgresSecurityContextSettings = value.postgresSecurityContextSettings;
      this._postgresSelector = value.postgresSelector;
      this._postgresStorageClass = value.postgresStorageClass;
      this._postgresStorageRequirements.internalValue = value.postgresStorageRequirements;
      this._postgresTolerations = value.postgresTolerations;
      this._projectsExistingClaim = value.projectsExistingClaim;
      this._projectsPersistence = value.projectsPersistence;
      this._projectsStorageAccessMode = value.projectsStorageAccessMode;
      this._projectsStorageClass = value.projectsStorageClass;
      this._projectsStorageSize = value.projectsStorageSize;
      this._projectsUseExistingClaim = value.projectsUseExistingClaim;
      this._receptorLogLevel = value.receptorLogLevel;
      this._redisCapabilities = value.redisCapabilities;
      this._redisImage = value.redisImage;
      this._redisImageVersion = value.redisImageVersion;
      this._redisResourceRequirements.internalValue = value.redisResourceRequirements;
      this._replicas = value.replicas;
      this._routeApiVersion = value.routeApiVersion;
      this._routeHost = value.routeHost;
      this._routeTlsSecret = value.routeTlsSecret;
      this._routeTlsTerminationMechanism = value.routeTlsTerminationMechanism;
      this._rsyslogArgs = value.rsyslogArgs;
      this._rsyslogCommand = value.rsyslogCommand;
      this._rsyslogExtraEnv = value.rsyslogExtraEnv;
      this._rsyslogExtraVolumeMounts = value.rsyslogExtraVolumeMounts;
      this._rsyslogResourceRequirements.internalValue = value.rsyslogResourceRequirements;
      this._secretKeySecret = value.secretKeySecret;
      this._securityContextSettings = value.securityContextSettings;
      this._serviceAccountAnnotations = value.serviceAccountAnnotations;
      this._serviceAnnotations = value.serviceAnnotations;
      this._serviceLabels = value.serviceLabels;
      this._serviceType = value.serviceType;
      this._sessionCookieSecure = value.sessionCookieSecure;
      this._setSelfLabels = value.setSelfLabels;
      this._taskAffinity.internalValue = value.taskAffinity;
      this._taskAnnotations = value.taskAnnotations;
      this._taskArgs = value.taskArgs;
      this._taskCommand = value.taskCommand;
      this._taskExtraEnv = value.taskExtraEnv;
      this._taskExtraVolumeMounts = value.taskExtraVolumeMounts;
      this._taskLivenessFailureThreshold = value.taskLivenessFailureThreshold;
      this._taskLivenessInitialDelay = value.taskLivenessInitialDelay;
      this._taskLivenessPeriod = value.taskLivenessPeriod;
      this._taskLivenessTimeout = value.taskLivenessTimeout;
      this._taskManageReplicas = value.taskManageReplicas;
      this._taskNodeSelector = value.taskNodeSelector;
      this._taskPrivileged = value.taskPrivileged;
      this._taskReadinessFailureThreshold = value.taskReadinessFailureThreshold;
      this._taskReadinessInitialDelay = value.taskReadinessInitialDelay;
      this._taskReadinessPeriod = value.taskReadinessPeriod;
      this._taskReadinessTimeout = value.taskReadinessTimeout;
      this._taskReplicas = value.taskReplicas;
      this._taskResourceRequirements.internalValue = value.taskResourceRequirements;
      this._taskTolerations = value.taskTolerations;
      this._taskTopologySpreadConstraints = value.taskTopologySpreadConstraints;
      this._terminationGracePeriodSeconds = value.terminationGracePeriodSeconds;
      this._tolerations = value.tolerations;
      this._topologySpreadConstraints = value.topologySpreadConstraints;
      this._uwsgiListenQueueSize = value.uwsgiListenQueueSize;
      this._uwsgiProcesses = value.uwsgiProcesses;
      this._webAffinity.internalValue = value.webAffinity;
      this._webAnnotations = value.webAnnotations;
      this._webArgs = value.webArgs;
      this._webCommand = value.webCommand;
      this._webExtraEnv = value.webExtraEnv;
      this._webExtraVolumeMounts = value.webExtraVolumeMounts;
      this._webLivenessFailureThreshold = value.webLivenessFailureThreshold;
      this._webLivenessInitialDelay = value.webLivenessInitialDelay;
      this._webLivenessPeriod = value.webLivenessPeriod;
      this._webLivenessTimeout = value.webLivenessTimeout;
      this._webManageReplicas = value.webManageReplicas;
      this._webNodeSelector = value.webNodeSelector;
      this._webReadinessFailureThreshold = value.webReadinessFailureThreshold;
      this._webReadinessInitialDelay = value.webReadinessInitialDelay;
      this._webReadinessPeriod = value.webReadinessPeriod;
      this._webReadinessTimeout = value.webReadinessTimeout;
      this._webReplicas = value.webReplicas;
      this._webResourceRequirements.internalValue = value.webResourceRequirements;
      this._webTolerations = value.webTolerations;
      this._webTopologySpreadConstraints = value.webTopologySpreadConstraints;
    }
  }

  // additional_labels - computed: false, optional: true, required: false
  private _additionalLabels?: string[]; 
  public get additionalLabels() {
    return this.getListAttribute('additional_labels');
  }
  public set additionalLabels(value: string[]) {
    this._additionalLabels = value;
  }
  public resetAdditionalLabels() {
    this._additionalLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalLabelsInput() {
    return this._additionalLabels;
  }

  // admin_email - computed: false, optional: true, required: false
  private _adminEmail?: string; 
  public get adminEmail() {
    return this.getStringAttribute('admin_email');
  }
  public set adminEmail(value: string) {
    this._adminEmail = value;
  }
  public resetAdminEmail() {
    this._adminEmail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adminEmailInput() {
    return this._adminEmail;
  }

  // admin_password_secret - computed: false, optional: true, required: false
  private _adminPasswordSecret?: string; 
  public get adminPasswordSecret() {
    return this.getStringAttribute('admin_password_secret');
  }
  public set adminPasswordSecret(value: string) {
    this._adminPasswordSecret = value;
  }
  public resetAdminPasswordSecret() {
    this._adminPasswordSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adminPasswordSecretInput() {
    return this._adminPasswordSecret;
  }

  // admin_user - computed: false, optional: true, required: false
  private _adminUser?: string; 
  public get adminUser() {
    return this.getStringAttribute('admin_user');
  }
  public set adminUser(value: string) {
    this._adminUser = value;
  }
  public resetAdminUser() {
    this._adminUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adminUserInput() {
    return this._adminUser;
  }

  // affinity - computed: false, optional: true, required: false
  private _affinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinityOutputReference(this, "affinity");
  public get affinity() {
    return this._affinity;
  }
  public putAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecAffinity) {
    this._affinity.internalValue = value;
  }
  public resetAffinity() {
    this._affinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affinityInput() {
    return this._affinity.internalValue;
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: string; 
  public get annotations() {
    return this.getStringAttribute('annotations');
  }
  public set annotations(value: string) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // api_urlpattern_prefix - computed: false, optional: true, required: false
  private _apiUrlpatternPrefix?: string; 
  public get apiUrlpatternPrefix() {
    return this.getStringAttribute('api_urlpattern_prefix');
  }
  public set apiUrlpatternPrefix(value: string) {
    this._apiUrlpatternPrefix = value;
  }
  public resetApiUrlpatternPrefix() {
    this._apiUrlpatternPrefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlpatternPrefixInput() {
    return this._apiUrlpatternPrefix;
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auto_upgrade - computed: false, optional: true, required: false
  private _autoUpgrade?: boolean | cdktf.IResolvable; 
  public get autoUpgrade() {
    return this.getBooleanAttribute('auto_upgrade');
  }
  public set autoUpgrade(value: boolean | cdktf.IResolvable) {
    this._autoUpgrade = value;
  }
  public resetAutoUpgrade() {
    this._autoUpgrade = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoUpgradeInput() {
    return this._autoUpgrade;
  }

  // broadcast_websocket_secret - computed: false, optional: true, required: false
  private _broadcastWebsocketSecret?: string; 
  public get broadcastWebsocketSecret() {
    return this.getStringAttribute('broadcast_websocket_secret');
  }
  public set broadcastWebsocketSecret(value: string) {
    this._broadcastWebsocketSecret = value;
  }
  public resetBroadcastWebsocketSecret() {
    this._broadcastWebsocketSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get broadcastWebsocketSecretInput() {
    return this._broadcastWebsocketSecret;
  }

  // bundle_cacert_secret - computed: false, optional: true, required: false
  private _bundleCacertSecret?: string; 
  public get bundleCacertSecret() {
    return this.getStringAttribute('bundle_cacert_secret');
  }
  public set bundleCacertSecret(value: string) {
    this._bundleCacertSecret = value;
  }
  public resetBundleCacertSecret() {
    this._bundleCacertSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bundleCacertSecretInput() {
    return this._bundleCacertSecret;
  }

  // ca_trust_bundle - computed: false, optional: true, required: false
  private _caTrustBundle?: string; 
  public get caTrustBundle() {
    return this.getStringAttribute('ca_trust_bundle');
  }
  public set caTrustBundle(value: string) {
    this._caTrustBundle = value;
  }
  public resetCaTrustBundle() {
    this._caTrustBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caTrustBundleInput() {
    return this._caTrustBundle;
  }

  // control_plane_ee_image - computed: false, optional: true, required: false
  private _controlPlaneEeImage?: string; 
  public get controlPlaneEeImage() {
    return this.getStringAttribute('control_plane_ee_image');
  }
  public set controlPlaneEeImage(value: string) {
    this._controlPlaneEeImage = value;
  }
  public resetControlPlaneEeImage() {
    this._controlPlaneEeImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controlPlaneEeImageInput() {
    return this._controlPlaneEeImage;
  }

  // control_plane_priority_class - computed: false, optional: true, required: false
  private _controlPlanePriorityClass?: string; 
  public get controlPlanePriorityClass() {
    return this.getStringAttribute('control_plane_priority_class');
  }
  public set controlPlanePriorityClass(value: string) {
    this._controlPlanePriorityClass = value;
  }
  public resetControlPlanePriorityClass() {
    this._controlPlanePriorityClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controlPlanePriorityClassInput() {
    return this._controlPlanePriorityClass;
  }

  // create_preload_data - computed: false, optional: true, required: false
  private _createPreloadData?: boolean | cdktf.IResolvable; 
  public get createPreloadData() {
    return this.getBooleanAttribute('create_preload_data');
  }
  public set createPreloadData(value: boolean | cdktf.IResolvable) {
    this._createPreloadData = value;
  }
  public resetCreatePreloadData() {
    this._createPreloadData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createPreloadDataInput() {
    return this._createPreloadData;
  }

  // csrf_cookie_secure - computed: false, optional: true, required: false
  private _csrfCookieSecure?: string; 
  public get csrfCookieSecure() {
    return this.getStringAttribute('csrf_cookie_secure');
  }
  public set csrfCookieSecure(value: string) {
    this._csrfCookieSecure = value;
  }
  public resetCsrfCookieSecure() {
    this._csrfCookieSecure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get csrfCookieSecureInput() {
    return this._csrfCookieSecure;
  }

  // deployment_type - computed: false, optional: true, required: false
  private _deploymentType?: string; 
  public get deploymentType() {
    return this.getStringAttribute('deployment_type');
  }
  public set deploymentType(value: string) {
    this._deploymentType = value;
  }
  public resetDeploymentType() {
    this._deploymentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentTypeInput() {
    return this._deploymentType;
  }

  // development_mode - computed: false, optional: true, required: false
  private _developmentMode?: boolean | cdktf.IResolvable; 
  public get developmentMode() {
    return this.getBooleanAttribute('development_mode');
  }
  public set developmentMode(value: boolean | cdktf.IResolvable) {
    this._developmentMode = value;
  }
  public resetDevelopmentMode() {
    this._developmentMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get developmentModeInput() {
    return this._developmentMode;
  }

  // ee_extra_env - computed: false, optional: true, required: false
  private _eeExtraEnv?: string; 
  public get eeExtraEnv() {
    return this.getStringAttribute('ee_extra_env');
  }
  public set eeExtraEnv(value: string) {
    this._eeExtraEnv = value;
  }
  public resetEeExtraEnv() {
    this._eeExtraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eeExtraEnvInput() {
    return this._eeExtraEnv;
  }

  // ee_extra_volume_mounts - computed: false, optional: true, required: false
  private _eeExtraVolumeMounts?: string; 
  public get eeExtraVolumeMounts() {
    return this.getStringAttribute('ee_extra_volume_mounts');
  }
  public set eeExtraVolumeMounts(value: string) {
    this._eeExtraVolumeMounts = value;
  }
  public resetEeExtraVolumeMounts() {
    this._eeExtraVolumeMounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eeExtraVolumeMountsInput() {
    return this._eeExtraVolumeMounts;
  }

  // ee_images - computed: false, optional: true, required: false
  private _eeImages = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImagesList(this, "ee_images", false);
  public get eeImages() {
    return this._eeImages;
  }
  public putEeImages(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeImages[] | cdktf.IResolvable) {
    this._eeImages.internalValue = value;
  }
  public resetEeImages() {
    this._eeImages.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eeImagesInput() {
    return this._eeImages.internalValue;
  }

  // ee_pull_credentials_secret - computed: false, optional: true, required: false
  private _eePullCredentialsSecret?: string; 
  public get eePullCredentialsSecret() {
    return this.getStringAttribute('ee_pull_credentials_secret');
  }
  public set eePullCredentialsSecret(value: string) {
    this._eePullCredentialsSecret = value;
  }
  public resetEePullCredentialsSecret() {
    this._eePullCredentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eePullCredentialsSecretInput() {
    return this._eePullCredentialsSecret;
  }

  // ee_resource_requirements - computed: false, optional: true, required: false
  private _eeResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirementsOutputReference(this, "ee_resource_requirements");
  public get eeResourceRequirements() {
    return this._eeResourceRequirements;
  }
  public putEeResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecEeResourceRequirements) {
    this._eeResourceRequirements.internalValue = value;
  }
  public resetEeResourceRequirements() {
    this._eeResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eeResourceRequirementsInput() {
    return this._eeResourceRequirements.internalValue;
  }

  // extra_settings - computed: false, optional: true, required: false
  private _extraSettings = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsList(this, "extra_settings", false);
  public get extraSettings() {
    return this._extraSettings;
  }
  public putExtraSettings(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettings[] | cdktf.IResolvable) {
    this._extraSettings.internalValue = value;
  }
  public resetExtraSettings() {
    this._extraSettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraSettingsInput() {
    return this._extraSettings.internalValue;
  }

  // extra_settings_files - computed: false, optional: true, required: false
  private _extraSettingsFiles = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFilesOutputReference(this, "extra_settings_files");
  public get extraSettingsFiles() {
    return this._extraSettingsFiles;
  }
  public putExtraSettingsFiles(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecExtraSettingsFiles) {
    this._extraSettingsFiles.internalValue = value;
  }
  public resetExtraSettingsFiles() {
    this._extraSettingsFiles.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraSettingsFilesInput() {
    return this._extraSettingsFiles.internalValue;
  }

  // extra_volumes - computed: false, optional: true, required: false
  private _extraVolumes?: string; 
  public get extraVolumes() {
    return this.getStringAttribute('extra_volumes');
  }
  public set extraVolumes(value: string) {
    this._extraVolumes = value;
  }
  public resetExtraVolumes() {
    this._extraVolumes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraVolumesInput() {
    return this._extraVolumes;
  }

  // garbage_collect_secrets - computed: false, optional: true, required: false
  private _garbageCollectSecrets?: boolean | cdktf.IResolvable; 
  public get garbageCollectSecrets() {
    return this.getBooleanAttribute('garbage_collect_secrets');
  }
  public set garbageCollectSecrets(value: boolean | cdktf.IResolvable) {
    this._garbageCollectSecrets = value;
  }
  public resetGarbageCollectSecrets() {
    this._garbageCollectSecrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get garbageCollectSecretsInput() {
    return this._garbageCollectSecrets;
  }

  // host_aliases - computed: false, optional: true, required: false
  private _hostAliases = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliasesList(this, "host_aliases", false);
  public get hostAliases() {
    return this._hostAliases;
  }
  public putHostAliases(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecHostAliases[] | cdktf.IResolvable) {
    this._hostAliases.internalValue = value;
  }
  public resetHostAliases() {
    this._hostAliases.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostAliasesInput() {
    return this._hostAliases.internalValue;
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // image_pull_secret - computed: false, optional: true, required: false
  private _imagePullSecret?: string; 
  public get imagePullSecret() {
    return this.getStringAttribute('image_pull_secret');
  }
  public set imagePullSecret(value: string) {
    this._imagePullSecret = value;
  }
  public resetImagePullSecret() {
    this._imagePullSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretInput() {
    return this._imagePullSecret;
  }

  // image_pull_secrets - computed: false, optional: true, required: false
  private _imagePullSecrets?: string[]; 
  public get imagePullSecrets() {
    return this.getListAttribute('image_pull_secrets');
  }
  public set imagePullSecrets(value: string[]) {
    this._imagePullSecrets = value;
  }
  public resetImagePullSecrets() {
    this._imagePullSecrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretsInput() {
    return this._imagePullSecrets;
  }

  // image_version - computed: false, optional: true, required: false
  private _imageVersion?: string; 
  public get imageVersion() {
    return this.getStringAttribute('image_version');
  }
  public set imageVersion(value: string) {
    this._imageVersion = value;
  }
  public resetImageVersion() {
    this._imageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageVersionInput() {
    return this._imageVersion;
  }

  // ingress_annotations - computed: false, optional: true, required: false
  private _ingressAnnotations?: string; 
  public get ingressAnnotations() {
    return this.getStringAttribute('ingress_annotations');
  }
  public set ingressAnnotations(value: string) {
    this._ingressAnnotations = value;
  }
  public resetIngressAnnotations() {
    this._ingressAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressAnnotationsInput() {
    return this._ingressAnnotations;
  }

  // ingress_api_version - computed: false, optional: true, required: false
  private _ingressApiVersion?: string; 
  public get ingressApiVersion() {
    return this.getStringAttribute('ingress_api_version');
  }
  public set ingressApiVersion(value: string) {
    this._ingressApiVersion = value;
  }
  public resetIngressApiVersion() {
    this._ingressApiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressApiVersionInput() {
    return this._ingressApiVersion;
  }

  // ingress_class_name - computed: false, optional: true, required: false
  private _ingressClassName?: string; 
  public get ingressClassName() {
    return this.getStringAttribute('ingress_class_name');
  }
  public set ingressClassName(value: string) {
    this._ingressClassName = value;
  }
  public resetIngressClassName() {
    this._ingressClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressClassNameInput() {
    return this._ingressClassName;
  }

  // ingress_controller - computed: false, optional: true, required: false
  private _ingressController?: string; 
  public get ingressController() {
    return this.getStringAttribute('ingress_controller');
  }
  public set ingressController(value: string) {
    this._ingressController = value;
  }
  public resetIngressController() {
    this._ingressController = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressControllerInput() {
    return this._ingressController;
  }

  // ingress_hosts - computed: false, optional: true, required: false
  private _ingressHosts = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHostsList(this, "ingress_hosts", false);
  public get ingressHosts() {
    return this._ingressHosts;
  }
  public putIngressHosts(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecIngressHosts[] | cdktf.IResolvable) {
    this._ingressHosts.internalValue = value;
  }
  public resetIngressHosts() {
    this._ingressHosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressHostsInput() {
    return this._ingressHosts.internalValue;
  }

  // ingress_path - computed: false, optional: true, required: false
  private _ingressPath?: string; 
  public get ingressPath() {
    return this.getStringAttribute('ingress_path');
  }
  public set ingressPath(value: string) {
    this._ingressPath = value;
  }
  public resetIngressPath() {
    this._ingressPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressPathInput() {
    return this._ingressPath;
  }

  // ingress_path_type - computed: false, optional: true, required: false
  private _ingressPathType?: string; 
  public get ingressPathType() {
    return this.getStringAttribute('ingress_path_type');
  }
  public set ingressPathType(value: string) {
    this._ingressPathType = value;
  }
  public resetIngressPathType() {
    this._ingressPathType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressPathTypeInput() {
    return this._ingressPathType;
  }

  // ingress_tls_secret - computed: false, optional: true, required: false
  private _ingressTlsSecret?: string; 
  public get ingressTlsSecret() {
    return this.getStringAttribute('ingress_tls_secret');
  }
  public set ingressTlsSecret(value: string) {
    this._ingressTlsSecret = value;
  }
  public resetIngressTlsSecret() {
    this._ingressTlsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressTlsSecretInput() {
    return this._ingressTlsSecret;
  }

  // ingress_type - computed: false, optional: true, required: false
  private _ingressType?: string; 
  public get ingressType() {
    return this.getStringAttribute('ingress_type');
  }
  public set ingressType(value: string) {
    this._ingressType = value;
  }
  public resetIngressType() {
    this._ingressType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressTypeInput() {
    return this._ingressType;
  }

  // init_container_extra_commands - computed: false, optional: true, required: false
  private _initContainerExtraCommands?: string; 
  public get initContainerExtraCommands() {
    return this.getStringAttribute('init_container_extra_commands');
  }
  public set initContainerExtraCommands(value: string) {
    this._initContainerExtraCommands = value;
  }
  public resetInitContainerExtraCommands() {
    this._initContainerExtraCommands = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainerExtraCommandsInput() {
    return this._initContainerExtraCommands;
  }

  // init_container_extra_volume_mounts - computed: false, optional: true, required: false
  private _initContainerExtraVolumeMounts?: string; 
  public get initContainerExtraVolumeMounts() {
    return this.getStringAttribute('init_container_extra_volume_mounts');
  }
  public set initContainerExtraVolumeMounts(value: string) {
    this._initContainerExtraVolumeMounts = value;
  }
  public resetInitContainerExtraVolumeMounts() {
    this._initContainerExtraVolumeMounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainerExtraVolumeMountsInput() {
    return this._initContainerExtraVolumeMounts;
  }

  // init_container_image - computed: false, optional: true, required: false
  private _initContainerImage?: string; 
  public get initContainerImage() {
    return this.getStringAttribute('init_container_image');
  }
  public set initContainerImage(value: string) {
    this._initContainerImage = value;
  }
  public resetInitContainerImage() {
    this._initContainerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainerImageInput() {
    return this._initContainerImage;
  }

  // init_container_image_version - computed: false, optional: true, required: false
  private _initContainerImageVersion?: string; 
  public get initContainerImageVersion() {
    return this.getStringAttribute('init_container_image_version');
  }
  public set initContainerImageVersion(value: string) {
    this._initContainerImageVersion = value;
  }
  public resetInitContainerImageVersion() {
    this._initContainerImageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainerImageVersionInput() {
    return this._initContainerImageVersion;
  }

  // init_container_resource_requirements - computed: false, optional: true, required: false
  private _initContainerResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirementsOutputReference(this, "init_container_resource_requirements");
  public get initContainerResourceRequirements() {
    return this._initContainerResourceRequirements;
  }
  public putInitContainerResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecInitContainerResourceRequirements) {
    this._initContainerResourceRequirements.internalValue = value;
  }
  public resetInitContainerResourceRequirements() {
    this._initContainerResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initContainerResourceRequirementsInput() {
    return this._initContainerResourceRequirements.internalValue;
  }

  // init_projects_container_image - computed: false, optional: true, required: false
  private _initProjectsContainerImage?: string; 
  public get initProjectsContainerImage() {
    return this.getStringAttribute('init_projects_container_image');
  }
  public set initProjectsContainerImage(value: string) {
    this._initProjectsContainerImage = value;
  }
  public resetInitProjectsContainerImage() {
    this._initProjectsContainerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initProjectsContainerImageInput() {
    return this._initProjectsContainerImage;
  }

  // ipv6_disabled - computed: false, optional: true, required: false
  private _ipv6Disabled?: boolean | cdktf.IResolvable; 
  public get ipv6Disabled() {
    return this.getBooleanAttribute('ipv6_disabled');
  }
  public set ipv6Disabled(value: boolean | cdktf.IResolvable) {
    this._ipv6Disabled = value;
  }
  public resetIpv6Disabled() {
    this._ipv6Disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipv6DisabledInput() {
    return this._ipv6Disabled;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // ldap_cacert_secret - computed: false, optional: true, required: false
  private _ldapCacertSecret?: string; 
  public get ldapCacertSecret() {
    return this.getStringAttribute('ldap_cacert_secret');
  }
  public set ldapCacertSecret(value: string) {
    this._ldapCacertSecret = value;
  }
  public resetLdapCacertSecret() {
    this._ldapCacertSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapCacertSecretInput() {
    return this._ldapCacertSecret;
  }

  // ldap_password_secret - computed: false, optional: true, required: false
  private _ldapPasswordSecret?: string; 
  public get ldapPasswordSecret() {
    return this.getStringAttribute('ldap_password_secret');
  }
  public set ldapPasswordSecret(value: string) {
    this._ldapPasswordSecret = value;
  }
  public resetLdapPasswordSecret() {
    this._ldapPasswordSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapPasswordSecretInput() {
    return this._ldapPasswordSecret;
  }

  // loadbalancer_class - computed: false, optional: true, required: false
  private _loadbalancerClass?: string; 
  public get loadbalancerClass() {
    return this.getStringAttribute('loadbalancer_class');
  }
  public set loadbalancerClass(value: string) {
    this._loadbalancerClass = value;
  }
  public resetLoadbalancerClass() {
    this._loadbalancerClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadbalancerClassInput() {
    return this._loadbalancerClass;
  }

  // loadbalancer_ip - computed: false, optional: true, required: false
  private _loadbalancerIp?: string; 
  public get loadbalancerIp() {
    return this.getStringAttribute('loadbalancer_ip');
  }
  public set loadbalancerIp(value: string) {
    this._loadbalancerIp = value;
  }
  public resetLoadbalancerIp() {
    this._loadbalancerIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadbalancerIpInput() {
    return this._loadbalancerIp;
  }

  // loadbalancer_port - computed: false, optional: true, required: false
  private _loadbalancerPort?: number; 
  public get loadbalancerPort() {
    return this.getNumberAttribute('loadbalancer_port');
  }
  public set loadbalancerPort(value: number) {
    this._loadbalancerPort = value;
  }
  public resetLoadbalancerPort() {
    this._loadbalancerPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadbalancerPortInput() {
    return this._loadbalancerPort;
  }

  // loadbalancer_protocol - computed: false, optional: true, required: false
  private _loadbalancerProtocol?: string; 
  public get loadbalancerProtocol() {
    return this.getStringAttribute('loadbalancer_protocol');
  }
  public set loadbalancerProtocol(value: string) {
    this._loadbalancerProtocol = value;
  }
  public resetLoadbalancerProtocol() {
    this._loadbalancerProtocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadbalancerProtocolInput() {
    return this._loadbalancerProtocol;
  }

  // metrics_utility_configmap - computed: false, optional: true, required: false
  private _metricsUtilityConfigmap?: string; 
  public get metricsUtilityConfigmap() {
    return this.getStringAttribute('metrics_utility_configmap');
  }
  public set metricsUtilityConfigmap(value: string) {
    this._metricsUtilityConfigmap = value;
  }
  public resetMetricsUtilityConfigmap() {
    this._metricsUtilityConfigmap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityConfigmapInput() {
    return this._metricsUtilityConfigmap;
  }

  // metrics_utility_console_enabled - computed: false, optional: true, required: false
  private _metricsUtilityConsoleEnabled?: boolean | cdktf.IResolvable; 
  public get metricsUtilityConsoleEnabled() {
    return this.getBooleanAttribute('metrics_utility_console_enabled');
  }
  public set metricsUtilityConsoleEnabled(value: boolean | cdktf.IResolvable) {
    this._metricsUtilityConsoleEnabled = value;
  }
  public resetMetricsUtilityConsoleEnabled() {
    this._metricsUtilityConsoleEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityConsoleEnabledInput() {
    return this._metricsUtilityConsoleEnabled;
  }

  // metrics_utility_cronjob_gather_schedule - computed: false, optional: true, required: false
  private _metricsUtilityCronjobGatherSchedule?: string; 
  public get metricsUtilityCronjobGatherSchedule() {
    return this.getStringAttribute('metrics_utility_cronjob_gather_schedule');
  }
  public set metricsUtilityCronjobGatherSchedule(value: string) {
    this._metricsUtilityCronjobGatherSchedule = value;
  }
  public resetMetricsUtilityCronjobGatherSchedule() {
    this._metricsUtilityCronjobGatherSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityCronjobGatherScheduleInput() {
    return this._metricsUtilityCronjobGatherSchedule;
  }

  // metrics_utility_cronjob_report_schedule - computed: false, optional: true, required: false
  private _metricsUtilityCronjobReportSchedule?: string; 
  public get metricsUtilityCronjobReportSchedule() {
    return this.getStringAttribute('metrics_utility_cronjob_report_schedule');
  }
  public set metricsUtilityCronjobReportSchedule(value: string) {
    this._metricsUtilityCronjobReportSchedule = value;
  }
  public resetMetricsUtilityCronjobReportSchedule() {
    this._metricsUtilityCronjobReportSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityCronjobReportScheduleInput() {
    return this._metricsUtilityCronjobReportSchedule;
  }

  // metrics_utility_enabled - computed: false, optional: true, required: false
  private _metricsUtilityEnabled?: boolean | cdktf.IResolvable; 
  public get metricsUtilityEnabled() {
    return this.getBooleanAttribute('metrics_utility_enabled');
  }
  public set metricsUtilityEnabled(value: boolean | cdktf.IResolvable) {
    this._metricsUtilityEnabled = value;
  }
  public resetMetricsUtilityEnabled() {
    this._metricsUtilityEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityEnabledInput() {
    return this._metricsUtilityEnabled;
  }

  // metrics_utility_image - computed: false, optional: true, required: false
  private _metricsUtilityImage?: string; 
  public get metricsUtilityImage() {
    return this.getStringAttribute('metrics_utility_image');
  }
  public set metricsUtilityImage(value: string) {
    this._metricsUtilityImage = value;
  }
  public resetMetricsUtilityImage() {
    this._metricsUtilityImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityImageInput() {
    return this._metricsUtilityImage;
  }

  // metrics_utility_image_pull_policy - computed: false, optional: true, required: false
  private _metricsUtilityImagePullPolicy?: string; 
  public get metricsUtilityImagePullPolicy() {
    return this.getStringAttribute('metrics_utility_image_pull_policy');
  }
  public set metricsUtilityImagePullPolicy(value: string) {
    this._metricsUtilityImagePullPolicy = value;
  }
  public resetMetricsUtilityImagePullPolicy() {
    this._metricsUtilityImagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityImagePullPolicyInput() {
    return this._metricsUtilityImagePullPolicy;
  }

  // metrics_utility_image_version - computed: false, optional: true, required: false
  private _metricsUtilityImageVersion?: string; 
  public get metricsUtilityImageVersion() {
    return this.getStringAttribute('metrics_utility_image_version');
  }
  public set metricsUtilityImageVersion(value: string) {
    this._metricsUtilityImageVersion = value;
  }
  public resetMetricsUtilityImageVersion() {
    this._metricsUtilityImageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityImageVersionInput() {
    return this._metricsUtilityImageVersion;
  }

  // metrics_utility_pvc_claim - computed: false, optional: true, required: false
  private _metricsUtilityPvcClaim?: string; 
  public get metricsUtilityPvcClaim() {
    return this.getStringAttribute('metrics_utility_pvc_claim');
  }
  public set metricsUtilityPvcClaim(value: string) {
    this._metricsUtilityPvcClaim = value;
  }
  public resetMetricsUtilityPvcClaim() {
    this._metricsUtilityPvcClaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityPvcClaimInput() {
    return this._metricsUtilityPvcClaim;
  }

  // metrics_utility_pvc_claim_size - computed: false, optional: true, required: false
  private _metricsUtilityPvcClaimSize?: string; 
  public get metricsUtilityPvcClaimSize() {
    return this.getStringAttribute('metrics_utility_pvc_claim_size');
  }
  public set metricsUtilityPvcClaimSize(value: string) {
    this._metricsUtilityPvcClaimSize = value;
  }
  public resetMetricsUtilityPvcClaimSize() {
    this._metricsUtilityPvcClaimSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityPvcClaimSizeInput() {
    return this._metricsUtilityPvcClaimSize;
  }

  // metrics_utility_pvc_claim_storage_class - computed: false, optional: true, required: false
  private _metricsUtilityPvcClaimStorageClass?: string; 
  public get metricsUtilityPvcClaimStorageClass() {
    return this.getStringAttribute('metrics_utility_pvc_claim_storage_class');
  }
  public set metricsUtilityPvcClaimStorageClass(value: string) {
    this._metricsUtilityPvcClaimStorageClass = value;
  }
  public resetMetricsUtilityPvcClaimStorageClass() {
    this._metricsUtilityPvcClaimStorageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityPvcClaimStorageClassInput() {
    return this._metricsUtilityPvcClaimStorageClass;
  }

  // metrics_utility_secret - computed: false, optional: true, required: false
  private _metricsUtilitySecret?: string; 
  public get metricsUtilitySecret() {
    return this.getStringAttribute('metrics_utility_secret');
  }
  public set metricsUtilitySecret(value: string) {
    this._metricsUtilitySecret = value;
  }
  public resetMetricsUtilitySecret() {
    this._metricsUtilitySecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilitySecretInput() {
    return this._metricsUtilitySecret;
  }

  // metrics_utility_ship_target - computed: false, optional: true, required: false
  private _metricsUtilityShipTarget?: string; 
  public get metricsUtilityShipTarget() {
    return this.getStringAttribute('metrics_utility_ship_target');
  }
  public set metricsUtilityShipTarget(value: string) {
    this._metricsUtilityShipTarget = value;
  }
  public resetMetricsUtilityShipTarget() {
    this._metricsUtilityShipTarget = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsUtilityShipTargetInput() {
    return this._metricsUtilityShipTarget;
  }

  // nginx_listen_queue_size - computed: false, optional: true, required: false
  private _nginxListenQueueSize?: number; 
  public get nginxListenQueueSize() {
    return this.getNumberAttribute('nginx_listen_queue_size');
  }
  public set nginxListenQueueSize(value: number) {
    this._nginxListenQueueSize = value;
  }
  public resetNginxListenQueueSize() {
    this._nginxListenQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nginxListenQueueSizeInput() {
    return this._nginxListenQueueSize;
  }

  // nginx_worker_connections - computed: false, optional: true, required: false
  private _nginxWorkerConnections?: number; 
  public get nginxWorkerConnections() {
    return this.getNumberAttribute('nginx_worker_connections');
  }
  public set nginxWorkerConnections(value: number) {
    this._nginxWorkerConnections = value;
  }
  public resetNginxWorkerConnections() {
    this._nginxWorkerConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nginxWorkerConnectionsInput() {
    return this._nginxWorkerConnections;
  }

  // nginx_worker_cpu_affinity - computed: false, optional: true, required: false
  private _nginxWorkerCpuAffinity?: string; 
  public get nginxWorkerCpuAffinity() {
    return this.getStringAttribute('nginx_worker_cpu_affinity');
  }
  public set nginxWorkerCpuAffinity(value: string) {
    this._nginxWorkerCpuAffinity = value;
  }
  public resetNginxWorkerCpuAffinity() {
    this._nginxWorkerCpuAffinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nginxWorkerCpuAffinityInput() {
    return this._nginxWorkerCpuAffinity;
  }

  // nginx_worker_processes - computed: false, optional: true, required: false
  private _nginxWorkerProcesses?: number; 
  public get nginxWorkerProcesses() {
    return this.getNumberAttribute('nginx_worker_processes');
  }
  public set nginxWorkerProcesses(value: number) {
    this._nginxWorkerProcesses = value;
  }
  public resetNginxWorkerProcesses() {
    this._nginxWorkerProcesses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nginxWorkerProcessesInput() {
    return this._nginxWorkerProcesses;
  }

  // no_log - computed: false, optional: true, required: false
  private _noLog?: boolean | cdktf.IResolvable; 
  public get noLog() {
    return this.getBooleanAttribute('no_log');
  }
  public set noLog(value: boolean | cdktf.IResolvable) {
    this._noLog = value;
  }
  public resetNoLog() {
    this._noLog = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get noLogInput() {
    return this._noLog;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: string; 
  public get nodeSelector() {
    return this.getStringAttribute('node_selector');
  }
  public set nodeSelector(value: string) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // nodeport_port - computed: false, optional: true, required: false
  private _nodeportPort?: number; 
  public get nodeportPort() {
    return this.getNumberAttribute('nodeport_port');
  }
  public set nodeportPort(value: number) {
    this._nodeportPort = value;
  }
  public resetNodeportPort() {
    this._nodeportPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeportPortInput() {
    return this._nodeportPort;
  }

  // old_postgres_configuration_secret - computed: false, optional: true, required: false
  private _oldPostgresConfigurationSecret?: string; 
  public get oldPostgresConfigurationSecret() {
    return this.getStringAttribute('old_postgres_configuration_secret');
  }
  public set oldPostgresConfigurationSecret(value: string) {
    this._oldPostgresConfigurationSecret = value;
  }
  public resetOldPostgresConfigurationSecret() {
    this._oldPostgresConfigurationSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oldPostgresConfigurationSecretInput() {
    return this._oldPostgresConfigurationSecret;
  }

  // pg_dump_suffix - computed: false, optional: true, required: false
  private _pgDumpSuffix?: string; 
  public get pgDumpSuffix() {
    return this.getStringAttribute('pg_dump_suffix');
  }
  public set pgDumpSuffix(value: string) {
    this._pgDumpSuffix = value;
  }
  public resetPgDumpSuffix() {
    this._pgDumpSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pgDumpSuffixInput() {
    return this._pgDumpSuffix;
  }

  // postgres_annotations - computed: false, optional: true, required: false
  private _postgresAnnotations?: string; 
  public get postgresAnnotations() {
    return this.getStringAttribute('postgres_annotations');
  }
  public set postgresAnnotations(value: string) {
    this._postgresAnnotations = value;
  }
  public resetPostgresAnnotations() {
    this._postgresAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresAnnotationsInput() {
    return this._postgresAnnotations;
  }

  // postgres_configuration_secret - computed: false, optional: true, required: false
  private _postgresConfigurationSecret?: string; 
  public get postgresConfigurationSecret() {
    return this.getStringAttribute('postgres_configuration_secret');
  }
  public set postgresConfigurationSecret(value: string) {
    this._postgresConfigurationSecret = value;
  }
  public resetPostgresConfigurationSecret() {
    this._postgresConfigurationSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresConfigurationSecretInput() {
    return this._postgresConfigurationSecret;
  }

  // postgres_data_volume_init - computed: false, optional: true, required: false
  private _postgresDataVolumeInit?: boolean | cdktf.IResolvable; 
  public get postgresDataVolumeInit() {
    return this.getBooleanAttribute('postgres_data_volume_init');
  }
  public set postgresDataVolumeInit(value: boolean | cdktf.IResolvable) {
    this._postgresDataVolumeInit = value;
  }
  public resetPostgresDataVolumeInit() {
    this._postgresDataVolumeInit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresDataVolumeInitInput() {
    return this._postgresDataVolumeInit;
  }

  // postgres_extra_args - computed: false, optional: true, required: false
  private _postgresExtraArgs?: string[]; 
  public get postgresExtraArgs() {
    return this.getListAttribute('postgres_extra_args');
  }
  public set postgresExtraArgs(value: string[]) {
    this._postgresExtraArgs = value;
  }
  public resetPostgresExtraArgs() {
    this._postgresExtraArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresExtraArgsInput() {
    return this._postgresExtraArgs;
  }

  // postgres_extra_volume_mounts - computed: false, optional: true, required: false
  private _postgresExtraVolumeMounts?: string; 
  public get postgresExtraVolumeMounts() {
    return this.getStringAttribute('postgres_extra_volume_mounts');
  }
  public set postgresExtraVolumeMounts(value: string) {
    this._postgresExtraVolumeMounts = value;
  }
  public resetPostgresExtraVolumeMounts() {
    this._postgresExtraVolumeMounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresExtraVolumeMountsInput() {
    return this._postgresExtraVolumeMounts;
  }

  // postgres_extra_volumes - computed: false, optional: true, required: false
  private _postgresExtraVolumes?: string; 
  public get postgresExtraVolumes() {
    return this.getStringAttribute('postgres_extra_volumes');
  }
  public set postgresExtraVolumes(value: string) {
    this._postgresExtraVolumes = value;
  }
  public resetPostgresExtraVolumes() {
    this._postgresExtraVolumes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresExtraVolumesInput() {
    return this._postgresExtraVolumes;
  }

  // postgres_image - computed: false, optional: true, required: false
  private _postgresImage?: string; 
  public get postgresImage() {
    return this.getStringAttribute('postgres_image');
  }
  public set postgresImage(value: string) {
    this._postgresImage = value;
  }
  public resetPostgresImage() {
    this._postgresImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresImageInput() {
    return this._postgresImage;
  }

  // postgres_image_version - computed: false, optional: true, required: false
  private _postgresImageVersion?: string; 
  public get postgresImageVersion() {
    return this.getStringAttribute('postgres_image_version');
  }
  public set postgresImageVersion(value: string) {
    this._postgresImageVersion = value;
  }
  public resetPostgresImageVersion() {
    this._postgresImageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresImageVersionInput() {
    return this._postgresImageVersion;
  }

  // postgres_init_container_commands - computed: false, optional: true, required: false
  private _postgresInitContainerCommands?: string; 
  public get postgresInitContainerCommands() {
    return this.getStringAttribute('postgres_init_container_commands');
  }
  public set postgresInitContainerCommands(value: string) {
    this._postgresInitContainerCommands = value;
  }
  public resetPostgresInitContainerCommands() {
    this._postgresInitContainerCommands = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresInitContainerCommandsInput() {
    return this._postgresInitContainerCommands;
  }

  // postgres_init_container_resource_requirements - computed: false, optional: true, required: false
  private _postgresInitContainerResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirementsOutputReference(this, "postgres_init_container_resource_requirements");
  public get postgresInitContainerResourceRequirements() {
    return this._postgresInitContainerResourceRequirements;
  }
  public putPostgresInitContainerResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresInitContainerResourceRequirements) {
    this._postgresInitContainerResourceRequirements.internalValue = value;
  }
  public resetPostgresInitContainerResourceRequirements() {
    this._postgresInitContainerResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresInitContainerResourceRequirementsInput() {
    return this._postgresInitContainerResourceRequirements.internalValue;
  }

  // postgres_keep_pvc_after_upgrade - computed: false, optional: true, required: false
  private _postgresKeepPvcAfterUpgrade?: boolean | cdktf.IResolvable; 
  public get postgresKeepPvcAfterUpgrade() {
    return this.getBooleanAttribute('postgres_keep_pvc_after_upgrade');
  }
  public set postgresKeepPvcAfterUpgrade(value: boolean | cdktf.IResolvable) {
    this._postgresKeepPvcAfterUpgrade = value;
  }
  public resetPostgresKeepPvcAfterUpgrade() {
    this._postgresKeepPvcAfterUpgrade = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresKeepPvcAfterUpgradeInput() {
    return this._postgresKeepPvcAfterUpgrade;
  }

  // postgres_keepalives - computed: false, optional: true, required: false
  private _postgresKeepalives?: boolean | cdktf.IResolvable; 
  public get postgresKeepalives() {
    return this.getBooleanAttribute('postgres_keepalives');
  }
  public set postgresKeepalives(value: boolean | cdktf.IResolvable) {
    this._postgresKeepalives = value;
  }
  public resetPostgresKeepalives() {
    this._postgresKeepalives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresKeepalivesInput() {
    return this._postgresKeepalives;
  }

  // postgres_keepalives_count - computed: false, optional: true, required: false
  private _postgresKeepalivesCount?: number; 
  public get postgresKeepalivesCount() {
    return this.getNumberAttribute('postgres_keepalives_count');
  }
  public set postgresKeepalivesCount(value: number) {
    this._postgresKeepalivesCount = value;
  }
  public resetPostgresKeepalivesCount() {
    this._postgresKeepalivesCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresKeepalivesCountInput() {
    return this._postgresKeepalivesCount;
  }

  // postgres_keepalives_idle - computed: false, optional: true, required: false
  private _postgresKeepalivesIdle?: number; 
  public get postgresKeepalivesIdle() {
    return this.getNumberAttribute('postgres_keepalives_idle');
  }
  public set postgresKeepalivesIdle(value: number) {
    this._postgresKeepalivesIdle = value;
  }
  public resetPostgresKeepalivesIdle() {
    this._postgresKeepalivesIdle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresKeepalivesIdleInput() {
    return this._postgresKeepalivesIdle;
  }

  // postgres_keepalives_interval - computed: false, optional: true, required: false
  private _postgresKeepalivesInterval?: number; 
  public get postgresKeepalivesInterval() {
    return this.getNumberAttribute('postgres_keepalives_interval');
  }
  public set postgresKeepalivesInterval(value: number) {
    this._postgresKeepalivesInterval = value;
  }
  public resetPostgresKeepalivesInterval() {
    this._postgresKeepalivesInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresKeepalivesIntervalInput() {
    return this._postgresKeepalivesInterval;
  }

  // postgres_label_selector - computed: false, optional: true, required: false
  private _postgresLabelSelector?: string; 
  public get postgresLabelSelector() {
    return this.getStringAttribute('postgres_label_selector');
  }
  public set postgresLabelSelector(value: string) {
    this._postgresLabelSelector = value;
  }
  public resetPostgresLabelSelector() {
    this._postgresLabelSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresLabelSelectorInput() {
    return this._postgresLabelSelector;
  }

  // postgres_priority_class - computed: false, optional: true, required: false
  private _postgresPriorityClass?: string; 
  public get postgresPriorityClass() {
    return this.getStringAttribute('postgres_priority_class');
  }
  public set postgresPriorityClass(value: string) {
    this._postgresPriorityClass = value;
  }
  public resetPostgresPriorityClass() {
    this._postgresPriorityClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresPriorityClassInput() {
    return this._postgresPriorityClass;
  }

  // postgres_resource_requirements - computed: false, optional: true, required: false
  private _postgresResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirementsOutputReference(this, "postgres_resource_requirements");
  public get postgresResourceRequirements() {
    return this._postgresResourceRequirements;
  }
  public putPostgresResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresResourceRequirements) {
    this._postgresResourceRequirements.internalValue = value;
  }
  public resetPostgresResourceRequirements() {
    this._postgresResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresResourceRequirementsInput() {
    return this._postgresResourceRequirements.internalValue;
  }

  // postgres_security_context_settings - computed: false, optional: true, required: false
  private _postgresSecurityContextSettings?: { [key: string]: string }; 
  public get postgresSecurityContextSettings() {
    return this.getStringMapAttribute('postgres_security_context_settings');
  }
  public set postgresSecurityContextSettings(value: { [key: string]: string }) {
    this._postgresSecurityContextSettings = value;
  }
  public resetPostgresSecurityContextSettings() {
    this._postgresSecurityContextSettings = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresSecurityContextSettingsInput() {
    return this._postgresSecurityContextSettings;
  }

  // postgres_selector - computed: false, optional: true, required: false
  private _postgresSelector?: string; 
  public get postgresSelector() {
    return this.getStringAttribute('postgres_selector');
  }
  public set postgresSelector(value: string) {
    this._postgresSelector = value;
  }
  public resetPostgresSelector() {
    this._postgresSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresSelectorInput() {
    return this._postgresSelector;
  }

  // postgres_storage_class - computed: false, optional: true, required: false
  private _postgresStorageClass?: string; 
  public get postgresStorageClass() {
    return this.getStringAttribute('postgres_storage_class');
  }
  public set postgresStorageClass(value: string) {
    this._postgresStorageClass = value;
  }
  public resetPostgresStorageClass() {
    this._postgresStorageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresStorageClassInput() {
    return this._postgresStorageClass;
  }

  // postgres_storage_requirements - computed: false, optional: true, required: false
  private _postgresStorageRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirementsOutputReference(this, "postgres_storage_requirements");
  public get postgresStorageRequirements() {
    return this._postgresStorageRequirements;
  }
  public putPostgresStorageRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecPostgresStorageRequirements) {
    this._postgresStorageRequirements.internalValue = value;
  }
  public resetPostgresStorageRequirements() {
    this._postgresStorageRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresStorageRequirementsInput() {
    return this._postgresStorageRequirements.internalValue;
  }

  // postgres_tolerations - computed: false, optional: true, required: false
  private _postgresTolerations?: string; 
  public get postgresTolerations() {
    return this.getStringAttribute('postgres_tolerations');
  }
  public set postgresTolerations(value: string) {
    this._postgresTolerations = value;
  }
  public resetPostgresTolerations() {
    this._postgresTolerations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresTolerationsInput() {
    return this._postgresTolerations;
  }

  // projects_existing_claim - computed: false, optional: true, required: false
  private _projectsExistingClaim?: string; 
  public get projectsExistingClaim() {
    return this.getStringAttribute('projects_existing_claim');
  }
  public set projectsExistingClaim(value: string) {
    this._projectsExistingClaim = value;
  }
  public resetProjectsExistingClaim() {
    this._projectsExistingClaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectsExistingClaimInput() {
    return this._projectsExistingClaim;
  }

  // projects_persistence - computed: false, optional: true, required: false
  private _projectsPersistence?: boolean | cdktf.IResolvable; 
  public get projectsPersistence() {
    return this.getBooleanAttribute('projects_persistence');
  }
  public set projectsPersistence(value: boolean | cdktf.IResolvable) {
    this._projectsPersistence = value;
  }
  public resetProjectsPersistence() {
    this._projectsPersistence = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectsPersistenceInput() {
    return this._projectsPersistence;
  }

  // projects_storage_access_mode - computed: false, optional: true, required: false
  private _projectsStorageAccessMode?: string; 
  public get projectsStorageAccessMode() {
    return this.getStringAttribute('projects_storage_access_mode');
  }
  public set projectsStorageAccessMode(value: string) {
    this._projectsStorageAccessMode = value;
  }
  public resetProjectsStorageAccessMode() {
    this._projectsStorageAccessMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectsStorageAccessModeInput() {
    return this._projectsStorageAccessMode;
  }

  // projects_storage_class - computed: false, optional: true, required: false
  private _projectsStorageClass?: string; 
  public get projectsStorageClass() {
    return this.getStringAttribute('projects_storage_class');
  }
  public set projectsStorageClass(value: string) {
    this._projectsStorageClass = value;
  }
  public resetProjectsStorageClass() {
    this._projectsStorageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectsStorageClassInput() {
    return this._projectsStorageClass;
  }

  // projects_storage_size - computed: false, optional: true, required: false
  private _projectsStorageSize?: string; 
  public get projectsStorageSize() {
    return this.getStringAttribute('projects_storage_size');
  }
  public set projectsStorageSize(value: string) {
    this._projectsStorageSize = value;
  }
  public resetProjectsStorageSize() {
    this._projectsStorageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectsStorageSizeInput() {
    return this._projectsStorageSize;
  }

  // projects_use_existing_claim - computed: false, optional: true, required: false
  private _projectsUseExistingClaim?: string; 
  public get projectsUseExistingClaim() {
    return this.getStringAttribute('projects_use_existing_claim');
  }
  public set projectsUseExistingClaim(value: string) {
    this._projectsUseExistingClaim = value;
  }
  public resetProjectsUseExistingClaim() {
    this._projectsUseExistingClaim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectsUseExistingClaimInput() {
    return this._projectsUseExistingClaim;
  }

  // receptor_log_level - computed: false, optional: true, required: false
  private _receptorLogLevel?: string; 
  public get receptorLogLevel() {
    return this.getStringAttribute('receptor_log_level');
  }
  public set receptorLogLevel(value: string) {
    this._receptorLogLevel = value;
  }
  public resetReceptorLogLevel() {
    this._receptorLogLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get receptorLogLevelInput() {
    return this._receptorLogLevel;
  }

  // redis_capabilities - computed: false, optional: true, required: false
  private _redisCapabilities?: string[]; 
  public get redisCapabilities() {
    return this.getListAttribute('redis_capabilities');
  }
  public set redisCapabilities(value: string[]) {
    this._redisCapabilities = value;
  }
  public resetRedisCapabilities() {
    this._redisCapabilities = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisCapabilitiesInput() {
    return this._redisCapabilities;
  }

  // redis_image - computed: false, optional: true, required: false
  private _redisImage?: string; 
  public get redisImage() {
    return this.getStringAttribute('redis_image');
  }
  public set redisImage(value: string) {
    this._redisImage = value;
  }
  public resetRedisImage() {
    this._redisImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisImageInput() {
    return this._redisImage;
  }

  // redis_image_version - computed: false, optional: true, required: false
  private _redisImageVersion?: string; 
  public get redisImageVersion() {
    return this.getStringAttribute('redis_image_version');
  }
  public set redisImageVersion(value: string) {
    this._redisImageVersion = value;
  }
  public resetRedisImageVersion() {
    this._redisImageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisImageVersionInput() {
    return this._redisImageVersion;
  }

  // redis_resource_requirements - computed: false, optional: true, required: false
  private _redisResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirementsOutputReference(this, "redis_resource_requirements");
  public get redisResourceRequirements() {
    return this._redisResourceRequirements;
  }
  public putRedisResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRedisResourceRequirements) {
    this._redisResourceRequirements.internalValue = value;
  }
  public resetRedisResourceRequirements() {
    this._redisResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisResourceRequirementsInput() {
    return this._redisResourceRequirements.internalValue;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // route_api_version - computed: false, optional: true, required: false
  private _routeApiVersion?: string; 
  public get routeApiVersion() {
    return this.getStringAttribute('route_api_version');
  }
  public set routeApiVersion(value: string) {
    this._routeApiVersion = value;
  }
  public resetRouteApiVersion() {
    this._routeApiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeApiVersionInput() {
    return this._routeApiVersion;
  }

  // route_host - computed: false, optional: true, required: false
  private _routeHost?: string; 
  public get routeHost() {
    return this.getStringAttribute('route_host');
  }
  public set routeHost(value: string) {
    this._routeHost = value;
  }
  public resetRouteHost() {
    this._routeHost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeHostInput() {
    return this._routeHost;
  }

  // route_tls_secret - computed: false, optional: true, required: false
  private _routeTlsSecret?: string; 
  public get routeTlsSecret() {
    return this.getStringAttribute('route_tls_secret');
  }
  public set routeTlsSecret(value: string) {
    this._routeTlsSecret = value;
  }
  public resetRouteTlsSecret() {
    this._routeTlsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTlsSecretInput() {
    return this._routeTlsSecret;
  }

  // route_tls_termination_mechanism - computed: false, optional: true, required: false
  private _routeTlsTerminationMechanism?: string; 
  public get routeTlsTerminationMechanism() {
    return this.getStringAttribute('route_tls_termination_mechanism');
  }
  public set routeTlsTerminationMechanism(value: string) {
    this._routeTlsTerminationMechanism = value;
  }
  public resetRouteTlsTerminationMechanism() {
    this._routeTlsTerminationMechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTlsTerminationMechanismInput() {
    return this._routeTlsTerminationMechanism;
  }

  // rsyslog_args - computed: false, optional: true, required: false
  private _rsyslogArgs?: string[]; 
  public get rsyslogArgs() {
    return this.getListAttribute('rsyslog_args');
  }
  public set rsyslogArgs(value: string[]) {
    this._rsyslogArgs = value;
  }
  public resetRsyslogArgs() {
    this._rsyslogArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rsyslogArgsInput() {
    return this._rsyslogArgs;
  }

  // rsyslog_command - computed: false, optional: true, required: false
  private _rsyslogCommand?: string[]; 
  public get rsyslogCommand() {
    return this.getListAttribute('rsyslog_command');
  }
  public set rsyslogCommand(value: string[]) {
    this._rsyslogCommand = value;
  }
  public resetRsyslogCommand() {
    this._rsyslogCommand = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rsyslogCommandInput() {
    return this._rsyslogCommand;
  }

  // rsyslog_extra_env - computed: false, optional: true, required: false
  private _rsyslogExtraEnv?: string; 
  public get rsyslogExtraEnv() {
    return this.getStringAttribute('rsyslog_extra_env');
  }
  public set rsyslogExtraEnv(value: string) {
    this._rsyslogExtraEnv = value;
  }
  public resetRsyslogExtraEnv() {
    this._rsyslogExtraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rsyslogExtraEnvInput() {
    return this._rsyslogExtraEnv;
  }

  // rsyslog_extra_volume_mounts - computed: false, optional: true, required: false
  private _rsyslogExtraVolumeMounts?: string; 
  public get rsyslogExtraVolumeMounts() {
    return this.getStringAttribute('rsyslog_extra_volume_mounts');
  }
  public set rsyslogExtraVolumeMounts(value: string) {
    this._rsyslogExtraVolumeMounts = value;
  }
  public resetRsyslogExtraVolumeMounts() {
    this._rsyslogExtraVolumeMounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rsyslogExtraVolumeMountsInput() {
    return this._rsyslogExtraVolumeMounts;
  }

  // rsyslog_resource_requirements - computed: false, optional: true, required: false
  private _rsyslogResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirementsOutputReference(this, "rsyslog_resource_requirements");
  public get rsyslogResourceRequirements() {
    return this._rsyslogResourceRequirements;
  }
  public putRsyslogResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecRsyslogResourceRequirements) {
    this._rsyslogResourceRequirements.internalValue = value;
  }
  public resetRsyslogResourceRequirements() {
    this._rsyslogResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rsyslogResourceRequirementsInput() {
    return this._rsyslogResourceRequirements.internalValue;
  }

  // secret_key_secret - computed: false, optional: true, required: false
  private _secretKeySecret?: string; 
  public get secretKeySecret() {
    return this.getStringAttribute('secret_key_secret');
  }
  public set secretKeySecret(value: string) {
    this._secretKeySecret = value;
  }
  public resetSecretKeySecret() {
    this._secretKeySecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeySecretInput() {
    return this._secretKeySecret;
  }

  // security_context_settings - computed: false, optional: true, required: false
  private _securityContextSettings?: { [key: string]: string }; 
  public get securityContextSettings() {
    return this.getStringMapAttribute('security_context_settings');
  }
  public set securityContextSettings(value: { [key: string]: string }) {
    this._securityContextSettings = value;
  }
  public resetSecurityContextSettings() {
    this._securityContextSettings = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityContextSettingsInput() {
    return this._securityContextSettings;
  }

  // service_account_annotations - computed: false, optional: true, required: false
  private _serviceAccountAnnotations?: string; 
  public get serviceAccountAnnotations() {
    return this.getStringAttribute('service_account_annotations');
  }
  public set serviceAccountAnnotations(value: string) {
    this._serviceAccountAnnotations = value;
  }
  public resetServiceAccountAnnotations() {
    this._serviceAccountAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountAnnotationsInput() {
    return this._serviceAccountAnnotations;
  }

  // service_annotations - computed: false, optional: true, required: false
  private _serviceAnnotations?: string; 
  public get serviceAnnotations() {
    return this.getStringAttribute('service_annotations');
  }
  public set serviceAnnotations(value: string) {
    this._serviceAnnotations = value;
  }
  public resetServiceAnnotations() {
    this._serviceAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAnnotationsInput() {
    return this._serviceAnnotations;
  }

  // service_labels - computed: false, optional: true, required: false
  private _serviceLabels?: string; 
  public get serviceLabels() {
    return this.getStringAttribute('service_labels');
  }
  public set serviceLabels(value: string) {
    this._serviceLabels = value;
  }
  public resetServiceLabels() {
    this._serviceLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceLabelsInput() {
    return this._serviceLabels;
  }

  // service_type - computed: false, optional: true, required: false
  private _serviceType?: string; 
  public get serviceType() {
    return this.getStringAttribute('service_type');
  }
  public set serviceType(value: string) {
    this._serviceType = value;
  }
  public resetServiceType() {
    this._serviceType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceTypeInput() {
    return this._serviceType;
  }

  // session_cookie_secure - computed: false, optional: true, required: false
  private _sessionCookieSecure?: string; 
  public get sessionCookieSecure() {
    return this.getStringAttribute('session_cookie_secure');
  }
  public set sessionCookieSecure(value: string) {
    this._sessionCookieSecure = value;
  }
  public resetSessionCookieSecure() {
    this._sessionCookieSecure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionCookieSecureInput() {
    return this._sessionCookieSecure;
  }

  // set_self_labels - computed: false, optional: true, required: false
  private _setSelfLabels?: boolean | cdktf.IResolvable; 
  public get setSelfLabels() {
    return this.getBooleanAttribute('set_self_labels');
  }
  public set setSelfLabels(value: boolean | cdktf.IResolvable) {
    this._setSelfLabels = value;
  }
  public resetSetSelfLabels() {
    this._setSelfLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setSelfLabelsInput() {
    return this._setSelfLabels;
  }

  // task_affinity - computed: false, optional: true, required: false
  private _taskAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinityOutputReference(this, "task_affinity");
  public get taskAffinity() {
    return this._taskAffinity;
  }
  public putTaskAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskAffinity) {
    this._taskAffinity.internalValue = value;
  }
  public resetTaskAffinity() {
    this._taskAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskAffinityInput() {
    return this._taskAffinity.internalValue;
  }

  // task_annotations - computed: false, optional: true, required: false
  private _taskAnnotations?: string; 
  public get taskAnnotations() {
    return this.getStringAttribute('task_annotations');
  }
  public set taskAnnotations(value: string) {
    this._taskAnnotations = value;
  }
  public resetTaskAnnotations() {
    this._taskAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskAnnotationsInput() {
    return this._taskAnnotations;
  }

  // task_args - computed: false, optional: true, required: false
  private _taskArgs?: string[]; 
  public get taskArgs() {
    return this.getListAttribute('task_args');
  }
  public set taskArgs(value: string[]) {
    this._taskArgs = value;
  }
  public resetTaskArgs() {
    this._taskArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskArgsInput() {
    return this._taskArgs;
  }

  // task_command - computed: false, optional: true, required: false
  private _taskCommand?: string[]; 
  public get taskCommand() {
    return this.getListAttribute('task_command');
  }
  public set taskCommand(value: string[]) {
    this._taskCommand = value;
  }
  public resetTaskCommand() {
    this._taskCommand = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskCommandInput() {
    return this._taskCommand;
  }

  // task_extra_env - computed: false, optional: true, required: false
  private _taskExtraEnv?: string; 
  public get taskExtraEnv() {
    return this.getStringAttribute('task_extra_env');
  }
  public set taskExtraEnv(value: string) {
    this._taskExtraEnv = value;
  }
  public resetTaskExtraEnv() {
    this._taskExtraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskExtraEnvInput() {
    return this._taskExtraEnv;
  }

  // task_extra_volume_mounts - computed: false, optional: true, required: false
  private _taskExtraVolumeMounts?: string; 
  public get taskExtraVolumeMounts() {
    return this.getStringAttribute('task_extra_volume_mounts');
  }
  public set taskExtraVolumeMounts(value: string) {
    this._taskExtraVolumeMounts = value;
  }
  public resetTaskExtraVolumeMounts() {
    this._taskExtraVolumeMounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskExtraVolumeMountsInput() {
    return this._taskExtraVolumeMounts;
  }

  // task_liveness_failure_threshold - computed: false, optional: true, required: false
  private _taskLivenessFailureThreshold?: number; 
  public get taskLivenessFailureThreshold() {
    return this.getNumberAttribute('task_liveness_failure_threshold');
  }
  public set taskLivenessFailureThreshold(value: number) {
    this._taskLivenessFailureThreshold = value;
  }
  public resetTaskLivenessFailureThreshold() {
    this._taskLivenessFailureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskLivenessFailureThresholdInput() {
    return this._taskLivenessFailureThreshold;
  }

  // task_liveness_initial_delay - computed: false, optional: true, required: false
  private _taskLivenessInitialDelay?: number; 
  public get taskLivenessInitialDelay() {
    return this.getNumberAttribute('task_liveness_initial_delay');
  }
  public set taskLivenessInitialDelay(value: number) {
    this._taskLivenessInitialDelay = value;
  }
  public resetTaskLivenessInitialDelay() {
    this._taskLivenessInitialDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskLivenessInitialDelayInput() {
    return this._taskLivenessInitialDelay;
  }

  // task_liveness_period - computed: false, optional: true, required: false
  private _taskLivenessPeriod?: number; 
  public get taskLivenessPeriod() {
    return this.getNumberAttribute('task_liveness_period');
  }
  public set taskLivenessPeriod(value: number) {
    this._taskLivenessPeriod = value;
  }
  public resetTaskLivenessPeriod() {
    this._taskLivenessPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskLivenessPeriodInput() {
    return this._taskLivenessPeriod;
  }

  // task_liveness_timeout - computed: false, optional: true, required: false
  private _taskLivenessTimeout?: number; 
  public get taskLivenessTimeout() {
    return this.getNumberAttribute('task_liveness_timeout');
  }
  public set taskLivenessTimeout(value: number) {
    this._taskLivenessTimeout = value;
  }
  public resetTaskLivenessTimeout() {
    this._taskLivenessTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskLivenessTimeoutInput() {
    return this._taskLivenessTimeout;
  }

  // task_manage_replicas - computed: false, optional: true, required: false
  private _taskManageReplicas?: boolean | cdktf.IResolvable; 
  public get taskManageReplicas() {
    return this.getBooleanAttribute('task_manage_replicas');
  }
  public set taskManageReplicas(value: boolean | cdktf.IResolvable) {
    this._taskManageReplicas = value;
  }
  public resetTaskManageReplicas() {
    this._taskManageReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskManageReplicasInput() {
    return this._taskManageReplicas;
  }

  // task_node_selector - computed: false, optional: true, required: false
  private _taskNodeSelector?: string; 
  public get taskNodeSelector() {
    return this.getStringAttribute('task_node_selector');
  }
  public set taskNodeSelector(value: string) {
    this._taskNodeSelector = value;
  }
  public resetTaskNodeSelector() {
    this._taskNodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskNodeSelectorInput() {
    return this._taskNodeSelector;
  }

  // task_privileged - computed: false, optional: true, required: false
  private _taskPrivileged?: boolean | cdktf.IResolvable; 
  public get taskPrivileged() {
    return this.getBooleanAttribute('task_privileged');
  }
  public set taskPrivileged(value: boolean | cdktf.IResolvable) {
    this._taskPrivileged = value;
  }
  public resetTaskPrivileged() {
    this._taskPrivileged = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskPrivilegedInput() {
    return this._taskPrivileged;
  }

  // task_readiness_failure_threshold - computed: false, optional: true, required: false
  private _taskReadinessFailureThreshold?: number; 
  public get taskReadinessFailureThreshold() {
    return this.getNumberAttribute('task_readiness_failure_threshold');
  }
  public set taskReadinessFailureThreshold(value: number) {
    this._taskReadinessFailureThreshold = value;
  }
  public resetTaskReadinessFailureThreshold() {
    this._taskReadinessFailureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskReadinessFailureThresholdInput() {
    return this._taskReadinessFailureThreshold;
  }

  // task_readiness_initial_delay - computed: false, optional: true, required: false
  private _taskReadinessInitialDelay?: number; 
  public get taskReadinessInitialDelay() {
    return this.getNumberAttribute('task_readiness_initial_delay');
  }
  public set taskReadinessInitialDelay(value: number) {
    this._taskReadinessInitialDelay = value;
  }
  public resetTaskReadinessInitialDelay() {
    this._taskReadinessInitialDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskReadinessInitialDelayInput() {
    return this._taskReadinessInitialDelay;
  }

  // task_readiness_period - computed: false, optional: true, required: false
  private _taskReadinessPeriod?: number; 
  public get taskReadinessPeriod() {
    return this.getNumberAttribute('task_readiness_period');
  }
  public set taskReadinessPeriod(value: number) {
    this._taskReadinessPeriod = value;
  }
  public resetTaskReadinessPeriod() {
    this._taskReadinessPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskReadinessPeriodInput() {
    return this._taskReadinessPeriod;
  }

  // task_readiness_timeout - computed: false, optional: true, required: false
  private _taskReadinessTimeout?: number; 
  public get taskReadinessTimeout() {
    return this.getNumberAttribute('task_readiness_timeout');
  }
  public set taskReadinessTimeout(value: number) {
    this._taskReadinessTimeout = value;
  }
  public resetTaskReadinessTimeout() {
    this._taskReadinessTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskReadinessTimeoutInput() {
    return this._taskReadinessTimeout;
  }

  // task_replicas - computed: false, optional: true, required: false
  private _taskReplicas?: number; 
  public get taskReplicas() {
    return this.getNumberAttribute('task_replicas');
  }
  public set taskReplicas(value: number) {
    this._taskReplicas = value;
  }
  public resetTaskReplicas() {
    this._taskReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskReplicasInput() {
    return this._taskReplicas;
  }

  // task_resource_requirements - computed: false, optional: true, required: false
  private _taskResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirementsOutputReference(this, "task_resource_requirements");
  public get taskResourceRequirements() {
    return this._taskResourceRequirements;
  }
  public putTaskResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecTaskResourceRequirements) {
    this._taskResourceRequirements.internalValue = value;
  }
  public resetTaskResourceRequirements() {
    this._taskResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskResourceRequirementsInput() {
    return this._taskResourceRequirements.internalValue;
  }

  // task_tolerations - computed: false, optional: true, required: false
  private _taskTolerations?: string; 
  public get taskTolerations() {
    return this.getStringAttribute('task_tolerations');
  }
  public set taskTolerations(value: string) {
    this._taskTolerations = value;
  }
  public resetTaskTolerations() {
    this._taskTolerations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskTolerationsInput() {
    return this._taskTolerations;
  }

  // task_topology_spread_constraints - computed: false, optional: true, required: false
  private _taskTopologySpreadConstraints?: string; 
  public get taskTopologySpreadConstraints() {
    return this.getStringAttribute('task_topology_spread_constraints');
  }
  public set taskTopologySpreadConstraints(value: string) {
    this._taskTopologySpreadConstraints = value;
  }
  public resetTaskTopologySpreadConstraints() {
    this._taskTopologySpreadConstraints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get taskTopologySpreadConstraintsInput() {
    return this._taskTopologySpreadConstraints;
  }

  // termination_grace_period_seconds - computed: false, optional: true, required: false
  private _terminationGracePeriodSeconds?: number; 
  public get terminationGracePeriodSeconds() {
    return this.getNumberAttribute('termination_grace_period_seconds');
  }
  public set terminationGracePeriodSeconds(value: number) {
    this._terminationGracePeriodSeconds = value;
  }
  public resetTerminationGracePeriodSeconds() {
    this._terminationGracePeriodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminationGracePeriodSecondsInput() {
    return this._terminationGracePeriodSeconds;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations?: string; 
  public get tolerations() {
    return this.getStringAttribute('tolerations');
  }
  public set tolerations(value: string) {
    this._tolerations = value;
  }
  public resetTolerations() {
    this._tolerations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations;
  }

  // topology_spread_constraints - computed: false, optional: true, required: false
  private _topologySpreadConstraints?: string; 
  public get topologySpreadConstraints() {
    return this.getStringAttribute('topology_spread_constraints');
  }
  public set topologySpreadConstraints(value: string) {
    this._topologySpreadConstraints = value;
  }
  public resetTopologySpreadConstraints() {
    this._topologySpreadConstraints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologySpreadConstraintsInput() {
    return this._topologySpreadConstraints;
  }

  // uwsgi_listen_queue_size - computed: false, optional: true, required: false
  private _uwsgiListenQueueSize?: number; 
  public get uwsgiListenQueueSize() {
    return this.getNumberAttribute('uwsgi_listen_queue_size');
  }
  public set uwsgiListenQueueSize(value: number) {
    this._uwsgiListenQueueSize = value;
  }
  public resetUwsgiListenQueueSize() {
    this._uwsgiListenQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uwsgiListenQueueSizeInput() {
    return this._uwsgiListenQueueSize;
  }

  // uwsgi_processes - computed: false, optional: true, required: false
  private _uwsgiProcesses?: number; 
  public get uwsgiProcesses() {
    return this.getNumberAttribute('uwsgi_processes');
  }
  public set uwsgiProcesses(value: number) {
    this._uwsgiProcesses = value;
  }
  public resetUwsgiProcesses() {
    this._uwsgiProcesses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uwsgiProcessesInput() {
    return this._uwsgiProcesses;
  }

  // web_affinity - computed: false, optional: true, required: false
  private _webAffinity = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinityOutputReference(this, "web_affinity");
  public get webAffinity() {
    return this._webAffinity;
  }
  public putWebAffinity(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebAffinity) {
    this._webAffinity.internalValue = value;
  }
  public resetWebAffinity() {
    this._webAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webAffinityInput() {
    return this._webAffinity.internalValue;
  }

  // web_annotations - computed: false, optional: true, required: false
  private _webAnnotations?: string; 
  public get webAnnotations() {
    return this.getStringAttribute('web_annotations');
  }
  public set webAnnotations(value: string) {
    this._webAnnotations = value;
  }
  public resetWebAnnotations() {
    this._webAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webAnnotationsInput() {
    return this._webAnnotations;
  }

  // web_args - computed: false, optional: true, required: false
  private _webArgs?: string[]; 
  public get webArgs() {
    return this.getListAttribute('web_args');
  }
  public set webArgs(value: string[]) {
    this._webArgs = value;
  }
  public resetWebArgs() {
    this._webArgs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webArgsInput() {
    return this._webArgs;
  }

  // web_command - computed: false, optional: true, required: false
  private _webCommand?: string[]; 
  public get webCommand() {
    return this.getListAttribute('web_command');
  }
  public set webCommand(value: string[]) {
    this._webCommand = value;
  }
  public resetWebCommand() {
    this._webCommand = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webCommandInput() {
    return this._webCommand;
  }

  // web_extra_env - computed: false, optional: true, required: false
  private _webExtraEnv?: string; 
  public get webExtraEnv() {
    return this.getStringAttribute('web_extra_env');
  }
  public set webExtraEnv(value: string) {
    this._webExtraEnv = value;
  }
  public resetWebExtraEnv() {
    this._webExtraEnv = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webExtraEnvInput() {
    return this._webExtraEnv;
  }

  // web_extra_volume_mounts - computed: false, optional: true, required: false
  private _webExtraVolumeMounts?: string; 
  public get webExtraVolumeMounts() {
    return this.getStringAttribute('web_extra_volume_mounts');
  }
  public set webExtraVolumeMounts(value: string) {
    this._webExtraVolumeMounts = value;
  }
  public resetWebExtraVolumeMounts() {
    this._webExtraVolumeMounts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webExtraVolumeMountsInput() {
    return this._webExtraVolumeMounts;
  }

  // web_liveness_failure_threshold - computed: false, optional: true, required: false
  private _webLivenessFailureThreshold?: number; 
  public get webLivenessFailureThreshold() {
    return this.getNumberAttribute('web_liveness_failure_threshold');
  }
  public set webLivenessFailureThreshold(value: number) {
    this._webLivenessFailureThreshold = value;
  }
  public resetWebLivenessFailureThreshold() {
    this._webLivenessFailureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webLivenessFailureThresholdInput() {
    return this._webLivenessFailureThreshold;
  }

  // web_liveness_initial_delay - computed: false, optional: true, required: false
  private _webLivenessInitialDelay?: number; 
  public get webLivenessInitialDelay() {
    return this.getNumberAttribute('web_liveness_initial_delay');
  }
  public set webLivenessInitialDelay(value: number) {
    this._webLivenessInitialDelay = value;
  }
  public resetWebLivenessInitialDelay() {
    this._webLivenessInitialDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webLivenessInitialDelayInput() {
    return this._webLivenessInitialDelay;
  }

  // web_liveness_period - computed: false, optional: true, required: false
  private _webLivenessPeriod?: number; 
  public get webLivenessPeriod() {
    return this.getNumberAttribute('web_liveness_period');
  }
  public set webLivenessPeriod(value: number) {
    this._webLivenessPeriod = value;
  }
  public resetWebLivenessPeriod() {
    this._webLivenessPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webLivenessPeriodInput() {
    return this._webLivenessPeriod;
  }

  // web_liveness_timeout - computed: false, optional: true, required: false
  private _webLivenessTimeout?: number; 
  public get webLivenessTimeout() {
    return this.getNumberAttribute('web_liveness_timeout');
  }
  public set webLivenessTimeout(value: number) {
    this._webLivenessTimeout = value;
  }
  public resetWebLivenessTimeout() {
    this._webLivenessTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webLivenessTimeoutInput() {
    return this._webLivenessTimeout;
  }

  // web_manage_replicas - computed: false, optional: true, required: false
  private _webManageReplicas?: boolean | cdktf.IResolvable; 
  public get webManageReplicas() {
    return this.getBooleanAttribute('web_manage_replicas');
  }
  public set webManageReplicas(value: boolean | cdktf.IResolvable) {
    this._webManageReplicas = value;
  }
  public resetWebManageReplicas() {
    this._webManageReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webManageReplicasInput() {
    return this._webManageReplicas;
  }

  // web_node_selector - computed: false, optional: true, required: false
  private _webNodeSelector?: string; 
  public get webNodeSelector() {
    return this.getStringAttribute('web_node_selector');
  }
  public set webNodeSelector(value: string) {
    this._webNodeSelector = value;
  }
  public resetWebNodeSelector() {
    this._webNodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webNodeSelectorInput() {
    return this._webNodeSelector;
  }

  // web_readiness_failure_threshold - computed: false, optional: true, required: false
  private _webReadinessFailureThreshold?: number; 
  public get webReadinessFailureThreshold() {
    return this.getNumberAttribute('web_readiness_failure_threshold');
  }
  public set webReadinessFailureThreshold(value: number) {
    this._webReadinessFailureThreshold = value;
  }
  public resetWebReadinessFailureThreshold() {
    this._webReadinessFailureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webReadinessFailureThresholdInput() {
    return this._webReadinessFailureThreshold;
  }

  // web_readiness_initial_delay - computed: false, optional: true, required: false
  private _webReadinessInitialDelay?: number; 
  public get webReadinessInitialDelay() {
    return this.getNumberAttribute('web_readiness_initial_delay');
  }
  public set webReadinessInitialDelay(value: number) {
    this._webReadinessInitialDelay = value;
  }
  public resetWebReadinessInitialDelay() {
    this._webReadinessInitialDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webReadinessInitialDelayInput() {
    return this._webReadinessInitialDelay;
  }

  // web_readiness_period - computed: false, optional: true, required: false
  private _webReadinessPeriod?: number; 
  public get webReadinessPeriod() {
    return this.getNumberAttribute('web_readiness_period');
  }
  public set webReadinessPeriod(value: number) {
    this._webReadinessPeriod = value;
  }
  public resetWebReadinessPeriod() {
    this._webReadinessPeriod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webReadinessPeriodInput() {
    return this._webReadinessPeriod;
  }

  // web_readiness_timeout - computed: false, optional: true, required: false
  private _webReadinessTimeout?: number; 
  public get webReadinessTimeout() {
    return this.getNumberAttribute('web_readiness_timeout');
  }
  public set webReadinessTimeout(value: number) {
    this._webReadinessTimeout = value;
  }
  public resetWebReadinessTimeout() {
    this._webReadinessTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webReadinessTimeoutInput() {
    return this._webReadinessTimeout;
  }

  // web_replicas - computed: false, optional: true, required: false
  private _webReplicas?: number; 
  public get webReplicas() {
    return this.getNumberAttribute('web_replicas');
  }
  public set webReplicas(value: number) {
    this._webReplicas = value;
  }
  public resetWebReplicas() {
    this._webReplicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webReplicasInput() {
    return this._webReplicas;
  }

  // web_resource_requirements - computed: false, optional: true, required: false
  private _webResourceRequirements = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirementsOutputReference(this, "web_resource_requirements");
  public get webResourceRequirements() {
    return this._webResourceRequirements;
  }
  public putWebResourceRequirements(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecWebResourceRequirements) {
    this._webResourceRequirements.internalValue = value;
  }
  public resetWebResourceRequirements() {
    this._webResourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webResourceRequirementsInput() {
    return this._webResourceRequirements.internalValue;
  }

  // web_tolerations - computed: false, optional: true, required: false
  private _webTolerations?: string; 
  public get webTolerations() {
    return this.getStringAttribute('web_tolerations');
  }
  public set webTolerations(value: string) {
    this._webTolerations = value;
  }
  public resetWebTolerations() {
    this._webTolerations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webTolerationsInput() {
    return this._webTolerations;
  }

  // web_topology_spread_constraints - computed: false, optional: true, required: false
  private _webTopologySpreadConstraints?: string; 
  public get webTopologySpreadConstraints() {
    return this.getStringAttribute('web_topology_spread_constraints');
  }
  public set webTopologySpreadConstraints(value: string) {
    this._webTopologySpreadConstraints = value;
  }
  public resetWebTopologySpreadConstraints() {
    this._webTopologySpreadConstraints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webTopologySpreadConstraintsInput() {
    return this._webTopologySpreadConstraints;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest k8s_awx_ansible_com_awx_v1beta1_manifest}
*/
export class DataK8SAwxAnsibleComAwxV1Beta1Manifest extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "k8s_awx_ansible_com_awx_v1beta1_manifest";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataK8SAwxAnsibleComAwxV1Beta1Manifest resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataK8SAwxAnsibleComAwxV1Beta1Manifest to import
  * @param importFromId The id of the existing DataK8SAwxAnsibleComAwxV1Beta1Manifest that should be imported. Refer to the {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataK8SAwxAnsibleComAwxV1Beta1Manifest to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "k8s_awx_ansible_com_awx_v1beta1_manifest", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/metio/k8s/2025.11.3/docs/data-sources/awx_ansible_com_awx_v1beta1_manifest k8s_awx_ansible_com_awx_v1beta1_manifest} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataK8SAwxAnsibleComAwxV1Beta1ManifestConfig
  */
  public constructor(scope: Construct, id: string, config: DataK8SAwxAnsibleComAwxV1Beta1ManifestConfig) {
    super(scope, id, {
      terraformResourceType: 'k8s_awx_ansible_com_awx_v1beta1_manifest',
      terraformGeneratorMetadata: {
        providerName: 'k8s',
        providerVersion: '2025.11.3'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._metadata.internalValue = config.metadata;
    this._spec.internalValue = config.spec;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // metadata - computed: false, optional: false, required: true
  private _metadata = new DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SAwxAnsibleComAwxV1Beta1ManifestSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // yaml - computed: true, optional: false, required: false
  public get yaml() {
    return this.getStringAttribute('yaml');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      metadata: dataK8SAwxAnsibleComAwxV1Beta1ManifestMetadataToTerraform(this._metadata.internalValue),
      spec: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecToTerraform(this._spec.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      metadata: {
        value: dataK8SAwxAnsibleComAwxV1Beta1ManifestMetadataToHclTerraform(this._metadata.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestMetadata",
      },
      spec: {
        value: dataK8SAwxAnsibleComAwxV1Beta1ManifestSpecToHclTerraform(this._spec.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SAwxAnsibleComAwxV1Beta1ManifestSpec",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
