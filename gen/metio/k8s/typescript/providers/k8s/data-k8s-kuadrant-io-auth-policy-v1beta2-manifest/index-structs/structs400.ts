import * as cdktf from 'cdktf';
import { DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectors,
dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectorsToTerraform,
dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectorsToHclTerraform,
DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectorsList,
DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRules,
dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRulesToTerraform,
dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRulesToHclTerraform,
DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRulesOutputReference } from './structs0'
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaults {
  /**
  * Named sets of patterns that can be referred in 'when' conditions and in pattern-matching authorization policy rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#patterns DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#patterns}
  */
  readonly patterns?: { [key: string]: string };
  /**
  * Top-level route selectors. If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the external authorization service. At least one selected HTTPRoute rule must match to trigger the AuthPolicy. If no route selectors are specified, the AuthPolicy will be enforced at all requests to the protected routes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#route_selectors DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#route_selectors}
  */
  readonly routeSelectors?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectors[] | cdktf.IResolvable;
  /**
  * The auth rules of the policy. See Authorino's AuthConfig CRD for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#rules DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#rules}
  */
  readonly rules?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRules;
  /**
  * Overall conditions for the AuthPolicy to be enforced. If omitted, the AuthPolicy will be enforced at all requests to the protected routes. If present, all conditions must match for the AuthPolicy to be enforced; otherwise, the authorization service skips the AuthPolicy and returns to the auth request with status OK.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#when DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#when}
  */
  readonly when?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    patterns: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.patterns),
    route_selectors: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectorsToTerraform, false)(struct!.routeSelectors),
    rules: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRulesToTerraform(struct!.rules),
    when: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenToTerraform, false)(struct!.when),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    patterns: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.patterns),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    route_selectors: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectorsToHclTerraform, false)(struct!.routeSelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectorsList",
    },
    rules: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRulesToHclTerraform(struct!.rules),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRules",
    },
    when: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenToHclTerraform, false)(struct!.when),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaults | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._patterns !== undefined) {
      hasAnyValues = true;
      internalValueResult.patterns = this._patterns;
    }
    if (this._routeSelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSelectors = this._routeSelectors?.internalValue;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._when?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.when = this._when?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaults | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._patterns = undefined;
      this._routeSelectors.internalValue = undefined;
      this._rules.internalValue = undefined;
      this._when.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._patterns = value.patterns;
      this._routeSelectors.internalValue = value.routeSelectors;
      this._rules.internalValue = value.rules;
      this._when.internalValue = value.when;
    }
  }

  // patterns - computed: false, optional: true, required: false
  private _patterns?: { [key: string]: string }; 
  public get patterns() {
    return this.getStringMapAttribute('patterns');
  }
  public set patterns(value: { [key: string]: string }) {
    this._patterns = value;
  }
  public resetPatterns() {
    this._patterns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternsInput() {
    return this._patterns;
  }

  // route_selectors - computed: false, optional: true, required: false
  private _routeSelectors = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectorsList(this, "route_selectors", false);
  public get routeSelectors() {
    return this._routeSelectors;
  }
  public putRouteSelectors(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRouteSelectors[] | cdktf.IResolvable) {
    this._routeSelectors.internalValue = value;
  }
  public resetRouteSelectors() {
    this._routeSelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSelectorsInput() {
    return this._routeSelectors.internalValue;
  }

  // rules - computed: false, optional: true, required: false
  private _rules = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRulesOutputReference(this, "rules");
  public get rules() {
    return this._rules;
  }
  public putRules(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsRules) {
    this._rules.internalValue = value;
  }
  public resetRules() {
    this._rules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // when - computed: false, optional: true, required: false
  private _when = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhenList(this, "when", false);
  public get when() {
    return this._when;
  }
  public putWhen(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecDefaultsWhen[] | cdktf.IResolvable) {
    this._when.internalValue = value;
  }
  public resetWhen() {
    this._when.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenInput() {
    return this._when.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders {
  /**
  * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, 'foo' and 'Foo' are considered equivalent. When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for 'Set-Cookie'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the header. Support: Core (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP Header to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath {
  /**
  * Type specifies how to match against the path Value. Support: Core (Exact, PathPrefix) Support: Implementation-specific (RegularExpression)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value of the HTTP path to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPathToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPathToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams {
  /**
  * Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3). If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored. If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API. Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the query parameter. Support: Extended (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP query param to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches {
  /**
  * Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders[] | cdktf.IResolvable;
  /**
  * Method specifies HTTP method matcher. When specified, this route will be matched only if the request has the specified method. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the '/' path is provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#path DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#path}
  */
  readonly path?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath;
  /**
  * QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_params}
  */
  readonly queryParams?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersToTerraform, false)(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    path: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPathToTerraform(struct!.path),
    query_params: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersList",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPathToHclTerraform(struct!.path),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath",
    },
    query_params: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsToHclTerraform, false)(struct!.queryParams),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    if (this._queryParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._path.internalValue = undefined;
      this._queryParams.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._path.internalValue = value.path;
      this._queryParams.internalValue = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPathOutputReference(this, "path");
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesPath) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParamsList(this, "query_params", false);
  public get queryParams() {
    return this._queryParams;
  }
  public putQueryParams(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable) {
    this._queryParams.internalValue = value;
  }
  public resetQueryParams() {
    this._queryParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectors {
  /**
  * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#hostnames DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Matches define conditions used for matching the rule against incoming HTTP requests. https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#matches DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#matches}
  */
  readonly matches?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    matches: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesToTerraform, false)(struct!.matches),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesToHclTerraform, false)(struct!.matches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._matches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._matches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._matches.internalValue = value.matches;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // matches - computed: false, optional: true, required: false
  private _matches = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatchesList(this, "matches", false);
  public get matches() {
    return this._matches;
  }
  public putMatches(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsMatches[] | cdktf.IResolvable) {
    this._matches.internalValue = value;
  }
  public resetMatches() {
    this._matches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRouteSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#values DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#match_expressions DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#match_labels DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey {
  /**
  * Whether Authorino should look for API key secrets in all namespaces or only in the same namespace as the AuthConfig. Enabling this option in namespaced Authorino instances has no effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all_namespaces DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all_namespaces}
  */
  readonly allNamespaces?: boolean | cdktf.IResolvable;
  /**
  * Label selector used by Authorino to match secrets from the cluster storing valid credentials to authenticate to this service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_namespaces: cdktf.booleanToTerraform(struct!.allNamespaces),
    selector: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_namespaces: {
      value: cdktf.booleanToHclTerraform(struct!.allNamespaces),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    selector: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.allNamespaces = this._allNamespaces;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allNamespaces = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allNamespaces = value.allNamespaces;
      this._selector.internalValue = value.selector;
    }
  }

  // all_namespaces - computed: false, optional: true, required: false
  private _allNamespaces?: boolean | cdktf.IResolvable; 
  public get allNamespaces() {
    return this.getBooleanAttribute('all_namespaces');
  }
  public set allNamespaces(value: boolean | cdktf.IResolvable) {
    this._allNamespaces = value;
  }
  public resetAllNamespaces() {
    this._allNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allNamespacesInput() {
    return this._allNamespaces;
  }

  // selector - computed: false, optional: false, required: true
  private _selector = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeySelector) {
    this._selector.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKeyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKeyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache {
  /**
  * Key used to store the entry in the cache. The resolved key must be unique within the scope of this particular config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey;
  /**
  * Duration (in seconds) of the external data in the cache before pulled again from the source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKeyToTerraform(struct!.key),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKeyToHclTerraform(struct!.key),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key?.internalValue;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key.internalValue = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key.internalValue = value.key;
      this._ttl = value.ttl;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKeyOutputReference(this, "key");
  public get key() {
    return this._key;
  }
  public putKey(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheKey) {
    this._key.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key.internalValue;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#prefix DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._prefix = value.prefix;
    }
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookieToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookieToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryStringToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryStringToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryStringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#authorization_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#authorization_header}
  */
  readonly authorizationHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cookie DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cookie}
  */
  readonly cookie?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#custom_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#custom_header}
  */
  readonly customHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_string DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_string}
  */
  readonly queryString?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authorization_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeaderToTerraform(struct!.authorizationHeader),
    cookie: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookieToTerraform(struct!.cookie),
    custom_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeaderToTerraform(struct!.customHeader),
    query_string: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryStringToTerraform(struct!.queryString),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authorization_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeaderToHclTerraform(struct!.authorizationHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader",
    },
    cookie: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie",
    },
    custom_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeaderToHclTerraform(struct!.customHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader",
    },
    query_string: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryStringToHclTerraform(struct!.queryString),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorizationHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationHeader = this._authorizationHeader?.internalValue;
    }
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    if (this._customHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHeader = this._customHeader?.internalValue;
    }
    if (this._queryString?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryString = this._queryString?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = undefined;
      this._cookie.internalValue = undefined;
      this._customHeader.internalValue = undefined;
      this._queryString.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = value.authorizationHeader;
      this._cookie.internalValue = value.cookie;
      this._customHeader.internalValue = value.customHeader;
      this._queryString.internalValue = value.queryString;
    }
  }

  // authorization_header - computed: false, optional: true, required: false
  private _authorizationHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeaderOutputReference(this, "authorization_header");
  public get authorizationHeader() {
    return this._authorizationHeader;
  }
  public putAuthorizationHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsAuthorizationHeader) {
    this._authorizationHeader.internalValue = value;
  }
  public resetAuthorizationHeader() {
    this._authorizationHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationHeaderInput() {
    return this._authorizationHeader.internalValue;
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }

  // custom_header - computed: false, optional: true, required: false
  private _customHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeaderOutputReference(this, "custom_header");
  public get customHeader() {
    return this._customHeader;
  }
  public putCustomHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsCustomHeader) {
    this._customHeader.internalValue = value;
  }
  public resetCustomHeader() {
    this._customHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHeaderInput() {
    return this._customHeader.internalValue;
  }

  // query_string - computed: false, optional: true, required: false
  private _queryString = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryStringOutputReference(this, "query_string");
  public get queryString() {
    return this._queryString;
  }
  public putQueryString(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsQueryString) {
    this._queryString.internalValue = value;
  }
  public resetQueryString() {
    this._queryString.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryStringInput() {
    return this._queryString.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaultsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaultsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaultsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt {
  /**
  * URL of the issuer of the JWT. If 'jwksUrl' is omitted, Authorino will append the path to the OpenID Connect Well-Known Discovery endpoint (i.e. '/.well-known/openid-configuration') to this URL, to discover the OIDC configuration where to obtain the 'jkws_uri' claim from. The value must coincide with the value of the 'iss' (issuer) claim of the discovered OpenID Connect configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#issuer_url DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#issuer_url}
  */
  readonly issuerUrl?: string;
  /**
  * Decides how long to wait before refreshing the JWKS (in seconds). If omitted, Authorino will never refresh the JWKS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwtToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    issuer_url: cdktf.stringToTerraform(struct!.issuerUrl),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwtToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    issuer_url: {
      value: cdktf.stringToHclTerraform(struct!.issuerUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._issuerUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuerUrl = this._issuerUrl;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._issuerUrl = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._issuerUrl = value.issuerUrl;
      this._ttl = value.ttl;
    }
  }

  // issuer_url - computed: false, optional: true, required: false
  private _issuerUrl?: string; 
  public get issuerUrl() {
    return this.getStringAttribute('issuer_url');
  }
  public set issuerUrl(value: string) {
    this._issuerUrl = value;
  }
  public resetIssuerUrl() {
    this._issuerUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerUrlInput() {
    return this._issuerUrl;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview {
  /**
  * The list of audiences (scopes) that must be claimed in a Kubernetes authentication token supplied in the request, and reviewed by Authorino. If omitted, Authorino will review tokens expecting the host name of the requested protected service amongst the audiences.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#audiences DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#audiences}
  */
  readonly audiences?: string[];
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReviewToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReviewToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReviewOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection {
  /**
  * Reference to a Kubernetes secret in the same namespace, that stores client credentials to the OAuth2 server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#credentials_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#credentials_ref}
  */
  readonly credentialsRef: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef;
  /**
  * The full URL of the token introspection endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#endpoint DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#endpoint}
  */
  readonly endpoint: string;
  /**
  * The token type hint for the token introspection. If omitted, it defaults to 'access_token'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#token_type_hint DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#token_type_hint}
  */
  readonly tokenTypeHint?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRefToTerraform(struct!.credentialsRef),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    token_type_hint: cdktf.stringToTerraform(struct!.tokenTypeHint),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRefToHclTerraform(struct!.credentialsRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_type_hint: {
      value: cdktf.stringToHclTerraform(struct!.tokenTypeHint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsRef = this._credentialsRef?.internalValue;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._tokenTypeHint !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTypeHint = this._tokenTypeHint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsRef.internalValue = undefined;
      this._endpoint = undefined;
      this._tokenTypeHint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsRef.internalValue = value.credentialsRef;
      this._endpoint = value.endpoint;
      this._tokenTypeHint = value.tokenTypeHint;
    }
  }

  // credentials_ref - computed: false, optional: false, required: true
  private _credentialsRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRefOutputReference(this, "credentials_ref");
  public get credentialsRef() {
    return this._credentialsRef;
  }
  public putCredentialsRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionCredentialsRef) {
    this._credentialsRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsRefInput() {
    return this._credentialsRef.internalValue;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // token_type_hint - computed: false, optional: true, required: false
  private _tokenTypeHint?: string; 
  public get tokenTypeHint() {
    return this.getStringAttribute('token_type_hint');
  }
  public set tokenTypeHint(value: string) {
    this._tokenTypeHint = value;
  }
  public resetTokenTypeHint() {
    this._tokenTypeHint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTypeHintInput() {
    return this._tokenTypeHint;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverridesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverridesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlainToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlainToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlainOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
    }
  }

  // selector - computed: false, optional: false, required: true
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders {
  /**
  * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, 'foo' and 'Foo' are considered equivalent. When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for 'Set-Cookie'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the header. Support: Core (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP Header to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath {
  /**
  * Type specifies how to match against the path Value. Support: Core (Exact, PathPrefix) Support: Implementation-specific (RegularExpression)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value of the HTTP path to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPathToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPathToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams {
  /**
  * Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3). If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored. If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API. Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the query parameter. Support: Extended (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP query param to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches {
  /**
  * Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders[] | cdktf.IResolvable;
  /**
  * Method specifies HTTP method matcher. When specified, this route will be matched only if the request has the specified method. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the '/' path is provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#path DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#path}
  */
  readonly path?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath;
  /**
  * QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_params}
  */
  readonly queryParams?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersToTerraform, false)(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    path: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPathToTerraform(struct!.path),
    query_params: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersList",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPathToHclTerraform(struct!.path),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath",
    },
    query_params: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsToHclTerraform, false)(struct!.queryParams),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    if (this._queryParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._path.internalValue = undefined;
      this._queryParams.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._path.internalValue = value.path;
      this._queryParams.internalValue = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPathOutputReference(this, "path");
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesPath) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParamsList(this, "query_params", false);
  public get queryParams() {
    return this._queryParams;
  }
  public putQueryParams(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable) {
    this._queryParams.internalValue = value;
  }
  public resetQueryParams() {
    this._queryParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors {
  /**
  * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#hostnames DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Matches define conditions used for matching the rule against incoming HTTP requests. https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#matches DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#matches}
  */
  readonly matches?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    matches: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesToTerraform, false)(struct!.matches),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesToHclTerraform, false)(struct!.matches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._matches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._matches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._matches.internalValue = value.matches;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // matches - computed: false, optional: true, required: false
  private _matches = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatchesList(this, "matches", false);
  public get matches() {
    return this._matches;
  }
  public putMatches(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsMatches[] | cdktf.IResolvable) {
    this._matches.internalValue = value;
  }
  public resetMatches() {
    this._matches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#values DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#match_expressions DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#match_labels DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509 {
  /**
  * Whether Authorino should look for TLS secrets in all namespaces or only in the same namespace as the AuthConfig. Enabling this option in namespaced Authorino instances has no effect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all_namespaces DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all_namespaces}
  */
  readonly allNamespaces?: boolean | cdktf.IResolvable;
  /**
  * Label selector used by Authorino to match secrets from the cluster storing trusted CA certificates to validate clients trying to authenticate to this service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509ToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_namespaces: cdktf.booleanToTerraform(struct!.allNamespaces),
    selector: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorToTerraform(struct!.selector),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509ToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_namespaces: {
      value: cdktf.booleanToHclTerraform(struct!.allNamespaces),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    selector: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.allNamespaces = this._allNamespaces;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allNamespaces = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allNamespaces = value.allNamespaces;
      this._selector.internalValue = value.selector;
    }
  }

  // all_namespaces - computed: false, optional: true, required: false
  private _allNamespaces?: boolean | cdktf.IResolvable; 
  public get allNamespaces() {
    return this.getBooleanAttribute('all_namespaces');
  }
  public set allNamespaces(value: boolean | cdktf.IResolvable) {
    this._allNamespaces = value;
  }
  public resetAllNamespaces() {
    this._allNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allNamespacesInput() {
    return this._allNamespaces;
  }

  // selector - computed: false, optional: false, required: true
  private _selector = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509SelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509Selector) {
    this._selector.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthentication {
  /**
  * Anonymous access.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#anonymous DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#anonymous}
  */
  readonly anonymous?: { [key: string]: string };
  /**
  * Authentication based on API keys stored in Kubernetes secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#api_key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#api_key}
  */
  readonly apiKey?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey;
  /**
  * Caching options for the resolved object returned when applying this config. Omit it to avoid caching objects for this config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache;
  /**
  * Defines where credentials are required to be passed in the request for authentication based on this config. If omitted, it defaults to credentials passed in the HTTP Authorization header and the 'Bearer' prefix prepended to the secret credential value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#credentials DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#credentials}
  */
  readonly credentials?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials;
  /**
  * Set default property values (claims) for the resolved identity object, that are set before appending the object to the authorization JSON. If the property is already present in the resolved identity object, the default value is ignored. It requires the resolved identity object to always be a JSON object. Do not use this option with identity objects of other JSON types (array, string, etc).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#defaults DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#defaults}
  */
  readonly defaults?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults;
  /**
  * Authentication based on JWT tokens.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#jwt DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#jwt}
  */
  readonly jwt?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt;
  /**
  * Authentication by Kubernetes token review.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#kubernetes_token_review DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#kubernetes_token_review}
  */
  readonly kubernetesTokenReview?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview;
  /**
  * Whether this config should generate individual observability metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#metrics DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#metrics}
  */
  readonly metrics?: boolean | cdktf.IResolvable;
  /**
  * Authentication by OAuth2 token introspection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#oauth2_introspection DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#oauth2_introspection}
  */
  readonly oauth2Introspection?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection;
  /**
  * Overrides the resolved identity object by setting the additional properties (claims) specified in this config, before appending the object to the authorization JSON. It requires the resolved identity object to always be a JSON object. Do not use this option with identity objects of other JSON types (array, string, etc).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#overrides DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#overrides}
  */
  readonly overrides?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides;
  /**
  * Identity object extracted from the context. Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#plain DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#plain}
  */
  readonly plain?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain;
  /**
  * Priority group of the config. All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#priority DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#priority}
  */
  readonly priority?: number;
  /**
  * Top-level route selectors. If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule. At least one selected HTTPRoute rule must match to trigger the auth rule. If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#route_selectors DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#route_selectors}
  */
  readonly routeSelectors?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors[] | cdktf.IResolvable;
  /**
  * Conditions for Authorino to enforce this config. If omitted, the config will be enforced for all requests. If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#when DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#when}
  */
  readonly when?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen[] | cdktf.IResolvable;
  /**
  * Authentication based on client X.509 certificates. The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#x509 DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#x509}
  */
  readonly x509?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthentication | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    anonymous: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.anonymous),
    api_key: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeyToTerraform(struct!.apiKey),
    cache: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheToTerraform(struct!.cache),
    credentials: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsToTerraform(struct!.credentials),
    defaults: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaultsToTerraform(struct!.defaults),
    jwt: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwtToTerraform(struct!.jwt),
    kubernetes_token_review: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReviewToTerraform(struct!.kubernetesTokenReview),
    metrics: cdktf.booleanToTerraform(struct!.metrics),
    oauth2_introspection: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionToTerraform(struct!.oauth2Introspection),
    overrides: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverridesToTerraform(struct!.overrides),
    plain: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlainToTerraform(struct!.plain),
    priority: cdktf.numberToTerraform(struct!.priority),
    route_selectors: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsToTerraform, false)(struct!.routeSelectors),
    when: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenToTerraform, false)(struct!.when),
    x509: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509ToTerraform(struct!.x509),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthentication | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    anonymous: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.anonymous),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    api_key: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeyToHclTerraform(struct!.apiKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey",
    },
    cache: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache",
    },
    credentials: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials",
    },
    defaults: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaultsToHclTerraform(struct!.defaults),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults",
    },
    jwt: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt",
    },
    kubernetes_token_review: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReviewToHclTerraform(struct!.kubernetesTokenReview),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview",
    },
    metrics: {
      value: cdktf.booleanToHclTerraform(struct!.metrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    oauth2_introspection: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionToHclTerraform(struct!.oauth2Introspection),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection",
    },
    overrides: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides",
    },
    plain: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlainToHclTerraform(struct!.plain),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    route_selectors: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsToHclTerraform, false)(struct!.routeSelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsList",
    },
    when: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenToHclTerraform, false)(struct!.when),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenList",
    },
    x509: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509ToHclTerraform(struct!.x509),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthentication | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anonymous !== undefined) {
      hasAnyValues = true;
      internalValueResult.anonymous = this._anonymous;
    }
    if (this._apiKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey?.internalValue;
    }
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    if (this._defaults?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaults = this._defaults?.internalValue;
    }
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    if (this._kubernetesTokenReview?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesTokenReview = this._kubernetesTokenReview?.internalValue;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._oauth2Introspection?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2Introspection = this._oauth2Introspection?.internalValue;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    if (this._plain?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plain = this._plain?.internalValue;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._routeSelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSelectors = this._routeSelectors?.internalValue;
    }
    if (this._when?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.when = this._when?.internalValue;
    }
    if (this._x509?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.x509 = this._x509?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthentication | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anonymous = undefined;
      this._apiKey.internalValue = undefined;
      this._cache.internalValue = undefined;
      this._credentials.internalValue = undefined;
      this._defaults.internalValue = undefined;
      this._jwt.internalValue = undefined;
      this._kubernetesTokenReview.internalValue = undefined;
      this._metrics = undefined;
      this._oauth2Introspection.internalValue = undefined;
      this._overrides.internalValue = undefined;
      this._plain.internalValue = undefined;
      this._priority = undefined;
      this._routeSelectors.internalValue = undefined;
      this._when.internalValue = undefined;
      this._x509.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anonymous = value.anonymous;
      this._apiKey.internalValue = value.apiKey;
      this._cache.internalValue = value.cache;
      this._credentials.internalValue = value.credentials;
      this._defaults.internalValue = value.defaults;
      this._jwt.internalValue = value.jwt;
      this._kubernetesTokenReview.internalValue = value.kubernetesTokenReview;
      this._metrics = value.metrics;
      this._oauth2Introspection.internalValue = value.oauth2Introspection;
      this._overrides.internalValue = value.overrides;
      this._plain.internalValue = value.plain;
      this._priority = value.priority;
      this._routeSelectors.internalValue = value.routeSelectors;
      this._when.internalValue = value.when;
      this._x509.internalValue = value.x509;
    }
  }

  // anonymous - computed: false, optional: true, required: false
  private _anonymous?: { [key: string]: string }; 
  public get anonymous() {
    return this.getStringMapAttribute('anonymous');
  }
  public set anonymous(value: { [key: string]: string }) {
    this._anonymous = value;
  }
  public resetAnonymous() {
    this._anonymous = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anonymousInput() {
    return this._anonymous;
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKeyOutputReference(this, "api_key");
  public get apiKey() {
    return this._apiKey;
  }
  public putApiKey(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationApiKey) {
    this._apiKey.internalValue = value;
  }
  public resetApiKey() {
    this._apiKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey.internalValue;
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }

  // defaults - computed: false, optional: true, required: false
  private _defaults = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaultsOutputReference(this, "defaults");
  public get defaults() {
    return this._defaults;
  }
  public putDefaults(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationDefaults) {
    this._defaults.internalValue = value;
  }
  public resetDefaults() {
    this._defaults.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultsInput() {
    return this._defaults.internalValue;
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }

  // kubernetes_token_review - computed: false, optional: true, required: false
  private _kubernetesTokenReview = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReviewOutputReference(this, "kubernetes_token_review");
  public get kubernetesTokenReview() {
    return this._kubernetesTokenReview;
  }
  public putKubernetesTokenReview(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationKubernetesTokenReview) {
    this._kubernetesTokenReview.internalValue = value;
  }
  public resetKubernetesTokenReview() {
    this._kubernetesTokenReview.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesTokenReviewInput() {
    return this._kubernetesTokenReview.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: boolean | cdktf.IResolvable; 
  public get metrics() {
    return this.getBooleanAttribute('metrics');
  }
  public set metrics(value: boolean | cdktf.IResolvable) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // oauth2_introspection - computed: false, optional: true, required: false
  private _oauth2Introspection = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2IntrospectionOutputReference(this, "oauth2_introspection");
  public get oauth2Introspection() {
    return this._oauth2Introspection;
  }
  public putOauth2Introspection(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOauth2Introspection) {
    this._oauth2Introspection.internalValue = value;
  }
  public resetOauth2Introspection() {
    this._oauth2Introspection.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2IntrospectionInput() {
    return this._oauth2Introspection.internalValue;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }

  // plain - computed: false, optional: true, required: false
  private _plain = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlainOutputReference(this, "plain");
  public get plain() {
    return this._plain;
  }
  public putPlain(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationPlain) {
    this._plain.internalValue = value;
  }
  public resetPlain() {
    this._plain.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get plainInput() {
    return this._plain.internalValue;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // route_selectors - computed: false, optional: true, required: false
  private _routeSelectors = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectorsList(this, "route_selectors", false);
  public get routeSelectors() {
    return this._routeSelectors;
  }
  public putRouteSelectors(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationRouteSelectors[] | cdktf.IResolvable) {
    this._routeSelectors.internalValue = value;
  }
  public resetRouteSelectors() {
    this._routeSelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSelectorsInput() {
    return this._routeSelectors.internalValue;
  }

  // when - computed: false, optional: true, required: false
  private _when = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhenList(this, "when", false);
  public get when() {
    return this._when;
  }
  public putWhen(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationWhen[] | cdktf.IResolvable) {
    this._when.internalValue = value;
  }
  public resetWhen() {
    this._when.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenInput() {
    return this._when.internalValue;
  }

  // x509 - computed: false, optional: true, required: false
  private _x509 = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509OutputReference(this, "x509");
  public get x509() {
    return this._x509;
  }
  public putX509(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthenticationX509) {
    this._x509.internalValue = value;
  }
  public resetX509() {
    this._x509.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get x509Input() {
    return this._x509.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKeyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKeyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache {
  /**
  * Key used to store the entry in the cache. The resolved key must be unique within the scope of this particular config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey;
  /**
  * Duration (in seconds) of the external data in the cache before pulled again from the source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKeyToTerraform(struct!.key),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKeyToHclTerraform(struct!.key),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key?.internalValue;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key.internalValue = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key.internalValue = value.key;
      this._ttl = value.ttl;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKeyOutputReference(this, "key");
  public get key() {
    return this._key;
  }
  public putKey(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheKey) {
    this._key.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key.internalValue;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroupToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroupToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNameToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNameToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespaceToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespaceToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResourceToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResourceToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresourceToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresourceToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerbToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerbToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes {
  /**
  * API group of the resource. Use '*' for all API groups.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#group DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#group}
  */
  readonly group?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup;
  /**
  * Resource name Omit it to check for authorization on all resources of the specified kind.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName;
  /**
  * Namespace where the user must have permissions on the resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#namespace DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#namespace}
  */
  readonly namespace?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace;
  /**
  * Resource kind Use '*' for all resource kinds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#resource DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#resource}
  */
  readonly resource?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource;
  /**
  * Subresource kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#subresource DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#subresource}
  */
  readonly subresource?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource;
  /**
  * Verb to check for authorization on the resource. Use '*' for all verbs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#verb DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#verb}
  */
  readonly verb?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroupToTerraform(struct!.group),
    name: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNameToTerraform(struct!.name),
    namespace: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespaceToTerraform(struct!.namespace),
    resource: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResourceToTerraform(struct!.resource),
    subresource: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresourceToTerraform(struct!.subresource),
    verb: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerbToTerraform(struct!.verb),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroupToHclTerraform(struct!.group),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup",
    },
    name: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNameToHclTerraform(struct!.name),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName",
    },
    namespace: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespaceToHclTerraform(struct!.namespace),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace",
    },
    resource: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResourceToHclTerraform(struct!.resource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource",
    },
    subresource: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresourceToHclTerraform(struct!.subresource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource",
    },
    verb: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerbToHclTerraform(struct!.verb),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._group?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group?.internalValue;
    }
    if (this._name?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name?.internalValue;
    }
    if (this._namespace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace?.internalValue;
    }
    if (this._resource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource?.internalValue;
    }
    if (this._subresource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subresource = this._subresource?.internalValue;
    }
    if (this._verb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.verb = this._verb?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._group.internalValue = undefined;
      this._name.internalValue = undefined;
      this._namespace.internalValue = undefined;
      this._resource.internalValue = undefined;
      this._subresource.internalValue = undefined;
      this._verb.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._group.internalValue = value.group;
      this._name.internalValue = value.name;
      this._namespace.internalValue = value.namespace;
      this._resource.internalValue = value.resource;
      this._subresource.internalValue = value.subresource;
      this._verb.internalValue = value.verb;
    }
  }

  // group - computed: false, optional: true, required: false
  private _group = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroupOutputReference(this, "group");
  public get group() {
    return this._group;
  }
  public putGroup(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesGroup) {
    this._group.internalValue = value;
  }
  public resetGroup() {
    this._group.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNameOutputReference(this, "name");
  public get name() {
    return this._name;
  }
  public putName(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesName) {
    this._name.internalValue = value;
  }
  public resetName() {
    this._name.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name.internalValue;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespaceOutputReference(this, "namespace");
  public get namespace() {
    return this._namespace;
  }
  public putNamespace(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesNamespace) {
    this._namespace.internalValue = value;
  }
  public resetNamespace() {
    this._namespace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace.internalValue;
  }

  // resource - computed: false, optional: true, required: false
  private _resource = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResourceOutputReference(this, "resource");
  public get resource() {
    return this._resource;
  }
  public putResource(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesResource) {
    this._resource.internalValue = value;
  }
  public resetResource() {
    this._resource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource.internalValue;
  }

  // subresource - computed: false, optional: true, required: false
  private _subresource = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresourceOutputReference(this, "subresource");
  public get subresource() {
    return this._subresource;
  }
  public putSubresource(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesSubresource) {
    this._subresource.internalValue = value;
  }
  public resetSubresource() {
    this._subresource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subresourceInput() {
    return this._subresource.internalValue;
  }

  // verb - computed: false, optional: true, required: false
  private _verb = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerbOutputReference(this, "verb");
  public get verb() {
    return this._verb;
  }
  public putVerb(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesVerb) {
    this._verb.internalValue = value;
  }
  public resetVerb() {
    this._verb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verbInput() {
    return this._verb.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUserToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUserToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview {
  /**
  * Groups the user must be a member of or, if 'user' is omitted, the groups to check for authorization in the Kubernetes RBAC.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#groups DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#groups}
  */
  readonly groups?: string[];
  /**
  * Use resourceAttributes to check permissions on Kubernetes resources. If omitted, it performs a non-resource SubjectAccessReview, with verb and path inferred from the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#resource_attributes DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#resource_attributes}
  */
  readonly resourceAttributes?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes;
  /**
  * User to check for authorization in the Kubernetes RBAC. Omit it to check for group authorization only.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#user DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#user}
  */
  readonly user?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groups),
    resource_attributes: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesToTerraform(struct!.resourceAttributes),
    user: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUserToTerraform(struct!.user),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    resource_attributes: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesToHclTerraform(struct!.resourceAttributes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes",
    },
    user: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUserToHclTerraform(struct!.user),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._groups !== undefined) {
      hasAnyValues = true;
      internalValueResult.groups = this._groups;
    }
    if (this._resourceAttributes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceAttributes = this._resourceAttributes?.internalValue;
    }
    if (this._user?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._groups = undefined;
      this._resourceAttributes.internalValue = undefined;
      this._user.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._groups = value.groups;
      this._resourceAttributes.internalValue = value.resourceAttributes;
      this._user.internalValue = value.user;
    }
  }

  // groups - computed: false, optional: true, required: false
  private _groups?: string[]; 
  public get groups() {
    return this.getListAttribute('groups');
  }
  public set groups(value: string[]) {
    this._groups = value;
  }
  public resetGroups() {
    this._groups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupsInput() {
    return this._groups;
  }

  // resource_attributes - computed: false, optional: true, required: false
  private _resourceAttributes = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributesOutputReference(this, "resource_attributes");
  public get resourceAttributes() {
    return this._resourceAttributes;
  }
  public putResourceAttributes(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewResourceAttributes) {
    this._resourceAttributes.internalValue = value;
  }
  public resetResourceAttributes() {
    this._resourceAttributes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceAttributesInput() {
    return this._resourceAttributes.internalValue;
  }

  // user - computed: false, optional: true, required: false
  private _user = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUserOutputReference(this, "user");
  public get user() {
    return this._user;
  }
  public putUser(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewUser) {
    this._user.internalValue = value;
  }
  public resetUser() {
    this._user.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParametersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParametersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#prefix DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._prefix = value.prefix;
    }
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookieToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookieToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryStringToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryStringToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryStringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#authorization_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#authorization_header}
  */
  readonly authorizationHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cookie DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cookie}
  */
  readonly cookie?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#custom_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#custom_header}
  */
  readonly customHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_string DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_string}
  */
  readonly queryString?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authorization_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeaderToTerraform(struct!.authorizationHeader),
    cookie: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookieToTerraform(struct!.cookie),
    custom_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeaderToTerraform(struct!.customHeader),
    query_string: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryStringToTerraform(struct!.queryString),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authorization_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeaderToHclTerraform(struct!.authorizationHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader",
    },
    cookie: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie",
    },
    custom_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeaderToHclTerraform(struct!.customHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader",
    },
    query_string: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryStringToHclTerraform(struct!.queryString),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorizationHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationHeader = this._authorizationHeader?.internalValue;
    }
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    if (this._customHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHeader = this._customHeader?.internalValue;
    }
    if (this._queryString?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryString = this._queryString?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = undefined;
      this._cookie.internalValue = undefined;
      this._customHeader.internalValue = undefined;
      this._queryString.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = value.authorizationHeader;
      this._cookie.internalValue = value.cookie;
      this._customHeader.internalValue = value.customHeader;
      this._queryString.internalValue = value.queryString;
    }
  }

  // authorization_header - computed: false, optional: true, required: false
  private _authorizationHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeaderOutputReference(this, "authorization_header");
  public get authorizationHeader() {
    return this._authorizationHeader;
  }
  public putAuthorizationHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsAuthorizationHeader) {
    this._authorizationHeader.internalValue = value;
  }
  public resetAuthorizationHeader() {
    this._authorizationHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationHeaderInput() {
    return this._authorizationHeader.internalValue;
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }

  // custom_header - computed: false, optional: true, required: false
  private _customHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeaderOutputReference(this, "custom_header");
  public get customHeader() {
    return this._customHeader;
  }
  public putCustomHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsCustomHeader) {
    this._customHeader.internalValue = value;
  }
  public resetCustomHeader() {
    this._customHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHeaderInput() {
    return this._customHeader.internalValue;
  }

  // query_string - computed: false, optional: true, required: false
  private _queryString = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryStringOutputReference(this, "query_string");
  public get queryString() {
    return this._queryString;
  }
  public putQueryString(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsQueryString) {
    this._queryString.internalValue = value;
  }
  public resetQueryString() {
    this._queryString.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryStringInput() {
    return this._queryString.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * The name of the secret in the Authorino's namespace to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2 {
  /**
  * Caches and reuses the token until expired. Set it to false to force fetch the token at every authorization request regardless of expiration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: boolean | cdktf.IResolvable;
  /**
  * OAuth2 Client ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#client_id DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#client_id}
  */
  readonly clientId: string;
  /**
  * Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#client_secret_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#client_secret_ref}
  */
  readonly clientSecretRef: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef;
  /**
  * Optional extra parameters for the requests to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#extra_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#extra_params}
  */
  readonly extraParams?: { [key: string]: string };
  /**
  * Optional scopes for the client credentials grant, if supported by he OAuth2 server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#scopes DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#scopes}
  */
  readonly scopes?: string[];
  /**
  * Token endpoint URL of the OAuth2 resource server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#token_url DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#token_url}
  */
  readonly tokenUrl: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: cdktf.booleanToTerraform(struct!.cache),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRefToTerraform(struct!.clientSecretRef),
    extra_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: cdktf.booleanToHclTerraform(struct!.cache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRefToHclTerraform(struct!.clientSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef",
    },
    extra_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecretRef = this._clientSecretRef?.internalValue;
    }
    if (this._extraParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraParams = this._extraParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache = undefined;
      this._clientId = undefined;
      this._clientSecretRef.internalValue = undefined;
      this._extraParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache = value.cache;
      this._clientId = value.clientId;
      this._clientSecretRef.internalValue = value.clientSecretRef;
      this._extraParams = value.extraParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache?: boolean | cdktf.IResolvable; 
  public get cache() {
    return this.getBooleanAttribute('cache');
  }
  public set cache(value: boolean | cdktf.IResolvable) {
    this._cache = value;
  }
  public resetCache() {
    this._cache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret_ref - computed: false, optional: false, required: true
  private _clientSecretRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRefOutputReference(this, "client_secret_ref");
  public get clientSecretRef() {
    return this._clientSecretRef;
  }
  public putClientSecretRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ClientSecretRef) {
    this._clientSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretRefInput() {
    return this._clientSecretRef.internalValue;
  }

  // extra_params - computed: false, optional: true, required: false
  private _extraParams?: { [key: string]: string }; 
  public get extraParams() {
    return this.getStringMapAttribute('extra_params');
  }
  public set extraParams(value: { [key: string]: string }) {
    this._extraParams = value;
  }
  public resetExtraParams() {
    this._extraParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraParamsInput() {
    return this._extraParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: false, required: true
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * The name of the secret in the Authorino's namespace to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy {
  /**
  * Raw body of the HTTP request. Supersedes 'bodyParameters'; use either one or the other. Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body}
  */
  readonly body?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody;
  /**
  * Custom parameters to encode in the body of the HTTP request. Superseded by 'body'; use either one or the other. Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body_parameters DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body_parameters}
  */
  readonly bodyParameters?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters;
  /**
  * Content-Type of the request body. Shapes how 'bodyParameters' are encoded. Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#content_type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#content_type}
  */
  readonly contentType?: string;
  /**
  * Defines where client credentials will be passed in the request to the service. If omitted, it defaults to client credentials passed in the HTTP Authorization header and the 'Bearer' prefix expected prepended to the secret value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#credentials DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#credentials}
  */
  readonly credentials?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials;
  /**
  * Custom headers in the HTTP request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders;
  /**
  * HTTP verb used in the request to the service. Accepted values: GET (default), POST. When the request method is POST, the authorization JSON is passed in the body of the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Authentication with the HTTP service by OAuth2 Client Credentials grant.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#oauth2 DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#oauth2}
  */
  readonly oauth2?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2;
  /**
  * Reference to a Secret key whose value will be passed by Authorino in the request. The HTTP service can use the shared secret to authenticate the origin of the request. Ignored if used together with oauth2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#shared_secret_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#shared_secret_ref}
  */
  readonly sharedSecretRef?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef;
  /**
  * Duration (in seconds) of the external data in the cache before pulled again from the source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
  /**
  * Endpoint URL of the HTTP service. The value can include variable placeholders in the format '{selector}', where 'selector' is any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON. E.g. https://ext-auth-server.io/metadata?p={request.path}
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#url DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyToTerraform(struct!.body),
    body_parameters: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParametersToTerraform(struct!.bodyParameters),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    credentials: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsToTerraform(struct!.credentials),
    headers: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeadersToTerraform(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    oauth2: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ToTerraform(struct!.oauth2),
    shared_secret_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRefToTerraform(struct!.sharedSecretRef),
    ttl: cdktf.numberToTerraform(struct!.ttl),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody",
    },
    body_parameters: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParametersToHclTerraform(struct!.bodyParameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials",
    },
    headers: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth2: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2",
    },
    shared_secret_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRefToHclTerraform(struct!.sharedSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._bodyParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bodyParameters = this._bodyParameters?.internalValue;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._sharedSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedSecretRef = this._sharedSecretRef?.internalValue;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body.internalValue = undefined;
      this._bodyParameters.internalValue = undefined;
      this._contentType = undefined;
      this._credentials.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._oauth2.internalValue = undefined;
      this._sharedSecretRef.internalValue = undefined;
      this._ttl = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body.internalValue = value.body;
      this._bodyParameters.internalValue = value.bodyParameters;
      this._contentType = value.contentType;
      this._credentials.internalValue = value.credentials;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._oauth2.internalValue = value.oauth2;
      this._sharedSecretRef.internalValue = value.sharedSecretRef;
      this._ttl = value.ttl;
      this._url = value.url;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // body_parameters - computed: false, optional: true, required: false
  private _bodyParameters = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParametersOutputReference(this, "body_parameters");
  public get bodyParameters() {
    return this._bodyParameters;
  }
  public putBodyParameters(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyBodyParameters) {
    this._bodyParameters.internalValue = value;
  }
  public resetBodyParameters() {
    this._bodyParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyParametersInput() {
    return this._bodyParameters.internalValue;
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // shared_secret_ref - computed: false, optional: true, required: false
  private _sharedSecretRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRefOutputReference(this, "shared_secret_ref");
  public get sharedSecretRef() {
    return this._sharedSecretRef;
  }
  public putSharedSecretRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicySharedSecretRef) {
    this._sharedSecretRef.internalValue = value;
  }
  public resetSharedSecretRef() {
    this._sharedSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedSecretRefInput() {
    return this._sharedSecretRef.internalValue;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa {
  /**
  * Returns the value of all Rego rules in the virtual document. Values can be read in subsequent evaluators/phases of the Auth Pipeline. Otherwise, only the default 'allow' rule will be exposed. Returning all Rego rules can affect performance of OPA policies during reconciliation (policy precompile) and at runtime.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all_values DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all_values}
  */
  readonly allValues?: boolean | cdktf.IResolvable;
  /**
  * Settings for fetching the OPA policy from an external registry. Use it alternatively to 'rego'. For the configurations of the HTTP request, the following options are not implemented: 'method', 'body', 'bodyParameters', 'contentType', 'headers', 'oauth2'. Use it only with: 'url', 'sharedSecret', 'credentials'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#external_policy DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#external_policy}
  */
  readonly externalPolicy?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy;
  /**
  * Authorization policy as a Rego language document. The Rego document must include the 'allow' condition, set by Authorino to 'false' by default (i.e. requests are unauthorized unless changed). The Rego document must NOT include the 'package' declaration in line 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#rego DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#rego}
  */
  readonly rego?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_values: cdktf.booleanToTerraform(struct!.allValues),
    external_policy: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyToTerraform(struct!.externalPolicy),
    rego: cdktf.stringToTerraform(struct!.rego),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_values: {
      value: cdktf.booleanToHclTerraform(struct!.allValues),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    external_policy: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyToHclTerraform(struct!.externalPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy",
    },
    rego: {
      value: cdktf.stringToHclTerraform(struct!.rego),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allValues !== undefined) {
      hasAnyValues = true;
      internalValueResult.allValues = this._allValues;
    }
    if (this._externalPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalPolicy = this._externalPolicy?.internalValue;
    }
    if (this._rego !== undefined) {
      hasAnyValues = true;
      internalValueResult.rego = this._rego;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allValues = undefined;
      this._externalPolicy.internalValue = undefined;
      this._rego = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allValues = value.allValues;
      this._externalPolicy.internalValue = value.externalPolicy;
      this._rego = value.rego;
    }
  }

  // all_values - computed: false, optional: true, required: false
  private _allValues?: boolean | cdktf.IResolvable; 
  public get allValues() {
    return this.getBooleanAttribute('all_values');
  }
  public set allValues(value: boolean | cdktf.IResolvable) {
    this._allValues = value;
  }
  public resetAllValues() {
    this._allValues = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allValuesInput() {
    return this._allValues;
  }

  // external_policy - computed: false, optional: true, required: false
  private _externalPolicy = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicyOutputReference(this, "external_policy");
  public get externalPolicy() {
    return this._externalPolicy;
  }
  public putExternalPolicy(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaExternalPolicy) {
    this._externalPolicy.internalValue = value;
  }
  public resetExternalPolicy() {
    this._externalPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalPolicyInput() {
    return this._externalPolicy.internalValue;
  }

  // rego - computed: false, optional: true, required: false
  private _rego?: string; 
  public get rego() {
    return this.getStringAttribute('rego');
  }
  public set rego(value: string) {
    this._rego = value;
  }
  public resetRego() {
    this._rego = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regoInput() {
    return this._rego;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#patterns DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#patterns}
  */
  readonly patterns: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    patterns: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsToTerraform, false)(struct!.patterns),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    patterns: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsToHclTerraform, false)(struct!.patterns),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._patterns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patterns = this._patterns?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._patterns.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._patterns.internalValue = value.patterns;
    }
  }

  // patterns - computed: false, optional: false, required: true
  private _patterns = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatternsList(this, "patterns", false);
  public get patterns() {
    return this._patterns;
  }
  public putPatterns(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingPatterns[] | cdktf.IResolvable) {
    this._patterns.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get patternsInput() {
    return this._patterns.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders {
  /**
  * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, 'foo' and 'Foo' are considered equivalent. When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for 'Set-Cookie'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the header. Support: Core (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP Header to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath {
  /**
  * Type specifies how to match against the path Value. Support: Core (Exact, PathPrefix) Support: Implementation-specific (RegularExpression)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value of the HTTP path to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPathToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPathToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams {
  /**
  * Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3). If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored. If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API. Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the query parameter. Support: Extended (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP query param to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches {
  /**
  * Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders[] | cdktf.IResolvable;
  /**
  * Method specifies HTTP method matcher. When specified, this route will be matched only if the request has the specified method. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the '/' path is provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#path DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#path}
  */
  readonly path?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath;
  /**
  * QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_params}
  */
  readonly queryParams?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersToTerraform, false)(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    path: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPathToTerraform(struct!.path),
    query_params: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersList",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPathToHclTerraform(struct!.path),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath",
    },
    query_params: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsToHclTerraform, false)(struct!.queryParams),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    if (this._queryParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._path.internalValue = undefined;
      this._queryParams.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._path.internalValue = value.path;
      this._queryParams.internalValue = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPathOutputReference(this, "path");
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesPath) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParamsList(this, "query_params", false);
  public get queryParams() {
    return this._queryParams;
  }
  public putQueryParams(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable) {
    this._queryParams.internalValue = value;
  }
  public resetQueryParams() {
    this._queryParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors {
  /**
  * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#hostnames DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Matches define conditions used for matching the rule against incoming HTTP requests. https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#matches DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#matches}
  */
  readonly matches?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    matches: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesToTerraform, false)(struct!.matches),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesToHclTerraform, false)(struct!.matches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._matches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._matches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._matches.internalValue = value.matches;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // matches - computed: false, optional: true, required: false
  private _matches = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatchesList(this, "matches", false);
  public get matches() {
    return this._matches;
  }
  public putMatches(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsMatches[] | cdktf.IResolvable) {
    this._matches.internalValue = value;
  }
  public resetMatches() {
    this._matches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermissionToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermissionToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermissionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKindToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKindToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKindOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceNameToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceNameToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceNameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#kind DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#kind}
  */
  readonly kind?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kind: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKindToTerraform(struct!.kind),
    name: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceNameToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kind: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKindToHclTerraform(struct!.kind),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind",
    },
    name: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceNameToHclTerraform(struct!.name),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kind?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind?.internalValue;
    }
    if (this._name?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kind.internalValue = undefined;
      this._name.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kind.internalValue = value.kind;
      this._name.internalValue = value.name;
    }
  }

  // kind - computed: false, optional: true, required: false
  private _kind = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKindOutputReference(this, "kind");
  public get kind() {
    return this._kind;
  }
  public putKind(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceKind) {
    this._kind.internalValue = value;
  }
  public resetKind() {
    this._kind.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceNameOutputReference(this, "name");
  public get name() {
    return this._name;
  }
  public putName(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceName) {
    this._name.internalValue = value;
  }
  public resetName() {
    this._name.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * The name of the secret in the Authorino's namespace to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKindToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKindToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKindOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectNameToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectNameToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectNameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#kind DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#kind}
  */
  readonly kind?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kind: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKindToTerraform(struct!.kind),
    name: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectNameToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kind: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKindToHclTerraform(struct!.kind),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind",
    },
    name: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectNameToHclTerraform(struct!.name),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kind?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind?.internalValue;
    }
    if (this._name?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kind.internalValue = undefined;
      this._name.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kind.internalValue = value.kind;
      this._name.internalValue = value.name;
    }
  }

  // kind - computed: false, optional: true, required: false
  private _kind = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKindOutputReference(this, "kind");
  public get kind() {
    return this._kind;
  }
  public putKind(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectKind) {
    this._kind.internalValue = value;
  }
  public resetKind() {
    this._kind.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind.internalValue;
  }

  // name - computed: false, optional: true, required: false
  private _name = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectNameOutputReference(this, "name");
  public get name() {
    return this._name;
  }
  public putName(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectName) {
    this._name.internalValue = value;
  }
  public resetName() {
    this._name.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb {
  /**
  * Hostname and port number to the GRPC interface of the SpiceDB server (e.g. spicedb:50051).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#endpoint DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#endpoint}
  */
  readonly endpoint: string;
  /**
  * Insecure HTTP connection (i.e. disables TLS verification)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#insecure DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#insecure}
  */
  readonly insecure?: boolean | cdktf.IResolvable;
  /**
  * The name of the permission (or relation) on which to execute the check.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#permission DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#permission}
  */
  readonly permission?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission;
  /**
  * The resource on which to check the permission or relation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#resource DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#resource}
  */
  readonly resource?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource;
  /**
  * Reference to a Secret key whose value will be used by Authorino to authenticate with the Authzed service.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#shared_secret_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#shared_secret_ref}
  */
  readonly sharedSecretRef?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef;
  /**
  * The subject that will be checked for the permission or relation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#subject DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#subject}
  */
  readonly subject?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    insecure: cdktf.booleanToTerraform(struct!.insecure),
    permission: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermissionToTerraform(struct!.permission),
    resource: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceToTerraform(struct!.resource),
    shared_secret_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRefToTerraform(struct!.sharedSecretRef),
    subject: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectToTerraform(struct!.subject),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insecure: {
      value: cdktf.booleanToHclTerraform(struct!.insecure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    permission: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermissionToHclTerraform(struct!.permission),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission",
    },
    resource: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceToHclTerraform(struct!.resource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource",
    },
    shared_secret_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRefToHclTerraform(struct!.sharedSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef",
    },
    subject: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectToHclTerraform(struct!.subject),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._insecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecure = this._insecure;
    }
    if (this._permission?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.permission = this._permission?.internalValue;
    }
    if (this._resource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource?.internalValue;
    }
    if (this._sharedSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedSecretRef = this._sharedSecretRef?.internalValue;
    }
    if (this._subject?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subject = this._subject?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint = undefined;
      this._insecure = undefined;
      this._permission.internalValue = undefined;
      this._resource.internalValue = undefined;
      this._sharedSecretRef.internalValue = undefined;
      this._subject.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint = value.endpoint;
      this._insecure = value.insecure;
      this._permission.internalValue = value.permission;
      this._resource.internalValue = value.resource;
      this._sharedSecretRef.internalValue = value.sharedSecretRef;
      this._subject.internalValue = value.subject;
    }
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // insecure - computed: false, optional: true, required: false
  private _insecure?: boolean | cdktf.IResolvable; 
  public get insecure() {
    return this.getBooleanAttribute('insecure');
  }
  public set insecure(value: boolean | cdktf.IResolvable) {
    this._insecure = value;
  }
  public resetInsecure() {
    this._insecure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureInput() {
    return this._insecure;
  }

  // permission - computed: false, optional: true, required: false
  private _permission = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermissionOutputReference(this, "permission");
  public get permission() {
    return this._permission;
  }
  public putPermission(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbPermission) {
    this._permission.internalValue = value;
  }
  public resetPermission() {
    this._permission.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get permissionInput() {
    return this._permission.internalValue;
  }

  // resource - computed: false, optional: true, required: false
  private _resource = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResourceOutputReference(this, "resource");
  public get resource() {
    return this._resource;
  }
  public putResource(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbResource) {
    this._resource.internalValue = value;
  }
  public resetResource() {
    this._resource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource.internalValue;
  }

  // shared_secret_ref - computed: false, optional: true, required: false
  private _sharedSecretRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRefOutputReference(this, "shared_secret_ref");
  public get sharedSecretRef() {
    return this._sharedSecretRef;
  }
  public putSharedSecretRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSharedSecretRef) {
    this._sharedSecretRef.internalValue = value;
  }
  public resetSharedSecretRef() {
    this._sharedSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedSecretRefInput() {
    return this._sharedSecretRef.internalValue;
  }

  // subject - computed: false, optional: true, required: false
  private _subject = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubjectOutputReference(this, "subject");
  public get subject() {
    return this._subject;
  }
  public putSubject(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbSubject) {
    this._subject.internalValue = value;
  }
  public resetSubject() {
    this._subject.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectInput() {
    return this._subject.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorization {
  /**
  * Caching options for the resolved object returned when applying this config. Omit it to avoid caching objects for this config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache;
  /**
  * Authorization by Kubernetes SubjectAccessReview
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#kubernetes_subject_access_review DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#kubernetes_subject_access_review}
  */
  readonly kubernetesSubjectAccessReview?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview;
  /**
  * Whether this config should generate individual observability metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#metrics DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#metrics}
  */
  readonly metrics?: boolean | cdktf.IResolvable;
  /**
  * Open Policy Agent (OPA) Rego policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#opa DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#opa}
  */
  readonly opa?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa;
  /**
  * Pattern-matching authorization rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_matching DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_matching}
  */
  readonly patternMatching?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching;
  /**
  * Priority group of the config. All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#priority DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#priority}
  */
  readonly priority?: number;
  /**
  * Top-level route selectors. If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule. At least one selected HTTPRoute rule must match to trigger the auth rule. If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#route_selectors DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#route_selectors}
  */
  readonly routeSelectors?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors[] | cdktf.IResolvable;
  /**
  * Authorization decision delegated to external Authzed/SpiceDB server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#spicedb DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#spicedb}
  */
  readonly spicedb?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb;
  /**
  * Conditions for Authorino to enforce this config. If omitted, the config will be enforced for all requests. If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#when DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#when}
  */
  readonly when?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheToTerraform(struct!.cache),
    kubernetes_subject_access_review: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewToTerraform(struct!.kubernetesSubjectAccessReview),
    metrics: cdktf.booleanToTerraform(struct!.metrics),
    opa: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaToTerraform(struct!.opa),
    pattern_matching: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingToTerraform(struct!.patternMatching),
    priority: cdktf.numberToTerraform(struct!.priority),
    route_selectors: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsToTerraform, false)(struct!.routeSelectors),
    spicedb: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbToTerraform(struct!.spicedb),
    when: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenToTerraform, false)(struct!.when),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorization | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache",
    },
    kubernetes_subject_access_review: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewToHclTerraform(struct!.kubernetesSubjectAccessReview),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview",
    },
    metrics: {
      value: cdktf.booleanToHclTerraform(struct!.metrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    opa: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaToHclTerraform(struct!.opa),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa",
    },
    pattern_matching: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingToHclTerraform(struct!.patternMatching),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    route_selectors: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsToHclTerraform, false)(struct!.routeSelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsList",
    },
    spicedb: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbToHclTerraform(struct!.spicedb),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb",
    },
    when: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenToHclTerraform, false)(struct!.when),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorization | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._kubernetesSubjectAccessReview?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesSubjectAccessReview = this._kubernetesSubjectAccessReview?.internalValue;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._opa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.opa = this._opa?.internalValue;
    }
    if (this._patternMatching?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternMatching = this._patternMatching?.internalValue;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._routeSelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSelectors = this._routeSelectors?.internalValue;
    }
    if (this._spicedb?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spicedb = this._spicedb?.internalValue;
    }
    if (this._when?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.when = this._when?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorization | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._kubernetesSubjectAccessReview.internalValue = undefined;
      this._metrics = undefined;
      this._opa.internalValue = undefined;
      this._patternMatching.internalValue = undefined;
      this._priority = undefined;
      this._routeSelectors.internalValue = undefined;
      this._spicedb.internalValue = undefined;
      this._when.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._kubernetesSubjectAccessReview.internalValue = value.kubernetesSubjectAccessReview;
      this._metrics = value.metrics;
      this._opa.internalValue = value.opa;
      this._patternMatching.internalValue = value.patternMatching;
      this._priority = value.priority;
      this._routeSelectors.internalValue = value.routeSelectors;
      this._spicedb.internalValue = value.spicedb;
      this._when.internalValue = value.when;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // kubernetes_subject_access_review - computed: false, optional: true, required: false
  private _kubernetesSubjectAccessReview = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReviewOutputReference(this, "kubernetes_subject_access_review");
  public get kubernetesSubjectAccessReview() {
    return this._kubernetesSubjectAccessReview;
  }
  public putKubernetesSubjectAccessReview(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationKubernetesSubjectAccessReview) {
    this._kubernetesSubjectAccessReview.internalValue = value;
  }
  public resetKubernetesSubjectAccessReview() {
    this._kubernetesSubjectAccessReview.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesSubjectAccessReviewInput() {
    return this._kubernetesSubjectAccessReview.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: boolean | cdktf.IResolvable; 
  public get metrics() {
    return this.getBooleanAttribute('metrics');
  }
  public set metrics(value: boolean | cdktf.IResolvable) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // opa - computed: false, optional: true, required: false
  private _opa = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpaOutputReference(this, "opa");
  public get opa() {
    return this._opa;
  }
  public putOpa(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationOpa) {
    this._opa.internalValue = value;
  }
  public resetOpa() {
    this._opa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get opaInput() {
    return this._opa.internalValue;
  }

  // pattern_matching - computed: false, optional: true, required: false
  private _patternMatching = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatchingOutputReference(this, "pattern_matching");
  public get patternMatching() {
    return this._patternMatching;
  }
  public putPatternMatching(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationPatternMatching) {
    this._patternMatching.internalValue = value;
  }
  public resetPatternMatching() {
    this._patternMatching.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternMatchingInput() {
    return this._patternMatching.internalValue;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // route_selectors - computed: false, optional: true, required: false
  private _routeSelectors = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectorsList(this, "route_selectors", false);
  public get routeSelectors() {
    return this._routeSelectors;
  }
  public putRouteSelectors(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationRouteSelectors[] | cdktf.IResolvable) {
    this._routeSelectors.internalValue = value;
  }
  public resetRouteSelectors() {
    this._routeSelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSelectorsInput() {
    return this._routeSelectors.internalValue;
  }

  // spicedb - computed: false, optional: true, required: false
  private _spicedb = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedbOutputReference(this, "spicedb");
  public get spicedb() {
    return this._spicedb;
  }
  public putSpicedb(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationSpicedb) {
    this._spicedb.internalValue = value;
  }
  public resetSpicedb() {
    this._spicedb.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spicedbInput() {
    return this._spicedb.internalValue;
  }

  // when - computed: false, optional: true, required: false
  private _when = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhenList(this, "when", false);
  public get when() {
    return this._when;
  }
  public putWhen(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesAuthorizationWhen[] | cdktf.IResolvable) {
    this._when.internalValue = value;
  }
  public resetWhen() {
    this._when.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenInput() {
    return this._when.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKeyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKeyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache {
  /**
  * Key used to store the entry in the cache. The resolved key must be unique within the scope of this particular config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey;
  /**
  * Duration (in seconds) of the external data in the cache before pulled again from the source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKeyToTerraform(struct!.key),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKeyToHclTerraform(struct!.key),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key?.internalValue;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key.internalValue = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key.internalValue = value.key;
      this._ttl = value.ttl;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKeyOutputReference(this, "key");
  public get key() {
    return this._key;
  }
  public putKey(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheKey) {
    this._key.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key.internalValue;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParametersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParametersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#prefix DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._prefix = value.prefix;
    }
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookieToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookieToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryStringToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryStringToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryStringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#authorization_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#authorization_header}
  */
  readonly authorizationHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cookie DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cookie}
  */
  readonly cookie?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#custom_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#custom_header}
  */
  readonly customHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_string DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_string}
  */
  readonly queryString?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authorization_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeaderToTerraform(struct!.authorizationHeader),
    cookie: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookieToTerraform(struct!.cookie),
    custom_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeaderToTerraform(struct!.customHeader),
    query_string: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryStringToTerraform(struct!.queryString),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authorization_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeaderToHclTerraform(struct!.authorizationHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader",
    },
    cookie: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie",
    },
    custom_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeaderToHclTerraform(struct!.customHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader",
    },
    query_string: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryStringToHclTerraform(struct!.queryString),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorizationHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationHeader = this._authorizationHeader?.internalValue;
    }
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    if (this._customHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHeader = this._customHeader?.internalValue;
    }
    if (this._queryString?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryString = this._queryString?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = undefined;
      this._cookie.internalValue = undefined;
      this._customHeader.internalValue = undefined;
      this._queryString.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = value.authorizationHeader;
      this._cookie.internalValue = value.cookie;
      this._customHeader.internalValue = value.customHeader;
      this._queryString.internalValue = value.queryString;
    }
  }

  // authorization_header - computed: false, optional: true, required: false
  private _authorizationHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeaderOutputReference(this, "authorization_header");
  public get authorizationHeader() {
    return this._authorizationHeader;
  }
  public putAuthorizationHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsAuthorizationHeader) {
    this._authorizationHeader.internalValue = value;
  }
  public resetAuthorizationHeader() {
    this._authorizationHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationHeaderInput() {
    return this._authorizationHeader.internalValue;
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }

  // custom_header - computed: false, optional: true, required: false
  private _customHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeaderOutputReference(this, "custom_header");
  public get customHeader() {
    return this._customHeader;
  }
  public putCustomHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsCustomHeader) {
    this._customHeader.internalValue = value;
  }
  public resetCustomHeader() {
    this._customHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHeaderInput() {
    return this._customHeader.internalValue;
  }

  // query_string - computed: false, optional: true, required: false
  private _queryString = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryStringOutputReference(this, "query_string");
  public get queryString() {
    return this._queryString;
  }
  public putQueryString(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsQueryString) {
    this._queryString.internalValue = value;
  }
  public resetQueryString() {
    this._queryString.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryStringInput() {
    return this._queryString.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * The name of the secret in the Authorino's namespace to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2 {
  /**
  * Caches and reuses the token until expired. Set it to false to force fetch the token at every authorization request regardless of expiration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: boolean | cdktf.IResolvable;
  /**
  * OAuth2 Client ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#client_id DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#client_id}
  */
  readonly clientId: string;
  /**
  * Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#client_secret_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#client_secret_ref}
  */
  readonly clientSecretRef: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef;
  /**
  * Optional extra parameters for the requests to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#extra_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#extra_params}
  */
  readonly extraParams?: { [key: string]: string };
  /**
  * Optional scopes for the client credentials grant, if supported by he OAuth2 server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#scopes DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#scopes}
  */
  readonly scopes?: string[];
  /**
  * Token endpoint URL of the OAuth2 resource server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#token_url DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#token_url}
  */
  readonly tokenUrl: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: cdktf.booleanToTerraform(struct!.cache),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRefToTerraform(struct!.clientSecretRef),
    extra_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: cdktf.booleanToHclTerraform(struct!.cache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRefToHclTerraform(struct!.clientSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef",
    },
    extra_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecretRef = this._clientSecretRef?.internalValue;
    }
    if (this._extraParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraParams = this._extraParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache = undefined;
      this._clientId = undefined;
      this._clientSecretRef.internalValue = undefined;
      this._extraParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache = value.cache;
      this._clientId = value.clientId;
      this._clientSecretRef.internalValue = value.clientSecretRef;
      this._extraParams = value.extraParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache?: boolean | cdktf.IResolvable; 
  public get cache() {
    return this.getBooleanAttribute('cache');
  }
  public set cache(value: boolean | cdktf.IResolvable) {
    this._cache = value;
  }
  public resetCache() {
    this._cache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret_ref - computed: false, optional: false, required: true
  private _clientSecretRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRefOutputReference(this, "client_secret_ref");
  public get clientSecretRef() {
    return this._clientSecretRef;
  }
  public putClientSecretRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ClientSecretRef) {
    this._clientSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretRefInput() {
    return this._clientSecretRef.internalValue;
  }

  // extra_params - computed: false, optional: true, required: false
  private _extraParams?: { [key: string]: string }; 
  public get extraParams() {
    return this.getStringMapAttribute('extra_params');
  }
  public set extraParams(value: { [key: string]: string }) {
    this._extraParams = value;
  }
  public resetExtraParams() {
    this._extraParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraParamsInput() {
    return this._extraParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: false, required: true
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * The name of the secret in the Authorino's namespace to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp {
  /**
  * Raw body of the HTTP request. Supersedes 'bodyParameters'; use either one or the other. Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body}
  */
  readonly body?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody;
  /**
  * Custom parameters to encode in the body of the HTTP request. Superseded by 'body'; use either one or the other. Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body_parameters DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body_parameters}
  */
  readonly bodyParameters?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters;
  /**
  * Content-Type of the request body. Shapes how 'bodyParameters' are encoded. Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#content_type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#content_type}
  */
  readonly contentType?: string;
  /**
  * Defines where client credentials will be passed in the request to the service. If omitted, it defaults to client credentials passed in the HTTP Authorization header and the 'Bearer' prefix expected prepended to the secret value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#credentials DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#credentials}
  */
  readonly credentials?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials;
  /**
  * Custom headers in the HTTP request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders;
  /**
  * HTTP verb used in the request to the service. Accepted values: GET (default), POST. When the request method is POST, the authorization JSON is passed in the body of the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Authentication with the HTTP service by OAuth2 Client Credentials grant.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#oauth2 DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#oauth2}
  */
  readonly oauth2?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2;
  /**
  * Reference to a Secret key whose value will be passed by Authorino in the request. The HTTP service can use the shared secret to authenticate the origin of the request. Ignored if used together with oauth2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#shared_secret_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#shared_secret_ref}
  */
  readonly sharedSecretRef?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef;
  /**
  * Endpoint URL of the HTTP service. The value can include variable placeholders in the format '{selector}', where 'selector' is any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON. E.g. https://ext-auth-server.io/metadata?p={request.path}
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#url DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyToTerraform(struct!.body),
    body_parameters: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParametersToTerraform(struct!.bodyParameters),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    credentials: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsToTerraform(struct!.credentials),
    headers: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeadersToTerraform(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    oauth2: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ToTerraform(struct!.oauth2),
    shared_secret_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRefToTerraform(struct!.sharedSecretRef),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody",
    },
    body_parameters: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParametersToHclTerraform(struct!.bodyParameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials",
    },
    headers: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth2: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2",
    },
    shared_secret_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRefToHclTerraform(struct!.sharedSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._bodyParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bodyParameters = this._bodyParameters?.internalValue;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._sharedSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedSecretRef = this._sharedSecretRef?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body.internalValue = undefined;
      this._bodyParameters.internalValue = undefined;
      this._contentType = undefined;
      this._credentials.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._oauth2.internalValue = undefined;
      this._sharedSecretRef.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body.internalValue = value.body;
      this._bodyParameters.internalValue = value.bodyParameters;
      this._contentType = value.contentType;
      this._credentials.internalValue = value.credentials;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._oauth2.internalValue = value.oauth2;
      this._sharedSecretRef.internalValue = value.sharedSecretRef;
      this._url = value.url;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // body_parameters - computed: false, optional: true, required: false
  private _bodyParameters = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParametersOutputReference(this, "body_parameters");
  public get bodyParameters() {
    return this._bodyParameters;
  }
  public putBodyParameters(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpBodyParameters) {
    this._bodyParameters.internalValue = value;
  }
  public resetBodyParameters() {
    this._bodyParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyParametersInput() {
    return this._bodyParameters.internalValue;
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // shared_secret_ref - computed: false, optional: true, required: false
  private _sharedSecretRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRefOutputReference(this, "shared_secret_ref");
  public get sharedSecretRef() {
    return this._sharedSecretRef;
  }
  public putSharedSecretRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpSharedSecretRef) {
    this._sharedSecretRef.internalValue = value;
  }
  public resetSharedSecretRef() {
    this._sharedSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedSecretRefInput() {
    return this._sharedSecretRef.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders {
  /**
  * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, 'foo' and 'Foo' are considered equivalent. When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for 'Set-Cookie'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the header. Support: Core (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP Header to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath {
  /**
  * Type specifies how to match against the path Value. Support: Core (Exact, PathPrefix) Support: Implementation-specific (RegularExpression)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value of the HTTP path to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPathToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPathToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams {
  /**
  * Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3). If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored. If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API. Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the query parameter. Support: Extended (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP query param to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches {
  /**
  * Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders[] | cdktf.IResolvable;
  /**
  * Method specifies HTTP method matcher. When specified, this route will be matched only if the request has the specified method. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the '/' path is provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#path DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#path}
  */
  readonly path?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath;
  /**
  * QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_params}
  */
  readonly queryParams?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersToTerraform, false)(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    path: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPathToTerraform(struct!.path),
    query_params: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersList",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPathToHclTerraform(struct!.path),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath",
    },
    query_params: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsToHclTerraform, false)(struct!.queryParams),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    if (this._queryParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._path.internalValue = undefined;
      this._queryParams.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._path.internalValue = value.path;
      this._queryParams.internalValue = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPathOutputReference(this, "path");
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesPath) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParamsList(this, "query_params", false);
  public get queryParams() {
    return this._queryParams;
  }
  public putQueryParams(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable) {
    this._queryParams.internalValue = value;
  }
  public resetQueryParams() {
    this._queryParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors {
  /**
  * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#hostnames DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Matches define conditions used for matching the rule against incoming HTTP requests. https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#matches DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#matches}
  */
  readonly matches?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    matches: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesToTerraform, false)(struct!.matches),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesToHclTerraform, false)(struct!.matches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._matches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._matches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._matches.internalValue = value.matches;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // matches - computed: false, optional: true, required: false
  private _matches = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatchesList(this, "matches", false);
  public get matches() {
    return this._matches;
  }
  public putMatches(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsMatches[] | cdktf.IResolvable) {
    this._matches.internalValue = value;
  }
  public resetMatches() {
    this._matches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacks {
  /**
  * Caching options for the resolved object returned when applying this config. Omit it to avoid caching objects for this config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache;
  /**
  * Settings of the external HTTP request
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#http DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#http}
  */
  readonly http: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp;
  /**
  * Whether this config should generate individual observability metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#metrics DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#metrics}
  */
  readonly metrics?: boolean | cdktf.IResolvable;
  /**
  * Priority group of the config. All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#priority DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#priority}
  */
  readonly priority?: number;
  /**
  * Top-level route selectors. If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule. At least one selected HTTPRoute rule must match to trigger the auth rule. If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#route_selectors DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#route_selectors}
  */
  readonly routeSelectors?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors[] | cdktf.IResolvable;
  /**
  * Conditions for Authorino to enforce this config. If omitted, the config will be enforced for all requests. If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#when DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#when}
  */
  readonly when?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheToTerraform(struct!.cache),
    http: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpToTerraform(struct!.http),
    metrics: cdktf.booleanToTerraform(struct!.metrics),
    priority: cdktf.numberToTerraform(struct!.priority),
    route_selectors: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsToTerraform, false)(struct!.routeSelectors),
    when: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenToTerraform, false)(struct!.when),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache",
    },
    http: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpToHclTerraform(struct!.http),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp",
    },
    metrics: {
      value: cdktf.booleanToHclTerraform(struct!.metrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    route_selectors: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsToHclTerraform, false)(struct!.routeSelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsList",
    },
    when: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenToHclTerraform, false)(struct!.when),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._http?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http = this._http?.internalValue;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._routeSelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSelectors = this._routeSelectors?.internalValue;
    }
    if (this._when?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.when = this._when?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._http.internalValue = undefined;
      this._metrics = undefined;
      this._priority = undefined;
      this._routeSelectors.internalValue = undefined;
      this._when.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._http.internalValue = value.http;
      this._metrics = value.metrics;
      this._priority = value.priority;
      this._routeSelectors.internalValue = value.routeSelectors;
      this._when.internalValue = value.when;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // http - computed: false, optional: false, required: true
  private _http = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttpOutputReference(this, "http");
  public get http() {
    return this._http;
  }
  public putHttp(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksHttp) {
    this._http.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpInput() {
    return this._http.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: boolean | cdktf.IResolvable; 
  public get metrics() {
    return this.getBooleanAttribute('metrics');
  }
  public set metrics(value: boolean | cdktf.IResolvable) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // route_selectors - computed: false, optional: true, required: false
  private _routeSelectors = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectorsList(this, "route_selectors", false);
  public get routeSelectors() {
    return this._routeSelectors;
  }
  public putRouteSelectors(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksRouteSelectors[] | cdktf.IResolvable) {
    this._routeSelectors.internalValue = value;
  }
  public resetRouteSelectors() {
    this._routeSelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSelectorsInput() {
    return this._routeSelectors.internalValue;
  }

  // when - computed: false, optional: true, required: false
  private _when = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhenList(this, "when", false);
  public get when() {
    return this._when;
  }
  public putWhen(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesCallbacksWhen[] | cdktf.IResolvable) {
    this._when.internalValue = value;
  }
  public resetWhen() {
    this._when.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenInput() {
    return this._when.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKeyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKeyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache {
  /**
  * Key used to store the entry in the cache. The resolved key must be unique within the scope of this particular config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey;
  /**
  * Duration (in seconds) of the external data in the cache before pulled again from the source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKeyToTerraform(struct!.key),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKeyToHclTerraform(struct!.key),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key?.internalValue;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key.internalValue = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key.internalValue = value.key;
      this._ttl = value.ttl;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKeyOutputReference(this, "key");
  public get key() {
    return this._key;
  }
  public putKey(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheKey) {
    this._key.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key.internalValue;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParametersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParametersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#prefix DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._prefix = value.prefix;
    }
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookieToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookieToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeaderToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeaderToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryStringToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryStringToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryStringOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#authorization_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#authorization_header}
  */
  readonly authorizationHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cookie DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cookie}
  */
  readonly cookie?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#custom_header DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#custom_header}
  */
  readonly customHeader?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_string DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_string}
  */
  readonly queryString?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authorization_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeaderToTerraform(struct!.authorizationHeader),
    cookie: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookieToTerraform(struct!.cookie),
    custom_header: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeaderToTerraform(struct!.customHeader),
    query_string: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryStringToTerraform(struct!.queryString),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authorization_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeaderToHclTerraform(struct!.authorizationHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader",
    },
    cookie: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie",
    },
    custom_header: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeaderToHclTerraform(struct!.customHeader),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader",
    },
    query_string: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryStringToHclTerraform(struct!.queryString),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authorizationHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizationHeader = this._authorizationHeader?.internalValue;
    }
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    if (this._customHeader?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customHeader = this._customHeader?.internalValue;
    }
    if (this._queryString?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryString = this._queryString?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = undefined;
      this._cookie.internalValue = undefined;
      this._customHeader.internalValue = undefined;
      this._queryString.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authorizationHeader.internalValue = value.authorizationHeader;
      this._cookie.internalValue = value.cookie;
      this._customHeader.internalValue = value.customHeader;
      this._queryString.internalValue = value.queryString;
    }
  }

  // authorization_header - computed: false, optional: true, required: false
  private _authorizationHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeaderOutputReference(this, "authorization_header");
  public get authorizationHeader() {
    return this._authorizationHeader;
  }
  public putAuthorizationHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsAuthorizationHeader) {
    this._authorizationHeader.internalValue = value;
  }
  public resetAuthorizationHeader() {
    this._authorizationHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizationHeaderInput() {
    return this._authorizationHeader.internalValue;
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }

  // custom_header - computed: false, optional: true, required: false
  private _customHeader = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeaderOutputReference(this, "custom_header");
  public get customHeader() {
    return this._customHeader;
  }
  public putCustomHeader(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsCustomHeader) {
    this._customHeader.internalValue = value;
  }
  public resetCustomHeader() {
    this._customHeader.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customHeaderInput() {
    return this._customHeader.internalValue;
  }

  // query_string - computed: false, optional: true, required: false
  private _queryString = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryStringOutputReference(this, "query_string");
  public get queryString() {
    return this._queryString;
  }
  public putQueryString(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsQueryString) {
    this._queryString.internalValue = value;
  }
  public resetQueryString() {
    this._queryString.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryStringInput() {
    return this._queryString.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * The name of the secret in the Authorino's namespace to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2 {
  /**
  * Caches and reuses the token until expired. Set it to false to force fetch the token at every authorization request regardless of expiration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: boolean | cdktf.IResolvable;
  /**
  * OAuth2 Client ID.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#client_id DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#client_id}
  */
  readonly clientId: string;
  /**
  * Reference to a Kuberentes Secret key that stores that OAuth2 Client Secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#client_secret_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#client_secret_ref}
  */
  readonly clientSecretRef: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef;
  /**
  * Optional extra parameters for the requests to the token URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#extra_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#extra_params}
  */
  readonly extraParams?: { [key: string]: string };
  /**
  * Optional scopes for the client credentials grant, if supported by he OAuth2 server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#scopes DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#scopes}
  */
  readonly scopes?: string[];
  /**
  * Token endpoint URL of the OAuth2 resource server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#token_url DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#token_url}
  */
  readonly tokenUrl: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: cdktf.booleanToTerraform(struct!.cache),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRefToTerraform(struct!.clientSecretRef),
    extra_params: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.extraParams),
    scopes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.scopes),
    token_url: cdktf.stringToTerraform(struct!.tokenUrl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: cdktf.booleanToHclTerraform(struct!.cache),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRefToHclTerraform(struct!.clientSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef",
    },
    extra_params: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.extraParams),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    scopes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.scopes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    token_url: {
      value: cdktf.stringToHclTerraform(struct!.tokenUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecretRef = this._clientSecretRef?.internalValue;
    }
    if (this._extraParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraParams = this._extraParams;
    }
    if (this._scopes !== undefined) {
      hasAnyValues = true;
      internalValueResult.scopes = this._scopes;
    }
    if (this._tokenUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenUrl = this._tokenUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache = undefined;
      this._clientId = undefined;
      this._clientSecretRef.internalValue = undefined;
      this._extraParams = undefined;
      this._scopes = undefined;
      this._tokenUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache = value.cache;
      this._clientId = value.clientId;
      this._clientSecretRef.internalValue = value.clientSecretRef;
      this._extraParams = value.extraParams;
      this._scopes = value.scopes;
      this._tokenUrl = value.tokenUrl;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache?: boolean | cdktf.IResolvable; 
  public get cache() {
    return this.getBooleanAttribute('cache');
  }
  public set cache(value: boolean | cdktf.IResolvable) {
    this._cache = value;
  }
  public resetCache() {
    this._cache = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret_ref - computed: false, optional: false, required: true
  private _clientSecretRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRefOutputReference(this, "client_secret_ref");
  public get clientSecretRef() {
    return this._clientSecretRef;
  }
  public putClientSecretRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ClientSecretRef) {
    this._clientSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretRefInput() {
    return this._clientSecretRef.internalValue;
  }

  // extra_params - computed: false, optional: true, required: false
  private _extraParams?: { [key: string]: string }; 
  public get extraParams() {
    return this.getStringMapAttribute('extra_params');
  }
  public set extraParams(value: { [key: string]: string }) {
    this._extraParams = value;
  }
  public resetExtraParams() {
    this._extraParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraParamsInput() {
    return this._extraParams;
  }

  // scopes - computed: false, optional: true, required: false
  private _scopes?: string[]; 
  public get scopes() {
    return this.getListAttribute('scopes');
  }
  public set scopes(value: string[]) {
    this._scopes = value;
  }
  public resetScopes() {
    this._scopes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopesInput() {
    return this._scopes;
  }

  // token_url - computed: false, optional: false, required: true
  private _tokenUrl?: string; 
  public get tokenUrl() {
    return this.getStringAttribute('token_url');
  }
  public set tokenUrl(value: string) {
    this._tokenUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenUrlInput() {
    return this._tokenUrl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: string;
  /**
  * The name of the secret in the Authorino's namespace to select from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp {
  /**
  * Raw body of the HTTP request. Supersedes 'bodyParameters'; use either one or the other. Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body}
  */
  readonly body?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody;
  /**
  * Custom parameters to encode in the body of the HTTP request. Superseded by 'body'; use either one or the other. Use it with method=POST; for GET requests, set parameters as query string in the 'endpoint' (placeholders can be used).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body_parameters DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body_parameters}
  */
  readonly bodyParameters?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters;
  /**
  * Content-Type of the request body. Shapes how 'bodyParameters' are encoded. Use it with method=POST; for GET requests, Content-Type is automatically set to 'text/plain'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#content_type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#content_type}
  */
  readonly contentType?: string;
  /**
  * Defines where client credentials will be passed in the request to the service. If omitted, it defaults to client credentials passed in the HTTP Authorization header and the 'Bearer' prefix expected prepended to the secret value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#credentials DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#credentials}
  */
  readonly credentials?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials;
  /**
  * Custom headers in the HTTP request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders;
  /**
  * HTTP verb used in the request to the service. Accepted values: GET (default), POST. When the request method is POST, the authorization JSON is passed in the body of the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Authentication with the HTTP service by OAuth2 Client Credentials grant.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#oauth2 DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#oauth2}
  */
  readonly oauth2?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2;
  /**
  * Reference to a Secret key whose value will be passed by Authorino in the request. The HTTP service can use the shared secret to authenticate the origin of the request. Ignored if used together with oauth2.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#shared_secret_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#shared_secret_ref}
  */
  readonly sharedSecretRef?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef;
  /**
  * Endpoint URL of the HTTP service. The value can include variable placeholders in the format '{selector}', where 'selector' is any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson and selects value from the authorization JSON. E.g. https://ext-auth-server.io/metadata?p={request.path}
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#url DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#url}
  */
  readonly url: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyToTerraform(struct!.body),
    body_parameters: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParametersToTerraform(struct!.bodyParameters),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    credentials: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsToTerraform(struct!.credentials),
    headers: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeadersToTerraform(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    oauth2: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ToTerraform(struct!.oauth2),
    shared_secret_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRefToTerraform(struct!.sharedSecretRef),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody",
    },
    body_parameters: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParametersToHclTerraform(struct!.bodyParameters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials",
    },
    headers: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth2: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2ToHclTerraform(struct!.oauth2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2",
    },
    shared_secret_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRefToHclTerraform(struct!.sharedSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._bodyParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bodyParameters = this._bodyParameters?.internalValue;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._oauth2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauth2 = this._oauth2?.internalValue;
    }
    if (this._sharedSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sharedSecretRef = this._sharedSecretRef?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body.internalValue = undefined;
      this._bodyParameters.internalValue = undefined;
      this._contentType = undefined;
      this._credentials.internalValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._oauth2.internalValue = undefined;
      this._sharedSecretRef.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body.internalValue = value.body;
      this._bodyParameters.internalValue = value.bodyParameters;
      this._contentType = value.contentType;
      this._credentials.internalValue = value.credentials;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._oauth2.internalValue = value.oauth2;
      this._sharedSecretRef.internalValue = value.sharedSecretRef;
      this._url = value.url;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // body_parameters - computed: false, optional: true, required: false
  private _bodyParameters = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParametersOutputReference(this, "body_parameters");
  public get bodyParameters() {
    return this._bodyParameters;
  }
  public putBodyParameters(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpBodyParameters) {
    this._bodyParameters.internalValue = value;
  }
  public resetBodyParameters() {
    this._bodyParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyParametersInput() {
    return this._bodyParameters.internalValue;
  }

  // content_type - computed: false, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // oauth2 - computed: false, optional: true, required: false
  private _oauth2 = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2OutputReference(this, "oauth2");
  public get oauth2() {
    return this._oauth2;
  }
  public putOauth2(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOauth2) {
    this._oauth2.internalValue = value;
  }
  public resetOauth2() {
    this._oauth2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauth2Input() {
    return this._oauth2.internalValue;
  }

  // shared_secret_ref - computed: false, optional: true, required: false
  private _sharedSecretRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRefOutputReference(this, "shared_secret_ref");
  public get sharedSecretRef() {
    return this._sharedSecretRef;
  }
  public putSharedSecretRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpSharedSecretRef) {
    this._sharedSecretRef.internalValue = value;
  }
  public resetSharedSecretRef() {
    this._sharedSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedSecretRefInput() {
    return this._sharedSecretRef.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders {
  /**
  * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, 'foo' and 'Foo' are considered equivalent. When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for 'Set-Cookie'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the header. Support: Core (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP Header to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath {
  /**
  * Type specifies how to match against the path Value. Support: Core (Exact, PathPrefix) Support: Implementation-specific (RegularExpression)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value of the HTTP path to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPathToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPathToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams {
  /**
  * Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3). If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored. If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API. Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the query parameter. Support: Extended (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP query param to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches {
  /**
  * Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders[] | cdktf.IResolvable;
  /**
  * Method specifies HTTP method matcher. When specified, this route will be matched only if the request has the specified method. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the '/' path is provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#path DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#path}
  */
  readonly path?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath;
  /**
  * QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_params}
  */
  readonly queryParams?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersToTerraform, false)(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    path: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPathToTerraform(struct!.path),
    query_params: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersList",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPathToHclTerraform(struct!.path),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath",
    },
    query_params: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsToHclTerraform, false)(struct!.queryParams),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    if (this._queryParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._path.internalValue = undefined;
      this._queryParams.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._path.internalValue = value.path;
      this._queryParams.internalValue = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPathOutputReference(this, "path");
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesPath) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParamsList(this, "query_params", false);
  public get queryParams() {
    return this._queryParams;
  }
  public putQueryParams(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable) {
    this._queryParams.internalValue = value;
  }
  public resetQueryParams() {
    this._queryParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors {
  /**
  * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#hostnames DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Matches define conditions used for matching the rule against incoming HTTP requests. https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#matches DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#matches}
  */
  readonly matches?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    matches: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesToTerraform, false)(struct!.matches),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesToHclTerraform, false)(struct!.matches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._matches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._matches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._matches.internalValue = value.matches;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // matches - computed: false, optional: true, required: false
  private _matches = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatchesList(this, "matches", false);
  public get matches() {
    return this._matches;
  }
  public putMatches(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsMatches[] | cdktf.IResolvable) {
    this._matches.internalValue = value;
  }
  public resetMatches() {
    this._matches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRefToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRefToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma {
  /**
  * Reference to a Kubernetes secret in the same namespace, that stores client credentials to the resource registration API of the UMA server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#credentials_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#credentials_ref}
  */
  readonly credentialsRef: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef;
  /**
  * The endpoint of the UMA server. The value must coincide with the 'issuer' claim of the UMA config discovered from the well-known uma configuration endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#endpoint DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#endpoint}
  */
  readonly endpoint: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_ref: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRefToTerraform(struct!.credentialsRef),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_ref: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRefToHclTerraform(struct!.credentialsRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsRef = this._credentialsRef?.internalValue;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsRef.internalValue = undefined;
      this._endpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsRef.internalValue = value.credentialsRef;
      this._endpoint = value.endpoint;
    }
  }

  // credentials_ref - computed: false, optional: false, required: true
  private _credentialsRef = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRefOutputReference(this, "credentials_ref");
  public get credentialsRef() {
    return this._credentialsRef;
  }
  public putCredentialsRef(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaCredentialsRef) {
    this._credentialsRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsRefInput() {
    return this._credentialsRef.internalValue;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo {
  /**
  * The name of an OIDC-enabled JWT authentication config whose OpenID Connect configuration discovered includes the OIDC 'userinfo_endpoint' claim.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#identity_source DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#identity_source}
  */
  readonly identitySource: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfoToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    identity_source: cdktf.stringToTerraform(struct!.identitySource),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfoToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    identity_source: {
      value: cdktf.stringToHclTerraform(struct!.identitySource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfoOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._identitySource !== undefined) {
      hasAnyValues = true;
      internalValueResult.identitySource = this._identitySource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._identitySource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._identitySource = value.identitySource;
    }
  }

  // identity_source - computed: false, optional: false, required: true
  private _identitySource?: string; 
  public get identitySource() {
    return this.getStringAttribute('identity_source');
  }
  public set identitySource(value: string) {
    this._identitySource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get identitySourceInput() {
    return this._identitySource;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadata {
  /**
  * Caching options for the resolved object returned when applying this config. Omit it to avoid caching objects for this config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache;
  /**
  * External source of auth metadata via HTTP request
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#http DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#http}
  */
  readonly http?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp;
  /**
  * Whether this config should generate individual observability metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#metrics DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#metrics}
  */
  readonly metrics?: boolean | cdktf.IResolvable;
  /**
  * Priority group of the config. All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#priority DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#priority}
  */
  readonly priority?: number;
  /**
  * Top-level route selectors. If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule. At least one selected HTTPRoute rule must match to trigger the auth rule. If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#route_selectors DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#route_selectors}
  */
  readonly routeSelectors?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors[] | cdktf.IResolvable;
  /**
  * User-Managed Access (UMA) source of resource data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#uma DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#uma}
  */
  readonly uma?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma;
  /**
  * OpendID Connect UserInfo linked to an OIDC authentication config specified in this same AuthConfig.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#user_info DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#user_info}
  */
  readonly userInfo?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo;
  /**
  * Conditions for Authorino to enforce this config. If omitted, the config will be enforced for all requests. If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#when DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#when}
  */
  readonly when?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheToTerraform(struct!.cache),
    http: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpToTerraform(struct!.http),
    metrics: cdktf.booleanToTerraform(struct!.metrics),
    priority: cdktf.numberToTerraform(struct!.priority),
    route_selectors: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsToTerraform, false)(struct!.routeSelectors),
    uma: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaToTerraform(struct!.uma),
    user_info: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfoToTerraform(struct!.userInfo),
    when: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenToTerraform, false)(struct!.when),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache",
    },
    http: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpToHclTerraform(struct!.http),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp",
    },
    metrics: {
      value: cdktf.booleanToHclTerraform(struct!.metrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    route_selectors: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsToHclTerraform, false)(struct!.routeSelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsList",
    },
    uma: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaToHclTerraform(struct!.uma),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma",
    },
    user_info: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfoToHclTerraform(struct!.userInfo),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo",
    },
    when: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenToHclTerraform, false)(struct!.when),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._http?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.http = this._http?.internalValue;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._routeSelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSelectors = this._routeSelectors?.internalValue;
    }
    if (this._uma?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.uma = this._uma?.internalValue;
    }
    if (this._userInfo?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.userInfo = this._userInfo?.internalValue;
    }
    if (this._when?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.when = this._when?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._http.internalValue = undefined;
      this._metrics = undefined;
      this._priority = undefined;
      this._routeSelectors.internalValue = undefined;
      this._uma.internalValue = undefined;
      this._userInfo.internalValue = undefined;
      this._when.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._http.internalValue = value.http;
      this._metrics = value.metrics;
      this._priority = value.priority;
      this._routeSelectors.internalValue = value.routeSelectors;
      this._uma.internalValue = value.uma;
      this._userInfo.internalValue = value.userInfo;
      this._when.internalValue = value.when;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // http - computed: false, optional: true, required: false
  private _http = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttpOutputReference(this, "http");
  public get http() {
    return this._http;
  }
  public putHttp(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataHttp) {
    this._http.internalValue = value;
  }
  public resetHttp() {
    this._http.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpInput() {
    return this._http.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: boolean | cdktf.IResolvable; 
  public get metrics() {
    return this.getBooleanAttribute('metrics');
  }
  public set metrics(value: boolean | cdktf.IResolvable) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // route_selectors - computed: false, optional: true, required: false
  private _routeSelectors = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectorsList(this, "route_selectors", false);
  public get routeSelectors() {
    return this._routeSelectors;
  }
  public putRouteSelectors(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataRouteSelectors[] | cdktf.IResolvable) {
    this._routeSelectors.internalValue = value;
  }
  public resetRouteSelectors() {
    this._routeSelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSelectorsInput() {
    return this._routeSelectors.internalValue;
  }

  // uma - computed: false, optional: true, required: false
  private _uma = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUmaOutputReference(this, "uma");
  public get uma() {
    return this._uma;
  }
  public putUma(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUma) {
    this._uma.internalValue = value;
  }
  public resetUma() {
    this._uma.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get umaInput() {
    return this._uma.internalValue;
  }

  // user_info - computed: false, optional: true, required: false
  private _userInfo = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfoOutputReference(this, "user_info");
  public get userInfo() {
    return this._userInfo;
  }
  public putUserInfo(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataUserInfo) {
    this._userInfo.internalValue = value;
  }
  public resetUserInfo() {
    this._userInfo.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInfoInput() {
    return this._userInfo.internalValue;
  }

  // when - computed: false, optional: true, required: false
  private _when = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhenList(this, "when", false);
  public get when() {
    return this._when;
  }
  public putWhen(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesMetadataWhen[] | cdktf.IResolvable) {
    this._when.internalValue = value;
  }
  public resetWhen() {
    this._when.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenInput() {
    return this._when.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKeyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKeyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache {
  /**
  * Key used to store the entry in the cache. The resolved key must be unique within the scope of this particular config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey;
  /**
  * Duration (in seconds) of the external data in the cache before pulled again from the source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKeyToTerraform(struct!.key),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKeyToHclTerraform(struct!.key),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key?.internalValue;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key.internalValue = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key.internalValue = value.key;
      this._ttl = value.ttl;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKeyOutputReference(this, "key");
  public get key() {
    return this._key;
  }
  public putKey(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheKey) {
    this._key.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key.internalValue;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonPropertiesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonPropertiesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonPropertiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#properties DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#properties}
  */
  readonly properties: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    properties: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonPropertiesToTerraform(struct!.properties),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    properties: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonPropertiesToHclTerraform(struct!.properties),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._properties?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.properties = this._properties?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._properties.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._properties.internalValue = value.properties;
    }
  }

  // properties - computed: false, optional: false, required: true
  private _properties = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonPropertiesOutputReference(this, "properties");
  public get properties() {
    return this._properties;
  }
  public putProperties(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonProperties) {
    this._properties.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get propertiesInput() {
    return this._properties.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlainToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlainToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlainOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders {
  /**
  * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, 'foo' and 'Foo' are considered equivalent. When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for 'Set-Cookie'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the header. Support: Core (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP Header to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath {
  /**
  * Type specifies how to match against the path Value. Support: Core (Exact, PathPrefix) Support: Implementation-specific (RegularExpression)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value of the HTTP path to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams {
  /**
  * Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3). If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored. If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API. Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the query parameter. Support: Extended (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP query param to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches {
  /**
  * Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders[] | cdktf.IResolvable;
  /**
  * Method specifies HTTP method matcher. When specified, this route will be matched only if the request has the specified method. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the '/' path is provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#path DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#path}
  */
  readonly path?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath;
  /**
  * QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_params}
  */
  readonly queryParams?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersToTerraform, false)(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    path: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathToTerraform(struct!.path),
    query_params: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersList",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathToHclTerraform(struct!.path),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath",
    },
    query_params: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsToHclTerraform, false)(struct!.queryParams),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    if (this._queryParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._path.internalValue = undefined;
      this._queryParams.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._path.internalValue = value.path;
      this._queryParams.internalValue = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPathOutputReference(this, "path");
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesPath) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParamsList(this, "query_params", false);
  public get queryParams() {
    return this._queryParams;
  }
  public putQueryParams(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable) {
    this._queryParams.internalValue = value;
  }
  public resetQueryParams() {
    this._queryParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors {
  /**
  * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#hostnames DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Matches define conditions used for matching the rule against incoming HTTP requests. https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#matches DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#matches}
  */
  readonly matches?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    matches: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesToTerraform, false)(struct!.matches),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesToHclTerraform, false)(struct!.matches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._matches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._matches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._matches.internalValue = value.matches;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // matches - computed: false, optional: true, required: false
  private _matches = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatchesList(this, "matches", false);
  public get matches() {
    return this._matches;
  }
  public putMatches(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsMatches[] | cdktf.IResolvable) {
    this._matches.internalValue = value;
  }
  public resetMatches() {
    this._matches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaimsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaimsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs {
  /**
  * Algorithm to sign the wristband token using the signing key provided
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#algorithm DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#algorithm}
  */
  readonly algorithm: string;
  /**
  * Name of the signing key. The value is used to reference the Kubernetes secret that stores the key and in the 'kid' claim of the wristband token header.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    algorithm: cdktf.stringToTerraform(struct!.algorithm),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    algorithm: {
      value: cdktf.stringToHclTerraform(struct!.algorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._algorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.algorithm = this._algorithm;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._algorithm = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._algorithm = value.algorithm;
      this._name = value.name;
    }
  }

  // algorithm - computed: false, optional: false, required: true
  private _algorithm?: string; 
  public get algorithm() {
    return this.getStringAttribute('algorithm');
  }
  public set algorithm(value: string) {
    this._algorithm = value;
  }
  // Temporarily expose input value. Use with caution.
  public get algorithmInput() {
    return this._algorithm;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband {
  /**
  * Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#custom_claims DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#custom_claims}
  */
  readonly customClaims?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims;
  /**
  * The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#issuer DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#issuer}
  */
  readonly issuer: string;
  /**
  * Reference by name to Kubernetes secrets and corresponding signing algorithms. The secrets must contain a 'key.pem' entry whose value is the signing key formatted as PEM.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#signing_key_refs DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#signing_key_refs}
  */
  readonly signingKeyRefs: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs[] | cdktf.IResolvable;
  /**
  * Time span of the wristband token, in seconds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#token_duration DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#token_duration}
  */
  readonly tokenDuration?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_claims: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaimsToTerraform(struct!.customClaims),
    issuer: cdktf.stringToTerraform(struct!.issuer),
    signing_key_refs: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsToTerraform, false)(struct!.signingKeyRefs),
    token_duration: cdktf.numberToTerraform(struct!.tokenDuration),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_claims: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaimsToHclTerraform(struct!.customClaims),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims",
    },
    issuer: {
      value: cdktf.stringToHclTerraform(struct!.issuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signing_key_refs: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsToHclTerraform, false)(struct!.signingKeyRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsList",
    },
    token_duration: {
      value: cdktf.numberToHclTerraform(struct!.tokenDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customClaims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customClaims = this._customClaims?.internalValue;
    }
    if (this._issuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuer = this._issuer;
    }
    if (this._signingKeyRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.signingKeyRefs = this._signingKeyRefs?.internalValue;
    }
    if (this._tokenDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenDuration = this._tokenDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customClaims.internalValue = undefined;
      this._issuer = undefined;
      this._signingKeyRefs.internalValue = undefined;
      this._tokenDuration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customClaims.internalValue = value.customClaims;
      this._issuer = value.issuer;
      this._signingKeyRefs.internalValue = value.signingKeyRefs;
      this._tokenDuration = value.tokenDuration;
    }
  }

  // custom_claims - computed: false, optional: true, required: false
  private _customClaims = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaimsOutputReference(this, "custom_claims");
  public get customClaims() {
    return this._customClaims;
  }
  public putCustomClaims(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandCustomClaims) {
    this._customClaims.internalValue = value;
  }
  public resetCustomClaims() {
    this._customClaims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customClaimsInput() {
    return this._customClaims.internalValue;
  }

  // issuer - computed: false, optional: false, required: true
  private _issuer?: string; 
  public get issuer() {
    return this.getStringAttribute('issuer');
  }
  public set issuer(value: string) {
    this._issuer = value;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerInput() {
    return this._issuer;
  }

  // signing_key_refs - computed: false, optional: false, required: true
  private _signingKeyRefs = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefsList(this, "signing_key_refs", false);
  public get signingKeyRefs() {
    return this._signingKeyRefs;
  }
  public putSigningKeyRefs(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandSigningKeyRefs[] | cdktf.IResolvable) {
    this._signingKeyRefs.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get signingKeyRefsInput() {
    return this._signingKeyRefs.internalValue;
  }

  // token_duration - computed: false, optional: true, required: false
  private _tokenDuration?: number; 
  public get tokenDuration() {
    return this.getNumberAttribute('token_duration');
  }
  public set tokenDuration(value: number) {
    this._tokenDuration = value;
  }
  public resetTokenDuration() {
    this._tokenDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenDurationInput() {
    return this._tokenDuration;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata {
  /**
  * Caching options for the resolved object returned when applying this config. Omit it to avoid caching objects for this config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache;
  /**
  * JSON object Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#json DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#json}
  */
  readonly json?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson;
  /**
  * The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object). If omitted, it will be set to the name of the response config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key?: string;
  /**
  * Whether this config should generate individual observability metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#metrics DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#metrics}
  */
  readonly metrics?: boolean | cdktf.IResolvable;
  /**
  * Plain text content
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#plain DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#plain}
  */
  readonly plain?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain;
  /**
  * Priority group of the config. All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#priority DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#priority}
  */
  readonly priority?: number;
  /**
  * Top-level route selectors. If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule. At least one selected HTTPRoute rule must match to trigger the auth rule. If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#route_selectors DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#route_selectors}
  */
  readonly routeSelectors?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors[] | cdktf.IResolvable;
  /**
  * Conditions for Authorino to enforce this config. If omitted, the config will be enforced for all requests. If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#when DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#when}
  */
  readonly when?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen[] | cdktf.IResolvable;
  /**
  * Authorino Festival Wristband token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#wristband DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#wristband}
  */
  readonly wristband?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheToTerraform(struct!.cache),
    json: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonToTerraform(struct!.json),
    key: cdktf.stringToTerraform(struct!.key),
    metrics: cdktf.booleanToTerraform(struct!.metrics),
    plain: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlainToTerraform(struct!.plain),
    priority: cdktf.numberToTerraform(struct!.priority),
    route_selectors: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsToTerraform, false)(struct!.routeSelectors),
    when: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenToTerraform, false)(struct!.when),
    wristband: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandToTerraform(struct!.wristband),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache",
    },
    json: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics: {
      value: cdktf.booleanToHclTerraform(struct!.metrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    plain: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlainToHclTerraform(struct!.plain),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    route_selectors: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsToHclTerraform, false)(struct!.routeSelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsList",
    },
    when: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenToHclTerraform, false)(struct!.when),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenList",
    },
    wristband: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandToHclTerraform(struct!.wristband),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._plain?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plain = this._plain?.internalValue;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._routeSelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSelectors = this._routeSelectors?.internalValue;
    }
    if (this._when?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.when = this._when?.internalValue;
    }
    if (this._wristband?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wristband = this._wristband?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._json.internalValue = undefined;
      this._key = undefined;
      this._metrics = undefined;
      this._plain.internalValue = undefined;
      this._priority = undefined;
      this._routeSelectors.internalValue = undefined;
      this._when.internalValue = undefined;
      this._wristband.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._json.internalValue = value.json;
      this._key = value.key;
      this._metrics = value.metrics;
      this._plain.internalValue = value.plain;
      this._priority = value.priority;
      this._routeSelectors.internalValue = value.routeSelectors;
      this._when.internalValue = value.when;
      this._wristband.internalValue = value.wristband;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: boolean | cdktf.IResolvable; 
  public get metrics() {
    return this.getBooleanAttribute('metrics');
  }
  public set metrics(value: boolean | cdktf.IResolvable) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // plain - computed: false, optional: true, required: false
  private _plain = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlainOutputReference(this, "plain");
  public get plain() {
    return this._plain;
  }
  public putPlain(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataPlain) {
    this._plain.internalValue = value;
  }
  public resetPlain() {
    this._plain.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get plainInput() {
    return this._plain.internalValue;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // route_selectors - computed: false, optional: true, required: false
  private _routeSelectors = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectorsList(this, "route_selectors", false);
  public get routeSelectors() {
    return this._routeSelectors;
  }
  public putRouteSelectors(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataRouteSelectors[] | cdktf.IResolvable) {
    this._routeSelectors.internalValue = value;
  }
  public resetRouteSelectors() {
    this._routeSelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSelectorsInput() {
    return this._routeSelectors.internalValue;
  }

  // when - computed: false, optional: true, required: false
  private _when = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhenList(this, "when", false);
  public get when() {
    return this._when;
  }
  public putWhen(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWhen[] | cdktf.IResolvable) {
    this._when.internalValue = value;
  }
  public resetWhen() {
    this._when.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenInput() {
    return this._when.internalValue;
  }

  // wristband - computed: false, optional: true, required: false
  private _wristband = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristbandOutputReference(this, "wristband");
  public get wristband() {
    return this._wristband;
  }
  public putWristband(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataWristband) {
    this._wristband.internalValue = value;
  }
  public resetWristband() {
    this._wristband.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wristbandInput() {
    return this._wristband.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKeyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKeyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache {
  /**
  * Key used to store the entry in the cache. The resolved key must be unique within the scope of this particular config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey;
  /**
  * Duration (in seconds) of the external data in the cache before pulled again from the source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#ttl DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKeyToTerraform(struct!.key),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKeyToHclTerraform(struct!.key),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key?.internalValue;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key.internalValue = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key.internalValue = value.key;
      this._ttl = value.ttl;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKeyOutputReference(this, "key");
  public get key() {
    return this._key;
  }
  public putKey(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheKey) {
    this._key.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key.internalValue;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonPropertiesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonPropertiesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonPropertiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#properties DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#properties}
  */
  readonly properties: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    properties: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonPropertiesToTerraform(struct!.properties),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    properties: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonPropertiesToHclTerraform(struct!.properties),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._properties?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.properties = this._properties?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._properties.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._properties.internalValue = value.properties;
    }
  }

  // properties - computed: false, optional: false, required: true
  private _properties = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonPropertiesOutputReference(this, "properties");
  public get properties() {
    return this._properties;
  }
  public putProperties(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonProperties) {
    this._properties.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get propertiesInput() {
    return this._properties.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlainToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlainToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlainOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders {
  /**
  * Name is the name of the HTTP Header to be matched. Name matching MUST be case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2). If multiple entries specify equivalent header names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent header name MUST be ignored. Due to the case-insensitivity of header names, 'foo' and 'Foo' are considered equivalent. When a header is repeated in an HTTP request, it is implementation-specific behavior as to how this is represented. Generally, proxies should follow the guidance from the RFC: https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding processing a repeated header, with special handling for 'Set-Cookie'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the header. Support: Core (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression HeaderMatchType has implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP Header to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath {
  /**
  * Type specifies how to match against the path Value. Support: Core (Exact, PathPrefix) Support: Implementation-specific (RegularExpression)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value of the HTTP path to match against.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams {
  /**
  * Name is the name of the HTTP query param to be matched. This must be an exact string match. (See https://tools.ietf.org/html/rfc7230#section-2.7.3). If multiple entries specify equivalent query param names, only the first entry with an equivalent name MUST be considered for a match. Subsequent entries with an equivalent query param name MUST be ignored. If a query param is repeated in an HTTP request, the behavior is purposely left undefined, since different data planes have different capabilities. However, it is *recommended* that implementations should match against the first value of the param if the data plane supports it, as this behavior is expected in other load balancing contexts outside of the Gateway API. Users SHOULD NOT route traffic based on repeated query params to guard themselves against potential differences in the implementations.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
  /**
  * Type specifies how to match against the value of the query parameter. Support: Extended (Exact) Support: Implementation-specific (RegularExpression) Since RegularExpression QueryParamMatchType has Implementation-specific conformance, implementations can support POSIX, PCRE or any other dialects of regular expressions. Please read the implementation's documentation to determine the supported dialect.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#type DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#type}
  */
  readonly type?: string;
  /**
  * Value is the value of HTTP query param to be matched.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    type: cdktf.stringToTerraform(struct!.type),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._type = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._type = value.type;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches {
  /**
  * Headers specifies HTTP request header matchers. Multiple match values are ANDed together, meaning, a request must match all the specified headers to select the route.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders[] | cdktf.IResolvable;
  /**
  * Method specifies HTTP method matcher. When specified, this route will be matched only if the request has the specified method. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#method DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#method}
  */
  readonly method?: string;
  /**
  * Path specifies a HTTP request path matcher. If this field is not specified, a default prefix match on the '/' path is provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#path DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#path}
  */
  readonly path?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath;
  /**
  * QueryParams specifies HTTP query parameter matchers. Multiple match values are ANDed together, meaning, a request must match all the specified query parameters to select the route. Support: Extended
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#query_params DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#query_params}
  */
  readonly queryParams?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersToTerraform, false)(struct!.headers),
    method: cdktf.stringToTerraform(struct!.method),
    path: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathToTerraform(struct!.path),
    query_params: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersList",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathToHclTerraform(struct!.path),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath",
    },
    query_params: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsToHclTerraform, false)(struct!.queryParams),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    if (this._queryParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._method = undefined;
      this._path.internalValue = undefined;
      this._queryParams.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._method = value.method;
      this._path.internalValue = value.path;
      this._queryParams.internalValue = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // method - computed: false, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPathOutputReference(this, "path");
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesPath) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParamsList(this, "query_params", false);
  public get queryParams() {
    return this._queryParams;
  }
  public putQueryParams(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesQueryParams[] | cdktf.IResolvable) {
    this._queryParams.internalValue = value;
  }
  public resetQueryParams() {
    this._queryParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors {
  /**
  * Hostnames defines a set of hostname that should match against the HTTP Host header to select a HTTPRoute to process the request https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#hostnames DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#hostnames}
  */
  readonly hostnames?: string[];
  /**
  * Matches define conditions used for matching the rule against incoming HTTP requests. https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteSpec
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#matches DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#matches}
  */
  readonly matches?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches[] | cdktf.IResolvable;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hostnames: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.hostnames),
    matches: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesToTerraform, false)(struct!.matches),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hostnames: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.hostnames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesToHclTerraform, false)(struct!.matches),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hostnames !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnames = this._hostnames;
    }
    if (this._matches?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hostnames = undefined;
      this._matches.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hostnames = value.hostnames;
      this._matches.internalValue = value.matches;
    }
  }

  // hostnames - computed: false, optional: true, required: false
  private _hostnames?: string[]; 
  public get hostnames() {
    return this.getListAttribute('hostnames');
  }
  public set hostnames(value: string[]) {
    this._hostnames = value;
  }
  public resetHostnames() {
    this._hostnames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnamesInput() {
    return this._hostnames;
  }

  // matches - computed: false, optional: true, required: false
  private _matches = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatchesList(this, "matches", false);
  public get matches() {
    return this._matches;
  }
  public putMatches(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsMatches[] | cdktf.IResolvable) {
    this._matches.internalValue = value;
  }
  public resetMatches() {
    this._matches.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches.internalValue;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen {
  /**
  * A list of pattern expressions to be evaluated as a logical AND.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#all DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#all}
  */
  readonly all?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * A list of pattern expressions to be evaluated as a logical OR.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#any DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#any}
  */
  readonly any?: { [key: string]: string }[] | cdktf.IResolvable;
  /**
  * The binary operator to be applied to the content fetched from the authorization JSON, for comparison with 'value'. Possible values are: 'eq' (equal to), 'neq' (not equal to), 'incl' (includes; for arrays), 'excl' (excludes; for arrays), 'matches' (regex)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#operator DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Reference to a named set of pattern expressions
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#pattern_ref DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#pattern_ref}
  */
  readonly patternRef?: string;
  /**
  * Path selector to fetch content from the authorization JSON (e.g. 'request.method'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. Authorino custom JSON path modifiers are also supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * The value of reference for the comparison with the content fetched from the authorization JSON. If used with the 'matches' operator, the value must compile to a valid Golang regex.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.all),
    any: cdktf.listMapper(cdktf.hashMapper(cdktf.stringToTerraform), false)(struct!.any),
    operator: cdktf.stringToTerraform(struct!.operator),
    pattern_ref: cdktf.stringToTerraform(struct!.patternRef),
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.all),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    any: {
      value: cdktf.listMapperHcl(cdktf.hashMapperHcl(cdktf.stringToHclTerraform), false)(struct!.any),
      isBlock: false,
      type: "list",
      storageClassType: "stringMapList",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pattern_ref: {
      value: cdktf.stringToHclTerraform(struct!.patternRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._all !== undefined) {
      hasAnyValues = true;
      internalValueResult.all = this._all;
    }
    if (this._any !== undefined) {
      hasAnyValues = true;
      internalValueResult.any = this._any;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._patternRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.patternRef = this._patternRef;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._all = undefined;
      this._any = undefined;
      this._operator = undefined;
      this._patternRef = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._all = value.all;
      this._any = value.any;
      this._operator = value.operator;
      this._patternRef = value.patternRef;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // all - computed: false, optional: true, required: false
  private _all?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get all() {
    return this.interpolationForAttribute('all');
  }
  public set all(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._all = value;
  }
  public resetAll() {
    this._all = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allInput() {
    return this._all;
  }

  // any - computed: false, optional: true, required: false
  private _any?: { [key: string]: string }[] | cdktf.IResolvable; 
  public get any() {
    return this.interpolationForAttribute('any');
  }
  public set any(value: { [key: string]: string }[] | cdktf.IResolvable) {
    this._any = value;
  }
  public resetAny() {
    this._any = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyInput() {
    return this._any;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // pattern_ref - computed: false, optional: true, required: false
  private _patternRef?: string; 
  public get patternRef() {
    return this.getStringAttribute('pattern_ref');
  }
  public set patternRef(value: string) {
    this._patternRef = value;
  }
  public resetPatternRef() {
    this._patternRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternRefInput() {
    return this._patternRef;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaimsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaimsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs {
  /**
  * Algorithm to sign the wristband token using the signing key provided
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#algorithm DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#algorithm}
  */
  readonly algorithm: string;
  /**
  * Name of the signing key. The value is used to reference the Kubernetes secret that stores the key and in the 'kid' claim of the wristband token header.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#name DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    algorithm: cdktf.stringToTerraform(struct!.algorithm),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    algorithm: {
      value: cdktf.stringToHclTerraform(struct!.algorithm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._algorithm !== undefined) {
      hasAnyValues = true;
      internalValueResult.algorithm = this._algorithm;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._algorithm = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._algorithm = value.algorithm;
      this._name = value.name;
    }
  }

  // algorithm - computed: false, optional: false, required: true
  private _algorithm?: string; 
  public get algorithm() {
    return this.getStringAttribute('algorithm');
  }
  public set algorithm(value: string) {
    this._algorithm = value;
  }
  // Temporarily expose input value. Use with caution.
  public get algorithmInput() {
    return this._algorithm;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsOutputReference {
    return new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband {
  /**
  * Any claims to be added to the wristband token apart from the standard JWT claims (iss, iat, exp) added by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#custom_claims DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#custom_claims}
  */
  readonly customClaims?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims;
  /**
  * The endpoint to the Authorino service that issues the wristband (format: <scheme>://<host>:<port>/<realm>, where <realm> = <namespace>/<authorino-auth-config-resource-name/wristband-config-name)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#issuer DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#issuer}
  */
  readonly issuer: string;
  /**
  * Reference by name to Kubernetes secrets and corresponding signing algorithms. The secrets must contain a 'key.pem' entry whose value is the signing key formatted as PEM.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#signing_key_refs DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#signing_key_refs}
  */
  readonly signingKeyRefs: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs[] | cdktf.IResolvable;
  /**
  * Time span of the wristband token, in seconds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#token_duration DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#token_duration}
  */
  readonly tokenDuration?: number;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_claims: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaimsToTerraform(struct!.customClaims),
    issuer: cdktf.stringToTerraform(struct!.issuer),
    signing_key_refs: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsToTerraform, false)(struct!.signingKeyRefs),
    token_duration: cdktf.numberToTerraform(struct!.tokenDuration),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_claims: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaimsToHclTerraform(struct!.customClaims),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims",
    },
    issuer: {
      value: cdktf.stringToHclTerraform(struct!.issuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    signing_key_refs: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsToHclTerraform, false)(struct!.signingKeyRefs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsList",
    },
    token_duration: {
      value: cdktf.numberToHclTerraform(struct!.tokenDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customClaims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customClaims = this._customClaims?.internalValue;
    }
    if (this._issuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuer = this._issuer;
    }
    if (this._signingKeyRefs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.signingKeyRefs = this._signingKeyRefs?.internalValue;
    }
    if (this._tokenDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenDuration = this._tokenDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customClaims.internalValue = undefined;
      this._issuer = undefined;
      this._signingKeyRefs.internalValue = undefined;
      this._tokenDuration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customClaims.internalValue = value.customClaims;
      this._issuer = value.issuer;
      this._signingKeyRefs.internalValue = value.signingKeyRefs;
      this._tokenDuration = value.tokenDuration;
    }
  }

  // custom_claims - computed: false, optional: true, required: false
  private _customClaims = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaimsOutputReference(this, "custom_claims");
  public get customClaims() {
    return this._customClaims;
  }
  public putCustomClaims(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandCustomClaims) {
    this._customClaims.internalValue = value;
  }
  public resetCustomClaims() {
    this._customClaims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customClaimsInput() {
    return this._customClaims.internalValue;
  }

  // issuer - computed: false, optional: false, required: true
  private _issuer?: string; 
  public get issuer() {
    return this.getStringAttribute('issuer');
  }
  public set issuer(value: string) {
    this._issuer = value;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerInput() {
    return this._issuer;
  }

  // signing_key_refs - computed: false, optional: false, required: true
  private _signingKeyRefs = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefsList(this, "signing_key_refs", false);
  public get signingKeyRefs() {
    return this._signingKeyRefs;
  }
  public putSigningKeyRefs(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandSigningKeyRefs[] | cdktf.IResolvable) {
    this._signingKeyRefs.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get signingKeyRefsInput() {
    return this._signingKeyRefs.internalValue;
  }

  // token_duration - computed: false, optional: true, required: false
  private _tokenDuration?: number; 
  public get tokenDuration() {
    return this.getNumberAttribute('token_duration');
  }
  public set tokenDuration(value: number) {
    this._tokenDuration = value;
  }
  public resetTokenDuration() {
    this._tokenDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenDurationInput() {
    return this._tokenDuration;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders {
  /**
  * Caching options for the resolved object returned when applying this config. Omit it to avoid caching objects for this config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#cache DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#cache}
  */
  readonly cache?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache;
  /**
  * JSON object Specify it as the list of properties of the object, whose values can combine static values and values selected from the authorization JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#json DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#json}
  */
  readonly json?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson;
  /**
  * The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object). If omitted, it will be set to the name of the response config.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#key DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#key}
  */
  readonly key?: string;
  /**
  * Whether this config should generate individual observability metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#metrics DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#metrics}
  */
  readonly metrics?: boolean | cdktf.IResolvable;
  /**
  * Plain text content
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#plain DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#plain}
  */
  readonly plain?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain;
  /**
  * Priority group of the config. All configs in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#priority DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#priority}
  */
  readonly priority?: number;
  /**
  * Top-level route selectors. If present, the elements will be used to select HTTPRoute rules that, when activated, trigger the auth rule. At least one selected HTTPRoute rule must match to trigger the auth rule. If no route selectors are specified, the auth rule will be evaluated at all requests to the protected routes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#route_selectors DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#route_selectors}
  */
  readonly routeSelectors?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors[] | cdktf.IResolvable;
  /**
  * Conditions for Authorino to enforce this config. If omitted, the config will be enforced for all requests. If present, all conditions must match for the config to be enforced; otherwise, the config will be skipped.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#when DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#when}
  */
  readonly when?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen[] | cdktf.IResolvable;
  /**
  * Authorino Festival Wristband token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#wristband DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#wristband}
  */
  readonly wristband?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheToTerraform(struct!.cache),
    json: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonToTerraform(struct!.json),
    key: cdktf.stringToTerraform(struct!.key),
    metrics: cdktf.booleanToTerraform(struct!.metrics),
    plain: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlainToTerraform(struct!.plain),
    priority: cdktf.numberToTerraform(struct!.priority),
    route_selectors: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsToTerraform, false)(struct!.routeSelectors),
    when: cdktf.listMapper(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenToTerraform, false)(struct!.when),
    wristband: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandToTerraform(struct!.wristband),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheToHclTerraform(struct!.cache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache",
    },
    json: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonToHclTerraform(struct!.json),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics: {
      value: cdktf.booleanToHclTerraform(struct!.metrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    plain: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlainToHclTerraform(struct!.plain),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain",
    },
    priority: {
      value: cdktf.numberToHclTerraform(struct!.priority),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    route_selectors: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsToHclTerraform, false)(struct!.routeSelectors),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsList",
    },
    when: {
      value: cdktf.listMapperHcl(dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenToHclTerraform, false)(struct!.when),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenList",
    },
    wristband: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandToHclTerraform(struct!.wristband),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cache = this._cache?.internalValue;
    }
    if (this._json?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.json = this._json?.internalValue;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._metrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics;
    }
    if (this._plain?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plain = this._plain?.internalValue;
    }
    if (this._priority !== undefined) {
      hasAnyValues = true;
      internalValueResult.priority = this._priority;
    }
    if (this._routeSelectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeSelectors = this._routeSelectors?.internalValue;
    }
    if (this._when?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.when = this._when?.internalValue;
    }
    if (this._wristband?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wristband = this._wristband?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cache.internalValue = undefined;
      this._json.internalValue = undefined;
      this._key = undefined;
      this._metrics = undefined;
      this._plain.internalValue = undefined;
      this._priority = undefined;
      this._routeSelectors.internalValue = undefined;
      this._when.internalValue = undefined;
      this._wristband.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cache.internalValue = value.cache;
      this._json.internalValue = value.json;
      this._key = value.key;
      this._metrics = value.metrics;
      this._plain.internalValue = value.plain;
      this._priority = value.priority;
      this._routeSelectors.internalValue = value.routeSelectors;
      this._when.internalValue = value.when;
      this._wristband.internalValue = value.wristband;
    }
  }

  // cache - computed: false, optional: true, required: false
  private _cache = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCacheOutputReference(this, "cache");
  public get cache() {
    return this._cache;
  }
  public putCache(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersCache) {
    this._cache.internalValue = value;
  }
  public resetCache() {
    this._cache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheInput() {
    return this._cache.internalValue;
  }

  // json - computed: false, optional: true, required: false
  private _json = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJsonOutputReference(this, "json");
  public get json() {
    return this._json;
  }
  public putJson(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersJson) {
    this._json.internalValue = value;
  }
  public resetJson() {
    this._json.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonInput() {
    return this._json.internalValue;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics?: boolean | cdktf.IResolvable; 
  public get metrics() {
    return this.getBooleanAttribute('metrics');
  }
  public set metrics(value: boolean | cdktf.IResolvable) {
    this._metrics = value;
  }
  public resetMetrics() {
    this._metrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics;
  }

  // plain - computed: false, optional: true, required: false
  private _plain = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlainOutputReference(this, "plain");
  public get plain() {
    return this._plain;
  }
  public putPlain(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersPlain) {
    this._plain.internalValue = value;
  }
  public resetPlain() {
    this._plain.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get plainInput() {
    return this._plain.internalValue;
  }

  // priority - computed: false, optional: true, required: false
  private _priority?: number; 
  public get priority() {
    return this.getNumberAttribute('priority');
  }
  public set priority(value: number) {
    this._priority = value;
  }
  public resetPriority() {
    this._priority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityInput() {
    return this._priority;
  }

  // route_selectors - computed: false, optional: true, required: false
  private _routeSelectors = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectorsList(this, "route_selectors", false);
  public get routeSelectors() {
    return this._routeSelectors;
  }
  public putRouteSelectors(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersRouteSelectors[] | cdktf.IResolvable) {
    this._routeSelectors.internalValue = value;
  }
  public resetRouteSelectors() {
    this._routeSelectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeSelectorsInput() {
    return this._routeSelectors.internalValue;
  }

  // when - computed: false, optional: true, required: false
  private _when = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhenList(this, "when", false);
  public get when() {
    return this._when;
  }
  public putWhen(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWhen[] | cdktf.IResolvable) {
    this._when.internalValue = value;
  }
  public resetWhen() {
    this._when.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get whenInput() {
    return this._when.internalValue;
  }

  // wristband - computed: false, optional: true, required: false
  private _wristband = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristbandOutputReference(this, "wristband");
  public get wristband() {
    return this._wristband;
  }
  public putWristband(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersWristband) {
    this._wristband.internalValue = value;
  }
  public resetWristband() {
    this._wristband.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get wristbandInput() {
    return this._wristband.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccess {
  /**
  * Custom success response items wrapped as HTTP headers. For integration of Authorino via proxy, the proxy must use these settings to propagate dynamic metadata. See https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#dynamic_metadata DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#dynamic_metadata}
  */
  readonly dynamicMetadata?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata;
  /**
  * Custom success response items wrapped as HTTP headers. For integration of Authorino via proxy, the proxy must use these settings to inject data in the request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dynamic_metadata: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataToTerraform(struct!.dynamicMetadata),
    headers: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersToTerraform(struct!.headers),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dynamic_metadata: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataToHclTerraform(struct!.dynamicMetadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata",
    },
    headers: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dynamicMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadata = this._dynamicMetadata?.internalValue;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = value.dynamicMetadata;
      this._headers.internalValue = value.headers;
    }
  }

  // dynamic_metadata - computed: false, optional: true, required: false
  private _dynamicMetadata = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadataOutputReference(this, "dynamic_metadata");
  public get dynamicMetadata() {
    return this._dynamicMetadata;
  }
  public putDynamicMetadata(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessDynamicMetadata) {
    this._dynamicMetadata.internalValue = value;
  }
  public resetDynamicMetadata() {
    this._dynamicMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataInput() {
    return this._dynamicMetadata.internalValue;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseSuccessHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBodyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBodyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessageToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessageToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticated {
  /**
  * HTTP response body to override the default denial body.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body}
  */
  readonly body?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody;
  /**
  * HTTP status code to override the default denial status code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#code DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#code}
  */
  readonly code?: number;
  /**
  * HTTP response headers to override the default denial headers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders;
  /**
  * HTTP message to override the default denial message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#message DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#message}
  */
  readonly message?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticated | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBodyToTerraform(struct!.body),
    code: cdktf.numberToTerraform(struct!.code),
    headers: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeadersToTerraform(struct!.headers),
    message: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessageToTerraform(struct!.message),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticated | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody",
    },
    code: {
      value: cdktf.numberToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    headers: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders",
    },
    message: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessageToHclTerraform(struct!.message),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticated | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._message?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticated | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body.internalValue = undefined;
      this._code = undefined;
      this._headers.internalValue = undefined;
      this._message.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body.internalValue = value.body;
      this._code = value.code;
      this._headers.internalValue = value.headers;
      this._message.internalValue = value.message;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // code - computed: false, optional: true, required: false
  private _code?: number; 
  public get code() {
    return this.getNumberAttribute('code');
  }
  public set code(value: number) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // message - computed: false, optional: true, required: false
  private _message = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessageOutputReference(this, "message");
  public get message() {
    return this._message;
  }
  public putMessage(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthenticatedMessage) {
    this._message.internalValue = value;
  }
  public resetMessage() {
    this._message.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message.internalValue;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBodyToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBodyToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBodyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeadersToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeadersToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage {
  /**
  * Simple path selector to fetch content from the authorization JSON (e.g. 'request.method') or a string template with variables that resolve to patterns (e.g. 'Hello, {auth.identity.name}!'). Any pattern supported by https://pkg.go.dev/github.com/tidwall/gjson can be used. The following Authorino custom modifiers are supported: @extract:{sep:' ',pos:0}, @replace{old:'',new:''}, @case:upper|lower, @base64:encode|decode and @strip.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#selector DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Static value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#value DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessageToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    selector: cdktf.stringToTerraform(struct!.selector),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessageToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._selector = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._selector = value.selector;
      this._value = value.value;
    }
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorized {
  /**
  * HTTP response body to override the default denial body.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#body DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#body}
  */
  readonly body?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody;
  /**
  * HTTP status code to override the default denial status code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#code DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#code}
  */
  readonly code?: number;
  /**
  * HTTP response headers to override the default denial headers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#headers DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#headers}
  */
  readonly headers?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders;
  /**
  * HTTP message to override the default denial message.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kuadrant_io_auth_policy_v1beta2_manifest#message DataK8SKuadrantIoAuthPolicyV1Beta2Manifest#message}
  */
  readonly message?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage;
}

export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedToTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorized | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBodyToTerraform(struct!.body),
    code: cdktf.numberToTerraform(struct!.code),
    headers: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeadersToTerraform(struct!.headers),
    message: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessageToTerraform(struct!.message),
  }
}


export function dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedToHclTerraform(struct?: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorized | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBodyToHclTerraform(struct!.body),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody",
    },
    code: {
      value: cdktf.numberToHclTerraform(struct!.code),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    headers: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeadersToHclTerraform(struct!.headers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders",
    },
    message: {
      value: dataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessageToHclTerraform(struct!.message),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorized | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body?.internalValue;
    }
    if (this._code !== undefined) {
      hasAnyValues = true;
      internalValueResult.code = this._code;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._message?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorized | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body.internalValue = undefined;
      this._code = undefined;
      this._headers.internalValue = undefined;
      this._message.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body.internalValue = value.body;
      this._code = value.code;
      this._headers.internalValue = value.headers;
      this._message.internalValue = value.message;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBodyOutputReference(this, "body");
  public get body() {
    return this._body;
  }
  public putBody(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedBody) {
    this._body.internalValue = value;
  }
  public resetBody() {
    this._body.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body.internalValue;
  }

  // code - computed: false, optional: true, required: false
  private _code?: number; 
  public get code() {
    return this.getNumberAttribute('code');
  }
  public set code(value: number) {
    this._code = value;
  }
  public resetCode() {
    this._code = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codeInput() {
    return this._code;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeadersOutputReference(this, "headers");
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedHeaders) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // message - computed: false, optional: true, required: false
  private _message = new DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessageOutputReference(this, "message");
  public get message() {
    return this._message;
  }
  public putMessage(value: DataK8SKuadrantIoAuthPolicyV1Beta2ManifestSpecOverridesRulesResponseUnauthorizedMessage) {
    this._message.internalValue = value;
  }
  public resetMessage() {
    this._message.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message.internalValue;
  }
}
