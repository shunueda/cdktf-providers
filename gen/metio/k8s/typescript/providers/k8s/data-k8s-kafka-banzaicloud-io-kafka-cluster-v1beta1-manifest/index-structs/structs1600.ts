import * as cdktf from 'cdktf';
import { DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfig,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfigToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfigToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfigOutputReference,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudget,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudgetToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudgetToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudgetOutputReference } from './structs1200'
import { DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPorts,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPortsToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPortsToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPortsList,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfig,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfigToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfigToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfigOutputReference } from './structs0'
import { DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroups,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroupsToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroupsToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroupsOutputReference } from './structs400'
import { DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokers,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokersToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokersToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokersList,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecret,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecretToTerraform,
dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecretToHclTerraform,
DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecretOutputReference } from './structs800'
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * A list of node selector requirements by node's labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * A list of node selector requirements by node's fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_fields DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A list of node selector terms. The terms are ORed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_selector_terms DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_selector_terms}
  */
  readonly nodeSelectorTerms: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, false)(struct!.nodeSelectorTerms),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, false)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: false, required: true
  private _nodeSelectorTerms = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A pod affinity term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_affinity_term DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#weight DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A pod affinity term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_affinity_term DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#weight DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity {
  /**
  * Describes node affinity scheduling rules for the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_affinity}
  */
  readonly nodeAffinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity;
  /**
  * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_affinity}
  */
  readonly podAffinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity;
  /**
  * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_anti_affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_anti_affinity}
  */
  readonly podAntiAffinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    pod_affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityToTerraform(struct!.podAffinity),
    pod_anti_affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityToTerraform(struct!.podAntiAffinity),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity",
    },
    pod_affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityToHclTerraform(struct!.podAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity",
    },
    pod_anti_affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityToHclTerraform(struct!.podAntiAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._podAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinity = this._podAffinity?.internalValue;
    }
    if (this._podAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinity = this._podAntiAffinity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = undefined;
      this._podAffinity.internalValue = undefined;
      this._podAntiAffinity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._podAffinity.internalValue = value.podAffinity;
      this._podAntiAffinity.internalValue = value.podAntiAffinity;
    }
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // pod_affinity - computed: false, optional: true, required: false
  private _podAffinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinityOutputReference(this, "pod_affinity");
  public get podAffinity() {
    return this._podAffinity;
  }
  public putPodAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAffinity) {
    this._podAffinity.internalValue = value;
  }
  public resetPodAffinity() {
    this._podAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityInput() {
    return this._podAffinity.internalValue;
  }

  // pod_anti_affinity - computed: false, optional: true, required: false
  private _podAntiAffinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinityOutputReference(this, "pod_anti_affinity");
  public get podAntiAffinity() {
    return this._podAntiAffinity;
  }
  public putPodAntiAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityPodAntiAffinity) {
    this._podAntiAffinity.internalValue = value;
  }
  public resetPodAntiAffinity() {
    this._podAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityInput() {
    return this._podAntiAffinity.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget {
  /**
  * The budget to set for the PDB, can either be static number or a percentage
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#budget DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#budget}
  */
  readonly budget?: string;
  /**
  * If set to true, will create a podDisruptionBudget
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#create DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#create}
  */
  readonly create?: boolean | cdktf.IResolvable;
  /**
  * The strategy to be used, either minAvailable or maxUnavailable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#strategy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#strategy}
  */
  readonly strategy?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudgetToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    budget: cdktf.stringToTerraform(struct!.budget),
    create: cdktf.booleanToTerraform(struct!.create),
    strategy: cdktf.stringToTerraform(struct!.strategy),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudgetToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    budget: {
      value: cdktf.stringToHclTerraform(struct!.budget),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create: {
      value: cdktf.booleanToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    strategy: {
      value: cdktf.stringToHclTerraform(struct!.strategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudgetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._budget !== undefined) {
      hasAnyValues = true;
      internalValueResult.budget = this._budget;
    }
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    if (this._strategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._budget = undefined;
      this._create = undefined;
      this._strategy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._budget = value.budget;
      this._create = value.create;
      this._strategy = value.strategy;
    }
  }

  // budget - computed: false, optional: true, required: false
  private _budget?: string; 
  public get budget() {
    return this.getStringAttribute('budget');
  }
  public set budget(value: string) {
    this._budget = value;
  }
  public resetBudget() {
    this._budget = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get budgetInput() {
    return this._budget;
  }

  // create - computed: false, optional: true, required: false
  private _create?: boolean | cdktf.IResolvable; 
  public get create() {
    return this.getBooleanAttribute('create');
  }
  public set create(value: boolean | cdktf.IResolvable) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }

  // strategy - computed: false, optional: true, required: false
  private _strategy?: string; 
  public get strategy() {
    return this.getStringAttribute('strategy');
  }
  public set strategy(value: string) {
    this._strategy = value;
  }
  public resetStrategy() {
    this._strategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs {
  /**
  * Envoy --concurrency command line argument. See https://www.envoyproxy.io/docs/envoy/latest/operations/cli#cmdoption-concurrency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#concurrency DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#concurrency}
  */
  readonly concurrency?: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._concurrency = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._concurrency = value.concurrency;
    }
  }

  // concurrency - computed: false, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets {
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions {
  /**
  * Level is SELinux level label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#level DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#level}
  */
  readonly level?: string;
  /**
  * Role is a SELinux role label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#role DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * Type is a SELinux type label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#type}
  */
  readonly type?: string;
  /**
  * User is a SELinux user label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#user DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#user}
  */
  readonly user?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.stringToTerraform(struct!.level),
    role: cdktf.stringToTerraform(struct!.role),
    type: cdktf.stringToTerraform(struct!.type),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._role = undefined;
      this._type = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._role = value.role;
      this._type = value.type;
      this._user = value.user;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile {
  /**
  * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is 'Localhost'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#localhost_profile DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#localhost_profile}
  */
  readonly localhostProfile?: string;
  /**
  * type indicates which kind of seccomp profile will be applied. Valid options are: Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfileToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    localhost_profile: cdktf.stringToTerraform(struct!.localhostProfile),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfileToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    localhost_profile: {
      value: cdktf.stringToHclTerraform(struct!.localhostProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localhostProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.localhostProfile = this._localhostProfile;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localhostProfile = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localhostProfile = value.localhostProfile;
      this._type = value.type;
    }
  }

  // localhost_profile - computed: false, optional: true, required: false
  private _localhostProfile?: string; 
  public get localhostProfile() {
    return this.getStringAttribute('localhost_profile');
  }
  public set localhostProfile(value: string) {
    this._localhostProfile = value;
  }
  public resetLocalhostProfile() {
    this._localhostProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localhostProfileInput() {
    return this._localhostProfile;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls {
  /**
  * Name of a property to set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Value of a property to set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions {
  /**
  * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#gmsa_credential_spec DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#gmsa_credential_spec}
  */
  readonly gmsaCredentialSpec?: string;
  /**
  * GMSACredentialSpecName is the name of the GMSA credential spec to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#gmsa_credential_spec_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#gmsa_credential_spec_name}
  */
  readonly gmsaCredentialSpecName?: string;
  /**
  * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#host_process DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#host_process}
  */
  readonly hostProcess?: boolean | cdktf.IResolvable;
  /**
  * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_user_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_user_name}
  */
  readonly runAsUserName?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gmsa_credential_spec: cdktf.stringToTerraform(struct!.gmsaCredentialSpec),
    gmsa_credential_spec_name: cdktf.stringToTerraform(struct!.gmsaCredentialSpecName),
    host_process: cdktf.booleanToTerraform(struct!.hostProcess),
    run_as_user_name: cdktf.stringToTerraform(struct!.runAsUserName),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gmsa_credential_spec: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gmsa_credential_spec_name: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpecName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_process: {
      value: cdktf.booleanToHclTerraform(struct!.hostProcess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user_name: {
      value: cdktf.stringToHclTerraform(struct!.runAsUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gmsaCredentialSpec !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpec = this._gmsaCredentialSpec;
    }
    if (this._gmsaCredentialSpecName !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpecName = this._gmsaCredentialSpecName;
    }
    if (this._hostProcess !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostProcess = this._hostProcess;
    }
    if (this._runAsUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUserName = this._runAsUserName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = undefined;
      this._gmsaCredentialSpecName = undefined;
      this._hostProcess = undefined;
      this._runAsUserName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = value.gmsaCredentialSpec;
      this._gmsaCredentialSpecName = value.gmsaCredentialSpecName;
      this._hostProcess = value.hostProcess;
      this._runAsUserName = value.runAsUserName;
    }
  }

  // gmsa_credential_spec - computed: false, optional: true, required: false
  private _gmsaCredentialSpec?: string; 
  public get gmsaCredentialSpec() {
    return this.getStringAttribute('gmsa_credential_spec');
  }
  public set gmsaCredentialSpec(value: string) {
    this._gmsaCredentialSpec = value;
  }
  public resetGmsaCredentialSpec() {
    this._gmsaCredentialSpec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecInput() {
    return this._gmsaCredentialSpec;
  }

  // gmsa_credential_spec_name - computed: false, optional: true, required: false
  private _gmsaCredentialSpecName?: string; 
  public get gmsaCredentialSpecName() {
    return this.getStringAttribute('gmsa_credential_spec_name');
  }
  public set gmsaCredentialSpecName(value: string) {
    this._gmsaCredentialSpecName = value;
  }
  public resetGmsaCredentialSpecName() {
    this._gmsaCredentialSpecName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecNameInput() {
    return this._gmsaCredentialSpecName;
  }

  // host_process - computed: false, optional: true, required: false
  private _hostProcess?: boolean | cdktf.IResolvable; 
  public get hostProcess() {
    return this.getBooleanAttribute('host_process');
  }
  public set hostProcess(value: boolean | cdktf.IResolvable) {
    this._hostProcess = value;
  }
  public resetHostProcess() {
    this._hostProcess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostProcessInput() {
    return this._hostProcess;
  }

  // run_as_user_name - computed: false, optional: true, required: false
  private _runAsUserName?: string; 
  public get runAsUserName() {
    return this.getStringAttribute('run_as_user_name');
  }
  public set runAsUserName(value: string) {
    this._runAsUserName = value;
  }
  public resetRunAsUserName() {
    this._runAsUserName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserNameInput() {
    return this._runAsUserName;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext {
  /**
  * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#fs_group DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are 'OnRootMismatch' and 'Always'. If not specified, 'Always' is used. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#fs_group_change_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#fs_group_change_policy}
  */
  readonly fsGroupChangePolicy?: string;
  /**
  * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_group DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_group}
  */
  readonly runAsGroup?: number;
  /**
  * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_non_root DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_non_root}
  */
  readonly runAsNonRoot?: boolean | cdktf.IResolvable;
  /**
  * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_user DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_user}
  */
  readonly runAsUser?: number;
  /**
  * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#se_linux_options DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#se_linux_options}
  */
  readonly seLinuxOptions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions;
  /**
  * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#seccomp_profile DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#seccomp_profile}
  */
  readonly seccompProfile?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile;
  /**
  * A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#supplemental_groups DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#supplemental_groups}
  */
  readonly supplementalGroups?: string[];
  /**
  * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#sysctls DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#sysctls}
  */
  readonly sysctls?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls[] | cdktf.IResolvable;
  /**
  * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#windows_options DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#windows_options}
  */
  readonly windowsOptions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    fs_group_change_policy: cdktf.stringToTerraform(struct!.fsGroupChangePolicy),
    run_as_group: cdktf.numberToTerraform(struct!.runAsGroup),
    run_as_non_root: cdktf.booleanToTerraform(struct!.runAsNonRoot),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
    se_linux_options: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptionsToTerraform(struct!.seLinuxOptions),
    seccomp_profile: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfileToTerraform(struct!.seccompProfile),
    supplemental_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.supplementalGroups),
    sysctls: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsToTerraform, false)(struct!.sysctls),
    windows_options: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptionsToTerraform(struct!.windowsOptions),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    fs_group_change_policy: {
      value: cdktf.stringToHclTerraform(struct!.fsGroupChangePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    run_as_group: {
      value: cdktf.numberToHclTerraform(struct!.runAsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_non_root: {
      value: cdktf.booleanToHclTerraform(struct!.runAsNonRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    se_linux_options: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptionsToHclTerraform(struct!.seLinuxOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions",
    },
    seccomp_profile: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfileToHclTerraform(struct!.seccompProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile",
    },
    supplemental_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.supplementalGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    sysctls: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsToHclTerraform, false)(struct!.sysctls),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsList",
    },
    windows_options: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptionsToHclTerraform(struct!.windowsOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._fsGroupChangePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroupChangePolicy = this._fsGroupChangePolicy;
    }
    if (this._runAsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsGroup = this._runAsGroup;
    }
    if (this._runAsNonRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsNonRoot = this._runAsNonRoot;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    if (this._seLinuxOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seLinuxOptions = this._seLinuxOptions?.internalValue;
    }
    if (this._seccompProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfile = this._seccompProfile?.internalValue;
    }
    if (this._supplementalGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.supplementalGroups = this._supplementalGroups;
    }
    if (this._sysctls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysctls = this._sysctls?.internalValue;
    }
    if (this._windowsOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowsOptions = this._windowsOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._fsGroupChangePolicy = undefined;
      this._runAsGroup = undefined;
      this._runAsNonRoot = undefined;
      this._runAsUser = undefined;
      this._seLinuxOptions.internalValue = undefined;
      this._seccompProfile.internalValue = undefined;
      this._supplementalGroups = undefined;
      this._sysctls.internalValue = undefined;
      this._windowsOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._fsGroupChangePolicy = value.fsGroupChangePolicy;
      this._runAsGroup = value.runAsGroup;
      this._runAsNonRoot = value.runAsNonRoot;
      this._runAsUser = value.runAsUser;
      this._seLinuxOptions.internalValue = value.seLinuxOptions;
      this._seccompProfile.internalValue = value.seccompProfile;
      this._supplementalGroups = value.supplementalGroups;
      this._sysctls.internalValue = value.sysctls;
      this._windowsOptions.internalValue = value.windowsOptions;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // fs_group_change_policy - computed: false, optional: true, required: false
  private _fsGroupChangePolicy?: string; 
  public get fsGroupChangePolicy() {
    return this.getStringAttribute('fs_group_change_policy');
  }
  public set fsGroupChangePolicy(value: string) {
    this._fsGroupChangePolicy = value;
  }
  public resetFsGroupChangePolicy() {
    this._fsGroupChangePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupChangePolicyInput() {
    return this._fsGroupChangePolicy;
  }

  // run_as_group - computed: false, optional: true, required: false
  private _runAsGroup?: number; 
  public get runAsGroup() {
    return this.getNumberAttribute('run_as_group');
  }
  public set runAsGroup(value: number) {
    this._runAsGroup = value;
  }
  public resetRunAsGroup() {
    this._runAsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsGroupInput() {
    return this._runAsGroup;
  }

  // run_as_non_root - computed: false, optional: true, required: false
  private _runAsNonRoot?: boolean | cdktf.IResolvable; 
  public get runAsNonRoot() {
    return this.getBooleanAttribute('run_as_non_root');
  }
  public set runAsNonRoot(value: boolean | cdktf.IResolvable) {
    this._runAsNonRoot = value;
  }
  public resetRunAsNonRoot() {
    this._runAsNonRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsNonRootInput() {
    return this._runAsNonRoot;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }

  // se_linux_options - computed: false, optional: true, required: false
  private _seLinuxOptions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptionsOutputReference(this, "se_linux_options");
  public get seLinuxOptions() {
    return this._seLinuxOptions;
  }
  public putSeLinuxOptions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeLinuxOptions) {
    this._seLinuxOptions.internalValue = value;
  }
  public resetSeLinuxOptions() {
    this._seLinuxOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seLinuxOptionsInput() {
    return this._seLinuxOptions.internalValue;
  }

  // seccomp_profile - computed: false, optional: true, required: false
  private _seccompProfile = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfileOutputReference(this, "seccomp_profile");
  public get seccompProfile() {
    return this._seccompProfile;
  }
  public putSeccompProfile(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSeccompProfile) {
    this._seccompProfile.internalValue = value;
  }
  public resetSeccompProfile() {
    this._seccompProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileInput() {
    return this._seccompProfile.internalValue;
  }

  // supplemental_groups - computed: false, optional: true, required: false
  private _supplementalGroups?: string[]; 
  public get supplementalGroups() {
    return this.getListAttribute('supplemental_groups');
  }
  public set supplementalGroups(value: string[]) {
    this._supplementalGroups = value;
  }
  public resetSupplementalGroups() {
    this._supplementalGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get supplementalGroupsInput() {
    return this._supplementalGroups;
  }

  // sysctls - computed: false, optional: true, required: false
  private _sysctls = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctlsList(this, "sysctls", false);
  public get sysctls() {
    return this._sysctls;
  }
  public putSysctls(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextSysctls[] | cdktf.IResolvable) {
    this._sysctls.internalValue = value;
  }
  public resetSysctls() {
    this._sysctls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysctlsInput() {
    return this._sysctls.internalValue;
  }

  // windows_options - computed: false, optional: true, required: false
  private _windowsOptions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptionsOutputReference(this, "windows_options");
  public get windowsOptions() {
    return this._windowsOptions;
  }
  public putWindowsOptions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextWindowsOptions) {
    this._windowsOptions.internalValue = value;
  }
  public resetWindowsOptions() {
    this._windowsOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowsOptionsInput() {
    return this._windowsOptions.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#claims DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#limits DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#requests DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#effect DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#toleration_seconds DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints {
  /**
  * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector;
  /**
  * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_label_keys DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_label_keys}
  */
  readonly matchLabelKeys?: string[];
  /**
  * MaxSkew describes the degree to which pods may be unevenly distributed. When 'whenUnsatisfiable=DoNotSchedule', it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | | P P | P P | P | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When 'whenUnsatisfiable=ScheduleAnyway', it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#max_skew DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#max_skew}
  */
  readonly maxSkew: number;
  /**
  * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats 'global minimum' as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule. For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P | The number of domains is less than 5(MinDomains), so 'global minimum' is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew. This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#min_domains DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#min_domains}
  */
  readonly minDomains?: number;
  /**
  * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations. If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_affinity_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_affinity_policy}
  */
  readonly nodeAffinityPolicy?: string;
  /**
  * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included. If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_taints_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_taints_policy}
  */
  readonly nodeTaintsPolicy?: string;
  /**
  * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a 'bucket', and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is 'kubernetes.io/hostname', each Node is a domain of that topology. And, if TopologyKey is 'topology.kubernetes.io/zone', each zone is a domain of that topology. It's a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
  /**
  * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered 'Unsatisfiable' for an incoming pod if and only if every possible node assignment for that pod would violate 'MaxSkew' on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#when_unsatisfiable DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#when_unsatisfiable}
  */
  readonly whenUnsatisfiable: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorToTerraform(struct!.labelSelector),
    match_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchLabelKeys),
    max_skew: cdktf.numberToTerraform(struct!.maxSkew),
    min_domains: cdktf.numberToTerraform(struct!.minDomains),
    node_affinity_policy: cdktf.stringToTerraform(struct!.nodeAffinityPolicy),
    node_taints_policy: cdktf.stringToTerraform(struct!.nodeTaintsPolicy),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    when_unsatisfiable: cdktf.stringToTerraform(struct!.whenUnsatisfiable),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector",
    },
    match_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_skew: {
      value: cdktf.numberToHclTerraform(struct!.maxSkew),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_domains: {
      value: cdktf.numberToHclTerraform(struct!.minDomains),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    node_affinity_policy: {
      value: cdktf.stringToHclTerraform(struct!.nodeAffinityPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_taints_policy: {
      value: cdktf.stringToHclTerraform(struct!.nodeTaintsPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    when_unsatisfiable: {
      value: cdktf.stringToHclTerraform(struct!.whenUnsatisfiable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._matchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabelKeys = this._matchLabelKeys;
    }
    if (this._maxSkew !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSkew = this._maxSkew;
    }
    if (this._minDomains !== undefined) {
      hasAnyValues = true;
      internalValueResult.minDomains = this._minDomains;
    }
    if (this._nodeAffinityPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinityPolicy = this._nodeAffinityPolicy;
    }
    if (this._nodeTaintsPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeTaintsPolicy = this._nodeTaintsPolicy;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._whenUnsatisfiable !== undefined) {
      hasAnyValues = true;
      internalValueResult.whenUnsatisfiable = this._whenUnsatisfiable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._matchLabelKeys = undefined;
      this._maxSkew = undefined;
      this._minDomains = undefined;
      this._nodeAffinityPolicy = undefined;
      this._nodeTaintsPolicy = undefined;
      this._topologyKey = undefined;
      this._whenUnsatisfiable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._matchLabelKeys = value.matchLabelKeys;
      this._maxSkew = value.maxSkew;
      this._minDomains = value.minDomains;
      this._nodeAffinityPolicy = value.nodeAffinityPolicy;
      this._nodeTaintsPolicy = value.nodeTaintsPolicy;
      this._topologyKey = value.topologyKey;
      this._whenUnsatisfiable = value.whenUnsatisfiable;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // match_label_keys - computed: false, optional: true, required: false
  private _matchLabelKeys?: string[]; 
  public get matchLabelKeys() {
    return this.getListAttribute('match_label_keys');
  }
  public set matchLabelKeys(value: string[]) {
    this._matchLabelKeys = value;
  }
  public resetMatchLabelKeys() {
    this._matchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelKeysInput() {
    return this._matchLabelKeys;
  }

  // max_skew - computed: false, optional: false, required: true
  private _maxSkew?: number; 
  public get maxSkew() {
    return this.getNumberAttribute('max_skew');
  }
  public set maxSkew(value: number) {
    this._maxSkew = value;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSkewInput() {
    return this._maxSkew;
  }

  // min_domains - computed: false, optional: true, required: false
  private _minDomains?: number; 
  public get minDomains() {
    return this.getNumberAttribute('min_domains');
  }
  public set minDomains(value: number) {
    this._minDomains = value;
  }
  public resetMinDomains() {
    this._minDomains = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minDomainsInput() {
    return this._minDomains;
  }

  // node_affinity_policy - computed: false, optional: true, required: false
  private _nodeAffinityPolicy?: string; 
  public get nodeAffinityPolicy() {
    return this.getStringAttribute('node_affinity_policy');
  }
  public set nodeAffinityPolicy(value: string) {
    this._nodeAffinityPolicy = value;
  }
  public resetNodeAffinityPolicy() {
    this._nodeAffinityPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityPolicyInput() {
    return this._nodeAffinityPolicy;
  }

  // node_taints_policy - computed: false, optional: true, required: false
  private _nodeTaintsPolicy?: string; 
  public get nodeTaintsPolicy() {
    return this.getStringAttribute('node_taints_policy');
  }
  public set nodeTaintsPolicy(value: string) {
    this._nodeTaintsPolicy = value;
  }
  public resetNodeTaintsPolicy() {
    this._nodeTaintsPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeTaintsPolicyInput() {
    return this._nodeTaintsPolicy;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // when_unsatisfiable - computed: false, optional: false, required: true
  private _whenUnsatisfiable?: string; 
  public get whenUnsatisfiable() {
    return this.getStringAttribute('when_unsatisfiable');
  }
  public set whenUnsatisfiable(value: string) {
    this._whenUnsatisfiable = value;
  }
  // Temporarily expose input value. Use with caution.
  public get whenUnsatisfiableInput() {
    return this._whenUnsatisfiable;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig {
  /**
  * Envoy admin port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#admin_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#admin_port}
  */
  readonly adminPort?: number;
  /**
  * Affinity is a group of affinity scheduling rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#affinity}
  */
  readonly affinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity;
  /**
  * Annotations defines the annotations placed on the envoy ingress controller deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * DisruptionBudget is the pod disruption budget attached to Envoy Deployment(s)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#disruption_budget DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#disruption_budget}
  */
  readonly disruptionBudget?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget;
  /**
  * EnableHealthCheckHttp10 is a toggle for adding HTTP1.0 support to Envoy health-check, default false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#enable_health_check_http10 DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#enable_health_check_http10}
  */
  readonly enableHealthCheckHttp10?: boolean | cdktf.IResolvable;
  /**
  * Envoy command line arguments
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#envoy_command_line_args DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#envoy_command_line_args}
  */
  readonly envoyCommandLineArgs?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs;
  /**
  * Envoy health-check port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#health_check_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#health_check_port}
  */
  readonly healthCheckPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#image DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#image}
  */
  readonly image?: string;
  /**
  * ImagePullSecrets for the envoy image pull
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#image_pull_secrets DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#image_pull_secrets}
  */
  readonly imagePullSecrets?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets[] | cdktf.IResolvable;
  /**
  * LoadBalancerIP can be used to specify an exact IP for the LoadBalancer service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#load_balancer_ip DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#load_balancer_ip}
  */
  readonly loadBalancerIp?: string;
  /**
  * If specified and supported by the platform, traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#load_balancer_source_ranges DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#load_balancer_source_ranges}
  */
  readonly loadBalancerSourceRanges?: string[];
  /**
  * NodeSelector is the node selector expression for envoy pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * PodSecurityContext holds pod-level security attributes and common container settings for the Envoy pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_security_context DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_security_context}
  */
  readonly podSecurityContext?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext;
  /**
  * PriorityClassName specifies the priority class name for the Envoy pod(s) If specified, the PriorityClass resource with this PriorityClassName must be created beforehand If not specified, the Envoy pods' priority is default to zero
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#priority_class_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#priority_class_name}
  */
  readonly priorityClassName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#replicas DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * ResourceRequirements describes the compute resource requirements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource_requirements DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource_requirements}
  */
  readonly resourceRequirements?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements;
  /**
  * ServiceAccountName is the name of service account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#service_account_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#service_account_name}
  */
  readonly serviceAccountName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#tolerations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#tolerations}
  */
  readonly tolerations?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_spread_constraints DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_spread_constraints}
  */
  readonly topologySpreadConstraints?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    admin_port: cdktf.numberToTerraform(struct!.adminPort),
    affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityToTerraform(struct!.affinity),
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    disruption_budget: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudgetToTerraform(struct!.disruptionBudget),
    enable_health_check_http10: cdktf.booleanToTerraform(struct!.enableHealthCheckHttp10),
    envoy_command_line_args: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgsToTerraform(struct!.envoyCommandLineArgs),
    health_check_port: cdktf.numberToTerraform(struct!.healthCheckPort),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_secrets: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsToTerraform, false)(struct!.imagePullSecrets),
    load_balancer_ip: cdktf.stringToTerraform(struct!.loadBalancerIp),
    load_balancer_source_ranges: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.loadBalancerSourceRanges),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    pod_security_context: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextToTerraform(struct!.podSecurityContext),
    priority_class_name: cdktf.stringToTerraform(struct!.priorityClassName),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resource_requirements: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsToTerraform(struct!.resourceRequirements),
    service_account_name: cdktf.stringToTerraform(struct!.serviceAccountName),
    tolerations: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsToTerraform, false)(struct!.tolerations),
    topology_spread_constraints: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsToTerraform, false)(struct!.topologySpreadConstraints),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    admin_port: {
      value: cdktf.numberToHclTerraform(struct!.adminPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityToHclTerraform(struct!.affinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity",
    },
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    disruption_budget: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudgetToHclTerraform(struct!.disruptionBudget),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget",
    },
    enable_health_check_http10: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheckHttp10),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    envoy_command_line_args: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgsToHclTerraform(struct!.envoyCommandLineArgs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs",
    },
    health_check_port: {
      value: cdktf.numberToHclTerraform(struct!.healthCheckPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secrets: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsToHclTerraform, false)(struct!.imagePullSecrets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsList",
    },
    load_balancer_ip: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_source_ranges: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.loadBalancerSourceRanges),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    pod_security_context: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextToHclTerraform(struct!.podSecurityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext",
    },
    priority_class_name: {
      value: cdktf.stringToHclTerraform(struct!.priorityClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resource_requirements: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsToHclTerraform(struct!.resourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements",
    },
    service_account_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsList",
    },
    topology_spread_constraints: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsToHclTerraform, false)(struct!.topologySpreadConstraints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._adminPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.adminPort = this._adminPort;
    }
    if (this._affinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.affinity = this._affinity?.internalValue;
    }
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._disruptionBudget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disruptionBudget = this._disruptionBudget?.internalValue;
    }
    if (this._enableHealthCheckHttp10 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheckHttp10 = this._enableHealthCheckHttp10;
    }
    if (this._envoyCommandLineArgs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyCommandLineArgs = this._envoyCommandLineArgs?.internalValue;
    }
    if (this._healthCheckPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheckPort = this._healthCheckPort;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullSecrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecrets = this._imagePullSecrets?.internalValue;
    }
    if (this._loadBalancerIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerIp = this._loadBalancerIp;
    }
    if (this._loadBalancerSourceRanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSourceRanges = this._loadBalancerSourceRanges;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._podSecurityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSecurityContext = this._podSecurityContext?.internalValue;
    }
    if (this._priorityClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.priorityClassName = this._priorityClassName;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceRequirements = this._resourceRequirements?.internalValue;
    }
    if (this._serviceAccountName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountName = this._serviceAccountName;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._topologySpreadConstraints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologySpreadConstraints = this._topologySpreadConstraints?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._adminPort = undefined;
      this._affinity.internalValue = undefined;
      this._annotations = undefined;
      this._disruptionBudget.internalValue = undefined;
      this._enableHealthCheckHttp10 = undefined;
      this._envoyCommandLineArgs.internalValue = undefined;
      this._healthCheckPort = undefined;
      this._image = undefined;
      this._imagePullSecrets.internalValue = undefined;
      this._loadBalancerIp = undefined;
      this._loadBalancerSourceRanges = undefined;
      this._nodeSelector = undefined;
      this._podSecurityContext.internalValue = undefined;
      this._priorityClassName = undefined;
      this._replicas = undefined;
      this._resourceRequirements.internalValue = undefined;
      this._serviceAccountName = undefined;
      this._tolerations.internalValue = undefined;
      this._topologySpreadConstraints.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._adminPort = value.adminPort;
      this._affinity.internalValue = value.affinity;
      this._annotations = value.annotations;
      this._disruptionBudget.internalValue = value.disruptionBudget;
      this._enableHealthCheckHttp10 = value.enableHealthCheckHttp10;
      this._envoyCommandLineArgs.internalValue = value.envoyCommandLineArgs;
      this._healthCheckPort = value.healthCheckPort;
      this._image = value.image;
      this._imagePullSecrets.internalValue = value.imagePullSecrets;
      this._loadBalancerIp = value.loadBalancerIp;
      this._loadBalancerSourceRanges = value.loadBalancerSourceRanges;
      this._nodeSelector = value.nodeSelector;
      this._podSecurityContext.internalValue = value.podSecurityContext;
      this._priorityClassName = value.priorityClassName;
      this._replicas = value.replicas;
      this._resourceRequirements.internalValue = value.resourceRequirements;
      this._serviceAccountName = value.serviceAccountName;
      this._tolerations.internalValue = value.tolerations;
      this._topologySpreadConstraints.internalValue = value.topologySpreadConstraints;
    }
  }

  // admin_port - computed: false, optional: true, required: false
  private _adminPort?: number; 
  public get adminPort() {
    return this.getNumberAttribute('admin_port');
  }
  public set adminPort(value: number) {
    this._adminPort = value;
  }
  public resetAdminPort() {
    this._adminPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adminPortInput() {
    return this._adminPort;
  }

  // affinity - computed: false, optional: true, required: false
  private _affinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinityOutputReference(this, "affinity");
  public get affinity() {
    return this._affinity;
  }
  public putAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigAffinity) {
    this._affinity.internalValue = value;
  }
  public resetAffinity() {
    this._affinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affinityInput() {
    return this._affinity.internalValue;
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // disruption_budget - computed: false, optional: true, required: false
  private _disruptionBudget = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudgetOutputReference(this, "disruption_budget");
  public get disruptionBudget() {
    return this._disruptionBudget;
  }
  public putDisruptionBudget(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigDisruptionBudget) {
    this._disruptionBudget.internalValue = value;
  }
  public resetDisruptionBudget() {
    this._disruptionBudget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disruptionBudgetInput() {
    return this._disruptionBudget.internalValue;
  }

  // enable_health_check_http10 - computed: false, optional: true, required: false
  private _enableHealthCheckHttp10?: boolean | cdktf.IResolvable; 
  public get enableHealthCheckHttp10() {
    return this.getBooleanAttribute('enable_health_check_http10');
  }
  public set enableHealthCheckHttp10(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheckHttp10 = value;
  }
  public resetEnableHealthCheckHttp10() {
    this._enableHealthCheckHttp10 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckHttp10Input() {
    return this._enableHealthCheckHttp10;
  }

  // envoy_command_line_args - computed: false, optional: true, required: false
  private _envoyCommandLineArgs = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgsOutputReference(this, "envoy_command_line_args");
  public get envoyCommandLineArgs() {
    return this._envoyCommandLineArgs;
  }
  public putEnvoyCommandLineArgs(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigEnvoyCommandLineArgs) {
    this._envoyCommandLineArgs.internalValue = value;
  }
  public resetEnvoyCommandLineArgs() {
    this._envoyCommandLineArgs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyCommandLineArgsInput() {
    return this._envoyCommandLineArgs.internalValue;
  }

  // health_check_port - computed: false, optional: true, required: false
  private _healthCheckPort?: number; 
  public get healthCheckPort() {
    return this.getNumberAttribute('health_check_port');
  }
  public set healthCheckPort(value: number) {
    this._healthCheckPort = value;
  }
  public resetHealthCheckPort() {
    this._healthCheckPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckPortInput() {
    return this._healthCheckPort;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_secrets - computed: false, optional: true, required: false
  private _imagePullSecrets = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecretsList(this, "image_pull_secrets", false);
  public get imagePullSecrets() {
    return this._imagePullSecrets;
  }
  public putImagePullSecrets(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigImagePullSecrets[] | cdktf.IResolvable) {
    this._imagePullSecrets.internalValue = value;
  }
  public resetImagePullSecrets() {
    this._imagePullSecrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretsInput() {
    return this._imagePullSecrets.internalValue;
  }

  // load_balancer_ip - computed: false, optional: true, required: false
  private _loadBalancerIp?: string; 
  public get loadBalancerIp() {
    return this.getStringAttribute('load_balancer_ip');
  }
  public set loadBalancerIp(value: string) {
    this._loadBalancerIp = value;
  }
  public resetLoadBalancerIp() {
    this._loadBalancerIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerIpInput() {
    return this._loadBalancerIp;
  }

  // load_balancer_source_ranges - computed: false, optional: true, required: false
  private _loadBalancerSourceRanges?: string[]; 
  public get loadBalancerSourceRanges() {
    return this.getListAttribute('load_balancer_source_ranges');
  }
  public set loadBalancerSourceRanges(value: string[]) {
    this._loadBalancerSourceRanges = value;
  }
  public resetLoadBalancerSourceRanges() {
    this._loadBalancerSourceRanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSourceRangesInput() {
    return this._loadBalancerSourceRanges;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // pod_security_context - computed: false, optional: true, required: false
  private _podSecurityContext = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContextOutputReference(this, "pod_security_context");
  public get podSecurityContext() {
    return this._podSecurityContext;
  }
  public putPodSecurityContext(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigPodSecurityContext) {
    this._podSecurityContext.internalValue = value;
  }
  public resetPodSecurityContext() {
    this._podSecurityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSecurityContextInput() {
    return this._podSecurityContext.internalValue;
  }

  // priority_class_name - computed: false, optional: true, required: false
  private _priorityClassName?: string; 
  public get priorityClassName() {
    return this.getStringAttribute('priority_class_name');
  }
  public set priorityClassName(value: string) {
    this._priorityClassName = value;
  }
  public resetPriorityClassName() {
    this._priorityClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityClassNameInput() {
    return this._priorityClassName;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resource_requirements - computed: false, optional: true, required: false
  private _resourceRequirements = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirementsOutputReference(this, "resource_requirements");
  public get resourceRequirements() {
    return this._resourceRequirements;
  }
  public putResourceRequirements(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigResourceRequirements) {
    this._resourceRequirements.internalValue = value;
  }
  public resetResourceRequirements() {
    this._resourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceRequirementsInput() {
    return this._resourceRequirements.internalValue;
  }

  // service_account_name - computed: false, optional: true, required: false
  private _serviceAccountName?: string; 
  public get serviceAccountName() {
    return this.getStringAttribute('service_account_name');
  }
  public set serviceAccountName(value: string) {
    this._serviceAccountName = value;
  }
  public resetServiceAccountName() {
    this._serviceAccountName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountNameInput() {
    return this._serviceAccountName;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // topology_spread_constraints - computed: false, optional: true, required: false
  private _topologySpreadConstraints = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraintsList(this, "topology_spread_constraints", false);
  public get topologySpreadConstraints() {
    return this._topologySpreadConstraints;
  }
  public putTopologySpreadConstraints(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigTopologySpreadConstraints[] | cdktf.IResolvable) {
    this._topologySpreadConstraints.internalValue = value;
  }
  public resetTopologySpreadConstraints() {
    this._topologySpreadConstraints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologySpreadConstraintsInput() {
    return this._topologySpreadConstraints.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#optional DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#api_version DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#field_path DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#container_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#divisor DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#optional DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#config_map_key_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#field_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource_field_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#secret_key_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value_from DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlaneToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlaneToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlaneOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#optional DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#api_version DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#field_path DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#container_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#divisor DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#optional DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#config_map_key_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#field_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource_field_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#secret_key_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value_from DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig {
  /**
  * REQUIRED if mode is 'MUTUAL'. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ca_certificates DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ca_certificates}
  */
  readonly caCertificates?: string;
  /**
  * Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#cipher_suites DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * The credentialName stands for a unique identifier that can be used to identify the serverCertificate and the privateKey. The credentialName appended with suffix '-cacert' is used to identify the CaCertificates associated with this server. Gateway workloads capable of fetching credentials from a remote credential store such as Kubernetes secrets, will be configured to retrieve the serverCertificate and the privateKey using credentialName, instead of using the file system paths specified above. If using mutual TLS, gateway workload instances will retrieve the CaCertificates using credentialName-cacert. The semantics of the name are platform dependent. In Kubernetes, the default Istio supplied credential server expects the credentialName to match the name of the Kubernetes secret that holds the server certificate, the private key, and the CA certificate (if using mutual TLS). Set the 'ISTIO_META_USER_SDS' metadata variable in the gateway's proxy to enable the dynamic credential fetching feature.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#credential_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#credential_name}
  */
  readonly credentialName?: string;
  /**
  * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#https_redirect DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#https_redirect}
  */
  readonly httpsRedirect?: boolean | cdktf.IResolvable;
  /**
  * Optional: Maximum TLS protocol version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#max_protocol_version DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#max_protocol_version}
  */
  readonly maxProtocolVersion?: string;
  /**
  * Optional: Minimum TLS protocol version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#min_protocol_version DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#min_protocol_version}
  */
  readonly minProtocolVersion?: string;
  /**
  * Optional: Indicates whether connections to this port should be secured using TLS. The value of this field determines how TLS is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#mode DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * REQUIRED if mode is 'SIMPLE' or 'MUTUAL'. The path to the file holding the server's private key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#private_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#private_key}
  */
  readonly privateKey?: string;
  /**
  * REQUIRED if mode is 'SIMPLE' or 'MUTUAL'. The path to the file holding the server-side TLS certificate to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#server_certificate DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#server_certificate}
  */
  readonly serverCertificate?: string;
  /**
  * A list of alternate names to verify the subject identity in the certificate presented by the client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#subject_alt_names DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#subject_alt_names}
  */
  readonly subjectAltNames?: string[];
  /**
  * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#verify_certificate_hash DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#verify_certificate_hash}
  */
  readonly verifyCertificateHash?: string[];
  /**
  * An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#verify_certificate_spki DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#verify_certificate_spki}
  */
  readonly verifyCertificateSpki?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificates: cdktf.stringToTerraform(struct!.caCertificates),
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    credential_name: cdktf.stringToTerraform(struct!.credentialName),
    https_redirect: cdktf.booleanToTerraform(struct!.httpsRedirect),
    max_protocol_version: cdktf.stringToTerraform(struct!.maxProtocolVersion),
    min_protocol_version: cdktf.stringToTerraform(struct!.minProtocolVersion),
    mode: cdktf.stringToTerraform(struct!.mode),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    server_certificate: cdktf.stringToTerraform(struct!.serverCertificate),
    subject_alt_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subjectAltNames),
    verify_certificate_hash: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifyCertificateHash),
    verify_certificate_spki: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifyCertificateSpki),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificates: {
      value: cdktf.stringToHclTerraform(struct!.caCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    credential_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    https_redirect: {
      value: cdktf.booleanToHclTerraform(struct!.httpsRedirect),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maxProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_certificate: {
      value: cdktf.stringToHclTerraform(struct!.serverCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_alt_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subjectAltNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    verify_certificate_hash: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifyCertificateHash),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    verify_certificate_spki: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifyCertificateSpki),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates;
    }
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._credentialName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialName = this._credentialName;
    }
    if (this._httpsRedirect !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpsRedirect = this._httpsRedirect;
    }
    if (this._maxProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProtocolVersion = this._maxProtocolVersion;
    }
    if (this._minProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minProtocolVersion = this._minProtocolVersion;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._serverCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverCertificate = this._serverCertificate;
    }
    if (this._subjectAltNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectAltNames = this._subjectAltNames;
    }
    if (this._verifyCertificateHash !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyCertificateHash = this._verifyCertificateHash;
    }
    if (this._verifyCertificateSpki !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyCertificateSpki = this._verifyCertificateSpki;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificates = undefined;
      this._cipherSuites = undefined;
      this._credentialName = undefined;
      this._httpsRedirect = undefined;
      this._maxProtocolVersion = undefined;
      this._minProtocolVersion = undefined;
      this._mode = undefined;
      this._privateKey = undefined;
      this._serverCertificate = undefined;
      this._subjectAltNames = undefined;
      this._verifyCertificateHash = undefined;
      this._verifyCertificateSpki = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificates = value.caCertificates;
      this._cipherSuites = value.cipherSuites;
      this._credentialName = value.credentialName;
      this._httpsRedirect = value.httpsRedirect;
      this._maxProtocolVersion = value.maxProtocolVersion;
      this._minProtocolVersion = value.minProtocolVersion;
      this._mode = value.mode;
      this._privateKey = value.privateKey;
      this._serverCertificate = value.serverCertificate;
      this._subjectAltNames = value.subjectAltNames;
      this._verifyCertificateHash = value.verifyCertificateHash;
      this._verifyCertificateSpki = value.verifyCertificateSpki;
    }
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates?: string; 
  public get caCertificates() {
    return this.getStringAttribute('ca_certificates');
  }
  public set caCertificates(value: string) {
    this._caCertificates = value;
  }
  public resetCaCertificates() {
    this._caCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates;
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // credential_name - computed: false, optional: true, required: false
  private _credentialName?: string; 
  public get credentialName() {
    return this.getStringAttribute('credential_name');
  }
  public set credentialName(value: string) {
    this._credentialName = value;
  }
  public resetCredentialName() {
    this._credentialName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialNameInput() {
    return this._credentialName;
  }

  // https_redirect - computed: false, optional: true, required: false
  private _httpsRedirect?: boolean | cdktf.IResolvable; 
  public get httpsRedirect() {
    return this.getBooleanAttribute('https_redirect');
  }
  public set httpsRedirect(value: boolean | cdktf.IResolvable) {
    this._httpsRedirect = value;
  }
  public resetHttpsRedirect() {
    this._httpsRedirect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpsRedirectInput() {
    return this._httpsRedirect;
  }

  // max_protocol_version - computed: false, optional: true, required: false
  private _maxProtocolVersion?: string; 
  public get maxProtocolVersion() {
    return this.getStringAttribute('max_protocol_version');
  }
  public set maxProtocolVersion(value: string) {
    this._maxProtocolVersion = value;
  }
  public resetMaxProtocolVersion() {
    this._maxProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProtocolVersionInput() {
    return this._maxProtocolVersion;
  }

  // min_protocol_version - computed: false, optional: true, required: false
  private _minProtocolVersion?: string; 
  public get minProtocolVersion() {
    return this.getStringAttribute('min_protocol_version');
  }
  public set minProtocolVersion(value: string) {
    this._minProtocolVersion = value;
  }
  public resetMinProtocolVersion() {
    this._minProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minProtocolVersionInput() {
    return this._minProtocolVersion;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // server_certificate - computed: false, optional: true, required: false
  private _serverCertificate?: string; 
  public get serverCertificate() {
    return this.getStringAttribute('server_certificate');
  }
  public set serverCertificate(value: string) {
    this._serverCertificate = value;
  }
  public resetServerCertificate() {
    this._serverCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverCertificateInput() {
    return this._serverCertificate;
  }

  // subject_alt_names - computed: false, optional: true, required: false
  private _subjectAltNames?: string[]; 
  public get subjectAltNames() {
    return this.getListAttribute('subject_alt_names');
  }
  public set subjectAltNames(value: string[]) {
    this._subjectAltNames = value;
  }
  public resetSubjectAltNames() {
    this._subjectAltNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAltNamesInput() {
    return this._subjectAltNames;
  }

  // verify_certificate_hash - computed: false, optional: true, required: false
  private _verifyCertificateHash?: string[]; 
  public get verifyCertificateHash() {
    return this.getListAttribute('verify_certificate_hash');
  }
  public set verifyCertificateHash(value: string[]) {
    this._verifyCertificateHash = value;
  }
  public resetVerifyCertificateHash() {
    this._verifyCertificateHash = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyCertificateHashInput() {
    return this._verifyCertificateHash;
  }

  // verify_certificate_spki - computed: false, optional: true, required: false
  private _verifyCertificateSpki?: string[]; 
  public get verifyCertificateSpki() {
    return this.getListAttribute('verify_certificate_spki');
  }
  public set verifyCertificateSpki(value: string[]) {
    this._verifyCertificateSpki = value;
  }
  public resetVerifyCertificateSpki() {
    this._verifyCertificateSpki = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyCertificateSpkiInput() {
    return this._verifyCertificateSpki;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#claims DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#limits DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#requests DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#effect DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#toleration_seconds DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig {
  /**
  * Annotations defines the annotations placed on the istio ingress controller deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Envs allows to add additional env vars to the istio meshgateway resource
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#envs DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#envs}
  */
  readonly envs?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#gateway_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#gateway_config}
  */
  readonly gatewayConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig;
  /**
  * If specified and supported by the platform, traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.' More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#load_balancer_source_ranges DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#load_balancer_source_ranges}
  */
  readonly loadBalancerSourceRanges?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#replicas DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * ResourceRequirements describes the compute resource requirements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource_requirements DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource_requirements}
  */
  readonly resourceRequirements?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#tolerations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#tolerations}
  */
  readonly tolerations?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#virtual_service_annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#virtual_service_annotations}
  */
  readonly virtualServiceAnnotations?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    envs: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsToTerraform, false)(struct!.envs),
    gateway_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfigToTerraform(struct!.gatewayConfig),
    load_balancer_source_ranges: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.loadBalancerSourceRanges),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resource_requirements: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsToTerraform(struct!.resourceRequirements),
    tolerations: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsToTerraform, false)(struct!.tolerations),
    virtual_service_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.virtualServiceAnnotations),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    envs: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsToHclTerraform, false)(struct!.envs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsList",
    },
    gateway_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfigToHclTerraform(struct!.gatewayConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig",
    },
    load_balancer_source_ranges: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.loadBalancerSourceRanges),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resource_requirements: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsToHclTerraform(struct!.resourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsList",
    },
    virtual_service_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.virtualServiceAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._envs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envs = this._envs?.internalValue;
    }
    if (this._gatewayConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayConfig = this._gatewayConfig?.internalValue;
    }
    if (this._loadBalancerSourceRanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSourceRanges = this._loadBalancerSourceRanges;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceRequirements = this._resourceRequirements?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._virtualServiceAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceAnnotations = this._virtualServiceAnnotations;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._envs.internalValue = undefined;
      this._gatewayConfig.internalValue = undefined;
      this._loadBalancerSourceRanges = undefined;
      this._nodeSelector = undefined;
      this._replicas = undefined;
      this._resourceRequirements.internalValue = undefined;
      this._tolerations.internalValue = undefined;
      this._virtualServiceAnnotations = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._envs.internalValue = value.envs;
      this._gatewayConfig.internalValue = value.gatewayConfig;
      this._loadBalancerSourceRanges = value.loadBalancerSourceRanges;
      this._nodeSelector = value.nodeSelector;
      this._replicas = value.replicas;
      this._resourceRequirements.internalValue = value.resourceRequirements;
      this._tolerations.internalValue = value.tolerations;
      this._virtualServiceAnnotations = value.virtualServiceAnnotations;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // envs - computed: false, optional: true, required: false
  private _envs = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvsList(this, "envs", false);
  public get envs() {
    return this._envs;
  }
  public putEnvs(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigEnvs[] | cdktf.IResolvable) {
    this._envs.internalValue = value;
  }
  public resetEnvs() {
    this._envs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envsInput() {
    return this._envs.internalValue;
  }

  // gateway_config - computed: false, optional: true, required: false
  private _gatewayConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfigOutputReference(this, "gateway_config");
  public get gatewayConfig() {
    return this._gatewayConfig;
  }
  public putGatewayConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigGatewayConfig) {
    this._gatewayConfig.internalValue = value;
  }
  public resetGatewayConfig() {
    this._gatewayConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayConfigInput() {
    return this._gatewayConfig.internalValue;
  }

  // load_balancer_source_ranges - computed: false, optional: true, required: false
  private _loadBalancerSourceRanges?: string[]; 
  public get loadBalancerSourceRanges() {
    return this.getListAttribute('load_balancer_source_ranges');
  }
  public set loadBalancerSourceRanges(value: string[]) {
    this._loadBalancerSourceRanges = value;
  }
  public resetLoadBalancerSourceRanges() {
    this._loadBalancerSourceRanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSourceRangesInput() {
    return this._loadBalancerSourceRanges;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resource_requirements - computed: false, optional: true, required: false
  private _resourceRequirements = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirementsOutputReference(this, "resource_requirements");
  public get resourceRequirements() {
    return this._resourceRequirements;
  }
  public putResourceRequirements(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigResourceRequirements) {
    this._resourceRequirements.internalValue = value;
  }
  public resetResourceRequirements() {
    this._resourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceRequirementsInput() {
    return this._resourceRequirements.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // virtual_service_annotations - computed: false, optional: true, required: false
  private _virtualServiceAnnotations?: { [key: string]: string }; 
  public get virtualServiceAnnotations() {
    return this.getStringMapAttribute('virtual_service_annotations');
  }
  public set virtualServiceAnnotations(value: { [key: string]: string }) {
    this._virtualServiceAnnotations = value;
  }
  public resetVirtualServiceAnnotations() {
    this._virtualServiceAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceAnnotationsInput() {
    return this._virtualServiceAnnotations;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
  * A list of node selector requirements by node's labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable;
  /**
  * A list of node selector requirements by node's fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_fields DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * A node selector term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#preference DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#preference}
  */
  readonly preference: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;
  /**
  * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#weight DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preference: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToTerraform(struct!.preference),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preference: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preference.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preference.internalValue = value.preference;
      this._weight = value.weight;
    }
  }

  // preference - computed: false, optional: false, required: true
  private _preference = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference) {
    this._preference.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
  * The label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
  * A list of node selector requirements by node's labels.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable;
  /**
  * A list of node selector requirements by node's fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_fields DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_fields}
  */
  readonly matchFields?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_fields: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToTerraform, false)(struct!.matchFields),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList",
    },
    match_fields: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsToHclTerraform, false)(struct!.matchFields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchFields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchFields = this._matchFields?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchFields.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchFields.internalValue = value.matchFields;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_fields - computed: false, optional: true, required: false
  private _matchFields = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsList(this, "match_fields", false);
  public get matchFields() {
    return this._matchFields;
  }
  public putMatchFields(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[] | cdktf.IResolvable) {
    this._matchFields.internalValue = value;
  }
  public resetMatchFields() {
    this._matchFields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchFieldsInput() {
    return this._matchFields.internalValue;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A list of node selector terms. The terms are ORed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_selector_terms DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_selector_terms}
  */
  readonly nodeSelectorTerms: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_selector_terms: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToTerraform, false)(struct!.nodeSelectorTerms),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_selector_terms: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsToHclTerraform, false)(struct!.nodeSelectorTerms),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeSelectorTerms?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelectorTerms = this._nodeSelectorTerms?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeSelectorTerms.internalValue = value.nodeSelectorTerms;
    }
  }

  // node_selector_terms - computed: false, optional: false, required: true
  private _nodeSelectorTerms = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsList(this, "node_selector_terms", false);
  public get nodeSelectorTerms() {
    return this._nodeSelectorTerms;
  }
  public putNodeSelectorTerms(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[] | cdktf.IResolvable) {
    this._nodeSelectorTerms.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorTermsInput() {
    return this._nodeSelectorTerms.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this, "required_during_scheduling_ignored_during_execution");
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A pod affinity term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_affinity_term DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#weight DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
  * Required. A pod affinity term, associated with the corresponding weight.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_affinity_term DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_affinity_term}
  */
  readonly podAffinityTerm: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;
  /**
  * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#weight DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#weight}
  */
  readonly weight: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pod_affinity_term: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToTerraform(struct!.podAffinityTerm),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pod_affinity_term: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermToHclTerraform(struct!.podAffinityTerm),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._podAffinityTerm?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinityTerm = this._podAffinityTerm?.internalValue;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._podAffinityTerm.internalValue = value.podAffinityTerm;
      this._weight = value.weight;
    }
  }

  // pod_affinity_term - computed: false, optional: false, required: true
  private _podAffinityTerm = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermOutputReference(this, "pod_affinity_term");
  public get podAffinityTerm() {
    return this._podAffinityTerm;
  }
  public putPodAffinityTerm(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm) {
    this._podAffinityTerm.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityTermInput() {
    return this._podAffinityTerm.internalValue;
  }

  // weight - computed: false, optional: false, required: true
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
  * A label query over a set of resources, in this case pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;
  /**
  * A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means 'this pod's namespace'. An empty selector ({}) matches all namespaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespace_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector;
  /**
  * namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means 'this pod's namespace'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#namespaces DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
  /**
  * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToTerraform(struct!.labelSelector),
    namespace_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector",
    },
    namespace_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
      this._topologyKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
      this._topologyKey = value.topologyKey;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity {
  /**
  * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding 'weight' to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#preferred_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#preferred_during_scheduling_ignored_during_execution}
  */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
  /**
  * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#required_during_scheduling_ignored_during_execution DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#required_during_scheduling_ignored_during_execution}
  */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    preferred_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
    required_during_scheduling_ignored_during_execution: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    preferred_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.preferredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList",
    },
    required_during_scheduling_ignored_during_execution: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionToHclTerraform, false)(struct!.requiredDuringSchedulingIgnoredDuringExecution),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preferredDuringSchedulingIgnoredDuringExecution = this._preferredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    if (this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requiredDuringSchedulingIgnoredDuringExecution = this._requiredDuringSchedulingIgnoredDuringExecution?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value.preferredDuringSchedulingIgnoredDuringExecution;
      this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value.requiredDuringSchedulingIgnoredDuringExecution;
    }
  }

  // preferred_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _preferredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionList(this, "preferred_during_scheduling_ignored_during_execution", false);
  public get preferredDuringSchedulingIgnoredDuringExecution() {
    return this._preferredDuringSchedulingIgnoredDuringExecution;
  }
  public putPreferredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetPreferredDuringSchedulingIgnoredDuringExecution() {
    this._preferredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._preferredDuringSchedulingIgnoredDuringExecution.internalValue;
  }

  // required_during_scheduling_ignored_during_execution - computed: false, optional: true, required: false
  private _requiredDuringSchedulingIgnoredDuringExecution = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionList(this, "required_during_scheduling_ignored_during_execution", false);
  public get requiredDuringSchedulingIgnoredDuringExecution() {
    return this._requiredDuringSchedulingIgnoredDuringExecution;
  }
  public putRequiredDuringSchedulingIgnoredDuringExecution(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[] | cdktf.IResolvable) {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = value;
  }
  public resetRequiredDuringSchedulingIgnoredDuringExecution() {
    this._requiredDuringSchedulingIgnoredDuringExecution.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requiredDuringSchedulingIgnoredDuringExecutionInput() {
    return this._requiredDuringSchedulingIgnoredDuringExecution.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity {
  /**
  * Describes node affinity scheduling rules for the pod.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_affinity}
  */
  readonly nodeAffinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity;
  /**
  * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_affinity}
  */
  readonly podAffinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity;
  /**
  * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_anti_affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_anti_affinity}
  */
  readonly podAntiAffinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    node_affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityToTerraform(struct!.nodeAffinity),
    pod_affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityToTerraform(struct!.podAffinity),
    pod_anti_affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityToTerraform(struct!.podAntiAffinity),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    node_affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityToHclTerraform(struct!.nodeAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity",
    },
    pod_affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityToHclTerraform(struct!.podAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity",
    },
    pod_anti_affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityToHclTerraform(struct!.podAntiAffinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._nodeAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinity = this._nodeAffinity?.internalValue;
    }
    if (this._podAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAffinity = this._podAffinity?.internalValue;
    }
    if (this._podAntiAffinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podAntiAffinity = this._podAntiAffinity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = undefined;
      this._podAffinity.internalValue = undefined;
      this._podAntiAffinity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._nodeAffinity.internalValue = value.nodeAffinity;
      this._podAffinity.internalValue = value.podAffinity;
      this._podAntiAffinity.internalValue = value.podAntiAffinity;
    }
  }

  // node_affinity - computed: false, optional: true, required: false
  private _nodeAffinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinityOutputReference(this, "node_affinity");
  public get nodeAffinity() {
    return this._nodeAffinity;
  }
  public putNodeAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityNodeAffinity) {
    this._nodeAffinity.internalValue = value;
  }
  public resetNodeAffinity() {
    this._nodeAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityInput() {
    return this._nodeAffinity.internalValue;
  }

  // pod_affinity - computed: false, optional: true, required: false
  private _podAffinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinityOutputReference(this, "pod_affinity");
  public get podAffinity() {
    return this._podAffinity;
  }
  public putPodAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAffinity) {
    this._podAffinity.internalValue = value;
  }
  public resetPodAffinity() {
    this._podAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAffinityInput() {
    return this._podAffinity.internalValue;
  }

  // pod_anti_affinity - computed: false, optional: true, required: false
  private _podAntiAffinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinityOutputReference(this, "pod_anti_affinity");
  public get podAntiAffinity() {
    return this._podAntiAffinity;
  }
  public putPodAntiAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityPodAntiAffinity) {
    this._podAntiAffinity.internalValue = value;
  }
  public resetPodAntiAffinity() {
    this._podAntiAffinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podAntiAffinityInput() {
    return this._podAntiAffinity.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget {
  /**
  * The budget to set for the PDB, can either be static number or a percentage
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#budget DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#budget}
  */
  readonly budget?: string;
  /**
  * If set to true, will create a podDisruptionBudget
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#create DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#create}
  */
  readonly create?: boolean | cdktf.IResolvable;
  /**
  * The strategy to be used, either minAvailable or maxUnavailable
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#strategy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#strategy}
  */
  readonly strategy?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudgetToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    budget: cdktf.stringToTerraform(struct!.budget),
    create: cdktf.booleanToTerraform(struct!.create),
    strategy: cdktf.stringToTerraform(struct!.strategy),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudgetToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    budget: {
      value: cdktf.stringToHclTerraform(struct!.budget),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create: {
      value: cdktf.booleanToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    strategy: {
      value: cdktf.stringToHclTerraform(struct!.strategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudgetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._budget !== undefined) {
      hasAnyValues = true;
      internalValueResult.budget = this._budget;
    }
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    if (this._strategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.strategy = this._strategy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._budget = undefined;
      this._create = undefined;
      this._strategy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._budget = value.budget;
      this._create = value.create;
      this._strategy = value.strategy;
    }
  }

  // budget - computed: false, optional: true, required: false
  private _budget?: string; 
  public get budget() {
    return this.getStringAttribute('budget');
  }
  public set budget(value: string) {
    this._budget = value;
  }
  public resetBudget() {
    this._budget = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get budgetInput() {
    return this._budget;
  }

  // create - computed: false, optional: true, required: false
  private _create?: boolean | cdktf.IResolvable; 
  public get create() {
    return this.getBooleanAttribute('create');
  }
  public set create(value: boolean | cdktf.IResolvable) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }

  // strategy - computed: false, optional: true, required: false
  private _strategy?: string; 
  public get strategy() {
    return this.getStringAttribute('strategy');
  }
  public set strategy(value: string) {
    this._strategy = value;
  }
  public resetStrategy() {
    this._strategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strategyInput() {
    return this._strategy;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs {
  /**
  * Envoy --concurrency command line argument. See https://www.envoyproxy.io/docs/envoy/latest/operations/cli#cmdoption-concurrency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#concurrency DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#concurrency}
  */
  readonly concurrency?: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._concurrency = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._concurrency = value.concurrency;
    }
  }

  // concurrency - computed: false, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets {
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions {
  /**
  * Level is SELinux level label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#level DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#level}
  */
  readonly level?: string;
  /**
  * Role is a SELinux role label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#role DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * Type is a SELinux type label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#type}
  */
  readonly type?: string;
  /**
  * User is a SELinux user label that applies to the container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#user DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#user}
  */
  readonly user?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    level: cdktf.stringToTerraform(struct!.level),
    role: cdktf.stringToTerraform(struct!.role),
    type: cdktf.stringToTerraform(struct!.type),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    level: {
      value: cdktf.stringToHclTerraform(struct!.level),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._level !== undefined) {
      hasAnyValues = true;
      internalValueResult.level = this._level;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._level = undefined;
      this._role = undefined;
      this._type = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._level = value.level;
      this._role = value.role;
      this._type = value.type;
      this._user = value.user;
    }
  }

  // level - computed: false, optional: true, required: false
  private _level?: string; 
  public get level() {
    return this.getStringAttribute('level');
  }
  public set level(value: string) {
    this._level = value;
  }
  public resetLevel() {
    this._level = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get levelInput() {
    return this._level;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // user - computed: false, optional: true, required: false
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  public resetUser() {
    this._user = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile {
  /**
  * localhostProfile indicates a profile defined in a file on the node should be used. The profile must be preconfigured on the node to work. Must be a descending path, relative to the kubelet's configured seccomp profile location. Must only be set if type is 'Localhost'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#localhost_profile DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#localhost_profile}
  */
  readonly localhostProfile?: string;
  /**
  * type indicates which kind of seccomp profile will be applied. Valid options are: Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfileToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    localhost_profile: cdktf.stringToTerraform(struct!.localhostProfile),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfileToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    localhost_profile: {
      value: cdktf.stringToHclTerraform(struct!.localhostProfile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._localhostProfile !== undefined) {
      hasAnyValues = true;
      internalValueResult.localhostProfile = this._localhostProfile;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._localhostProfile = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._localhostProfile = value.localhostProfile;
      this._type = value.type;
    }
  }

  // localhost_profile - computed: false, optional: true, required: false
  private _localhostProfile?: string; 
  public get localhostProfile() {
    return this.getStringAttribute('localhost_profile');
  }
  public set localhostProfile(value: string) {
    this._localhostProfile = value;
  }
  public resetLocalhostProfile() {
    this._localhostProfile = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localhostProfileInput() {
    return this._localhostProfile;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls {
  /**
  * Name of a property to set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Value of a property to set
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions {
  /**
  * GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#gmsa_credential_spec DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#gmsa_credential_spec}
  */
  readonly gmsaCredentialSpec?: string;
  /**
  * GMSACredentialSpecName is the name of the GMSA credential spec to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#gmsa_credential_spec_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#gmsa_credential_spec_name}
  */
  readonly gmsaCredentialSpecName?: string;
  /**
  * HostProcess determines if a container should be run as a 'Host Process' container. This field is alpha-level and will only be honored by components that enable the WindowsHostProcessContainers feature flag. Setting this field without the feature flag will result in errors when validating the Pod. All of a Pod's containers must have the same effective HostProcess value (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers). In addition, if HostProcess is true then HostNetwork must also be set to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#host_process DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#host_process}
  */
  readonly hostProcess?: boolean | cdktf.IResolvable;
  /**
  * The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_user_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_user_name}
  */
  readonly runAsUserName?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    gmsa_credential_spec: cdktf.stringToTerraform(struct!.gmsaCredentialSpec),
    gmsa_credential_spec_name: cdktf.stringToTerraform(struct!.gmsaCredentialSpecName),
    host_process: cdktf.booleanToTerraform(struct!.hostProcess),
    run_as_user_name: cdktf.stringToTerraform(struct!.runAsUserName),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    gmsa_credential_spec: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gmsa_credential_spec_name: {
      value: cdktf.stringToHclTerraform(struct!.gmsaCredentialSpecName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_process: {
      value: cdktf.booleanToHclTerraform(struct!.hostProcess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user_name: {
      value: cdktf.stringToHclTerraform(struct!.runAsUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._gmsaCredentialSpec !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpec = this._gmsaCredentialSpec;
    }
    if (this._gmsaCredentialSpecName !== undefined) {
      hasAnyValues = true;
      internalValueResult.gmsaCredentialSpecName = this._gmsaCredentialSpecName;
    }
    if (this._hostProcess !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostProcess = this._hostProcess;
    }
    if (this._runAsUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUserName = this._runAsUserName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = undefined;
      this._gmsaCredentialSpecName = undefined;
      this._hostProcess = undefined;
      this._runAsUserName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._gmsaCredentialSpec = value.gmsaCredentialSpec;
      this._gmsaCredentialSpecName = value.gmsaCredentialSpecName;
      this._hostProcess = value.hostProcess;
      this._runAsUserName = value.runAsUserName;
    }
  }

  // gmsa_credential_spec - computed: false, optional: true, required: false
  private _gmsaCredentialSpec?: string; 
  public get gmsaCredentialSpec() {
    return this.getStringAttribute('gmsa_credential_spec');
  }
  public set gmsaCredentialSpec(value: string) {
    this._gmsaCredentialSpec = value;
  }
  public resetGmsaCredentialSpec() {
    this._gmsaCredentialSpec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecInput() {
    return this._gmsaCredentialSpec;
  }

  // gmsa_credential_spec_name - computed: false, optional: true, required: false
  private _gmsaCredentialSpecName?: string; 
  public get gmsaCredentialSpecName() {
    return this.getStringAttribute('gmsa_credential_spec_name');
  }
  public set gmsaCredentialSpecName(value: string) {
    this._gmsaCredentialSpecName = value;
  }
  public resetGmsaCredentialSpecName() {
    this._gmsaCredentialSpecName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gmsaCredentialSpecNameInput() {
    return this._gmsaCredentialSpecName;
  }

  // host_process - computed: false, optional: true, required: false
  private _hostProcess?: boolean | cdktf.IResolvable; 
  public get hostProcess() {
    return this.getBooleanAttribute('host_process');
  }
  public set hostProcess(value: boolean | cdktf.IResolvable) {
    this._hostProcess = value;
  }
  public resetHostProcess() {
    this._hostProcess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostProcessInput() {
    return this._hostProcess;
  }

  // run_as_user_name - computed: false, optional: true, required: false
  private _runAsUserName?: string; 
  public get runAsUserName() {
    return this.getStringAttribute('run_as_user_name');
  }
  public set runAsUserName(value: string) {
    this._runAsUserName = value;
  }
  public resetRunAsUserName() {
    this._runAsUserName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserNameInput() {
    return this._runAsUserName;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext {
  /**
  * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw---- If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#fs_group DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#fs_group}
  */
  readonly fsGroup?: number;
  /**
  * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are 'OnRootMismatch' and 'Always'. If not specified, 'Always' is used. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#fs_group_change_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#fs_group_change_policy}
  */
  readonly fsGroupChangePolicy?: string;
  /**
  * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_group DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_group}
  */
  readonly runAsGroup?: number;
  /**
  * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_non_root DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_non_root}
  */
  readonly runAsNonRoot?: boolean | cdktf.IResolvable;
  /**
  * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#run_as_user DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#run_as_user}
  */
  readonly runAsUser?: number;
  /**
  * The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container. May also be set in SecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#se_linux_options DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#se_linux_options}
  */
  readonly seLinuxOptions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions;
  /**
  * The seccomp options to use by the containers in this pod. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#seccomp_profile DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#seccomp_profile}
  */
  readonly seccompProfile?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile;
  /**
  * A list of groups applied to the first process run in each container, in addition to the container's primary GID, the fsGroup (if specified), and group memberships defined in the container image for the uid of the container process. If unspecified, no additional groups are added to any container. Note that group memberships defined in the container image for the uid of the container process are still effective, even if they are not included in this list. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#supplemental_groups DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#supplemental_groups}
  */
  readonly supplementalGroups?: string[];
  /**
  * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch. Note that this field cannot be set when spec.os.name is windows.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#sysctls DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#sysctls}
  */
  readonly sysctls?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls[] | cdktf.IResolvable;
  /**
  * The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence. Note that this field cannot be set when spec.os.name is linux.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#windows_options DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#windows_options}
  */
  readonly windowsOptions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fs_group: cdktf.numberToTerraform(struct!.fsGroup),
    fs_group_change_policy: cdktf.stringToTerraform(struct!.fsGroupChangePolicy),
    run_as_group: cdktf.numberToTerraform(struct!.runAsGroup),
    run_as_non_root: cdktf.booleanToTerraform(struct!.runAsNonRoot),
    run_as_user: cdktf.numberToTerraform(struct!.runAsUser),
    se_linux_options: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptionsToTerraform(struct!.seLinuxOptions),
    seccomp_profile: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfileToTerraform(struct!.seccompProfile),
    supplemental_groups: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.supplementalGroups),
    sysctls: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsToTerraform, false)(struct!.sysctls),
    windows_options: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptionsToTerraform(struct!.windowsOptions),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fs_group: {
      value: cdktf.numberToHclTerraform(struct!.fsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    fs_group_change_policy: {
      value: cdktf.stringToHclTerraform(struct!.fsGroupChangePolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    run_as_group: {
      value: cdktf.numberToHclTerraform(struct!.runAsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    run_as_non_root: {
      value: cdktf.booleanToHclTerraform(struct!.runAsNonRoot),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    run_as_user: {
      value: cdktf.numberToHclTerraform(struct!.runAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    se_linux_options: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptionsToHclTerraform(struct!.seLinuxOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions",
    },
    seccomp_profile: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfileToHclTerraform(struct!.seccompProfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile",
    },
    supplemental_groups: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.supplementalGroups),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    sysctls: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsToHclTerraform, false)(struct!.sysctls),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsList",
    },
    windows_options: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptionsToHclTerraform(struct!.windowsOptions),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroup = this._fsGroup;
    }
    if (this._fsGroupChangePolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.fsGroupChangePolicy = this._fsGroupChangePolicy;
    }
    if (this._runAsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsGroup = this._runAsGroup;
    }
    if (this._runAsNonRoot !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsNonRoot = this._runAsNonRoot;
    }
    if (this._runAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.runAsUser = this._runAsUser;
    }
    if (this._seLinuxOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seLinuxOptions = this._seLinuxOptions?.internalValue;
    }
    if (this._seccompProfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.seccompProfile = this._seccompProfile?.internalValue;
    }
    if (this._supplementalGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.supplementalGroups = this._supplementalGroups;
    }
    if (this._sysctls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysctls = this._sysctls?.internalValue;
    }
    if (this._windowsOptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.windowsOptions = this._windowsOptions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fsGroup = undefined;
      this._fsGroupChangePolicy = undefined;
      this._runAsGroup = undefined;
      this._runAsNonRoot = undefined;
      this._runAsUser = undefined;
      this._seLinuxOptions.internalValue = undefined;
      this._seccompProfile.internalValue = undefined;
      this._supplementalGroups = undefined;
      this._sysctls.internalValue = undefined;
      this._windowsOptions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fsGroup = value.fsGroup;
      this._fsGroupChangePolicy = value.fsGroupChangePolicy;
      this._runAsGroup = value.runAsGroup;
      this._runAsNonRoot = value.runAsNonRoot;
      this._runAsUser = value.runAsUser;
      this._seLinuxOptions.internalValue = value.seLinuxOptions;
      this._seccompProfile.internalValue = value.seccompProfile;
      this._supplementalGroups = value.supplementalGroups;
      this._sysctls.internalValue = value.sysctls;
      this._windowsOptions.internalValue = value.windowsOptions;
    }
  }

  // fs_group - computed: false, optional: true, required: false
  private _fsGroup?: number; 
  public get fsGroup() {
    return this.getNumberAttribute('fs_group');
  }
  public set fsGroup(value: number) {
    this._fsGroup = value;
  }
  public resetFsGroup() {
    this._fsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupInput() {
    return this._fsGroup;
  }

  // fs_group_change_policy - computed: false, optional: true, required: false
  private _fsGroupChangePolicy?: string; 
  public get fsGroupChangePolicy() {
    return this.getStringAttribute('fs_group_change_policy');
  }
  public set fsGroupChangePolicy(value: string) {
    this._fsGroupChangePolicy = value;
  }
  public resetFsGroupChangePolicy() {
    this._fsGroupChangePolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fsGroupChangePolicyInput() {
    return this._fsGroupChangePolicy;
  }

  // run_as_group - computed: false, optional: true, required: false
  private _runAsGroup?: number; 
  public get runAsGroup() {
    return this.getNumberAttribute('run_as_group');
  }
  public set runAsGroup(value: number) {
    this._runAsGroup = value;
  }
  public resetRunAsGroup() {
    this._runAsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsGroupInput() {
    return this._runAsGroup;
  }

  // run_as_non_root - computed: false, optional: true, required: false
  private _runAsNonRoot?: boolean | cdktf.IResolvable; 
  public get runAsNonRoot() {
    return this.getBooleanAttribute('run_as_non_root');
  }
  public set runAsNonRoot(value: boolean | cdktf.IResolvable) {
    this._runAsNonRoot = value;
  }
  public resetRunAsNonRoot() {
    this._runAsNonRoot = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsNonRootInput() {
    return this._runAsNonRoot;
  }

  // run_as_user - computed: false, optional: true, required: false
  private _runAsUser?: number; 
  public get runAsUser() {
    return this.getNumberAttribute('run_as_user');
  }
  public set runAsUser(value: number) {
    this._runAsUser = value;
  }
  public resetRunAsUser() {
    this._runAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runAsUserInput() {
    return this._runAsUser;
  }

  // se_linux_options - computed: false, optional: true, required: false
  private _seLinuxOptions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptionsOutputReference(this, "se_linux_options");
  public get seLinuxOptions() {
    return this._seLinuxOptions;
  }
  public putSeLinuxOptions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeLinuxOptions) {
    this._seLinuxOptions.internalValue = value;
  }
  public resetSeLinuxOptions() {
    this._seLinuxOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seLinuxOptionsInput() {
    return this._seLinuxOptions.internalValue;
  }

  // seccomp_profile - computed: false, optional: true, required: false
  private _seccompProfile = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfileOutputReference(this, "seccomp_profile");
  public get seccompProfile() {
    return this._seccompProfile;
  }
  public putSeccompProfile(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSeccompProfile) {
    this._seccompProfile.internalValue = value;
  }
  public resetSeccompProfile() {
    this._seccompProfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get seccompProfileInput() {
    return this._seccompProfile.internalValue;
  }

  // supplemental_groups - computed: false, optional: true, required: false
  private _supplementalGroups?: string[]; 
  public get supplementalGroups() {
    return this.getListAttribute('supplemental_groups');
  }
  public set supplementalGroups(value: string[]) {
    this._supplementalGroups = value;
  }
  public resetSupplementalGroups() {
    this._supplementalGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get supplementalGroupsInput() {
    return this._supplementalGroups;
  }

  // sysctls - computed: false, optional: true, required: false
  private _sysctls = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctlsList(this, "sysctls", false);
  public get sysctls() {
    return this._sysctls;
  }
  public putSysctls(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextSysctls[] | cdktf.IResolvable) {
    this._sysctls.internalValue = value;
  }
  public resetSysctls() {
    this._sysctls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysctlsInput() {
    return this._sysctls.internalValue;
  }

  // windows_options - computed: false, optional: true, required: false
  private _windowsOptions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptionsOutputReference(this, "windows_options");
  public get windowsOptions() {
    return this._windowsOptions;
  }
  public putWindowsOptions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextWindowsOptions) {
    this._windowsOptions.internalValue = value;
  }
  public resetWindowsOptions() {
    this._windowsOptions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get windowsOptionsInput() {
    return this._windowsOptions.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#claims DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#limits DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#requests DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#effect DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#toleration_seconds DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#values DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_expressions DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints {
  /**
  * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#label_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector;
  /**
  * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#match_label_keys DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#match_label_keys}
  */
  readonly matchLabelKeys?: string[];
  /**
  * MaxSkew describes the degree to which pods may be unevenly distributed. When 'whenUnsatisfiable=DoNotSchedule', it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | | P P | P P | P | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When 'whenUnsatisfiable=ScheduleAnyway', it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#max_skew DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#max_skew}
  */
  readonly maxSkew: number;
  /**
  * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats 'global minimum' as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule. For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P | The number of domains is less than 5(MinDomains), so 'global minimum' is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew. This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#min_domains DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#min_domains}
  */
  readonly minDomains?: number;
  /**
  * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations. If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_affinity_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_affinity_policy}
  */
  readonly nodeAffinityPolicy?: string;
  /**
  * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included. If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_taints_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_taints_policy}
  */
  readonly nodeTaintsPolicy?: string;
  /**
  * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a 'bucket', and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is 'kubernetes.io/hostname', each Node is a domain of that topology. And, if TopologyKey is 'topology.kubernetes.io/zone', each zone is a domain of that topology. It's a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_key}
  */
  readonly topologyKey: string;
  /**
  * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered 'Unsatisfiable' for an incoming pod if and only if every possible node assignment for that pod would violate 'MaxSkew' on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#when_unsatisfiable DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#when_unsatisfiable}
  */
  readonly whenUnsatisfiable: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorToTerraform(struct!.labelSelector),
    match_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchLabelKeys),
    max_skew: cdktf.numberToTerraform(struct!.maxSkew),
    min_domains: cdktf.numberToTerraform(struct!.minDomains),
    node_affinity_policy: cdktf.stringToTerraform(struct!.nodeAffinityPolicy),
    node_taints_policy: cdktf.stringToTerraform(struct!.nodeTaintsPolicy),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    when_unsatisfiable: cdktf.stringToTerraform(struct!.whenUnsatisfiable),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector",
    },
    match_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_skew: {
      value: cdktf.numberToHclTerraform(struct!.maxSkew),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_domains: {
      value: cdktf.numberToHclTerraform(struct!.minDomains),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    node_affinity_policy: {
      value: cdktf.stringToHclTerraform(struct!.nodeAffinityPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_taints_policy: {
      value: cdktf.stringToHclTerraform(struct!.nodeTaintsPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    when_unsatisfiable: {
      value: cdktf.stringToHclTerraform(struct!.whenUnsatisfiable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._matchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabelKeys = this._matchLabelKeys;
    }
    if (this._maxSkew !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSkew = this._maxSkew;
    }
    if (this._minDomains !== undefined) {
      hasAnyValues = true;
      internalValueResult.minDomains = this._minDomains;
    }
    if (this._nodeAffinityPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinityPolicy = this._nodeAffinityPolicy;
    }
    if (this._nodeTaintsPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeTaintsPolicy = this._nodeTaintsPolicy;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._whenUnsatisfiable !== undefined) {
      hasAnyValues = true;
      internalValueResult.whenUnsatisfiable = this._whenUnsatisfiable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._matchLabelKeys = undefined;
      this._maxSkew = undefined;
      this._minDomains = undefined;
      this._nodeAffinityPolicy = undefined;
      this._nodeTaintsPolicy = undefined;
      this._topologyKey = undefined;
      this._whenUnsatisfiable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._matchLabelKeys = value.matchLabelKeys;
      this._maxSkew = value.maxSkew;
      this._minDomains = value.minDomains;
      this._nodeAffinityPolicy = value.nodeAffinityPolicy;
      this._nodeTaintsPolicy = value.nodeTaintsPolicy;
      this._topologyKey = value.topologyKey;
      this._whenUnsatisfiable = value.whenUnsatisfiable;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // match_label_keys - computed: false, optional: true, required: false
  private _matchLabelKeys?: string[]; 
  public get matchLabelKeys() {
    return this.getListAttribute('match_label_keys');
  }
  public set matchLabelKeys(value: string[]) {
    this._matchLabelKeys = value;
  }
  public resetMatchLabelKeys() {
    this._matchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelKeysInput() {
    return this._matchLabelKeys;
  }

  // max_skew - computed: false, optional: false, required: true
  private _maxSkew?: number; 
  public get maxSkew() {
    return this.getNumberAttribute('max_skew');
  }
  public set maxSkew(value: number) {
    this._maxSkew = value;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSkewInput() {
    return this._maxSkew;
  }

  // min_domains - computed: false, optional: true, required: false
  private _minDomains?: number; 
  public get minDomains() {
    return this.getNumberAttribute('min_domains');
  }
  public set minDomains(value: number) {
    this._minDomains = value;
  }
  public resetMinDomains() {
    this._minDomains = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minDomainsInput() {
    return this._minDomains;
  }

  // node_affinity_policy - computed: false, optional: true, required: false
  private _nodeAffinityPolicy?: string; 
  public get nodeAffinityPolicy() {
    return this.getStringAttribute('node_affinity_policy');
  }
  public set nodeAffinityPolicy(value: string) {
    this._nodeAffinityPolicy = value;
  }
  public resetNodeAffinityPolicy() {
    this._nodeAffinityPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityPolicyInput() {
    return this._nodeAffinityPolicy;
  }

  // node_taints_policy - computed: false, optional: true, required: false
  private _nodeTaintsPolicy?: string; 
  public get nodeTaintsPolicy() {
    return this.getStringAttribute('node_taints_policy');
  }
  public set nodeTaintsPolicy(value: string) {
    this._nodeTaintsPolicy = value;
  }
  public resetNodeTaintsPolicy() {
    this._nodeTaintsPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeTaintsPolicyInput() {
    return this._nodeTaintsPolicy;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // when_unsatisfiable - computed: false, optional: false, required: true
  private _whenUnsatisfiable?: string; 
  public get whenUnsatisfiable() {
    return this.getStringAttribute('when_unsatisfiable');
  }
  public set whenUnsatisfiable(value: string) {
    this._whenUnsatisfiable = value;
  }
  // Temporarily expose input value. Use with caution.
  public get whenUnsatisfiableInput() {
    return this._whenUnsatisfiable;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig {
  /**
  * Envoy admin port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#admin_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#admin_port}
  */
  readonly adminPort?: number;
  /**
  * Affinity is a group of affinity scheduling rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#affinity DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#affinity}
  */
  readonly affinity?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity;
  /**
  * Annotations defines the annotations placed on the envoy ingress controller deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * DisruptionBudget is the pod disruption budget attached to Envoy Deployment(s)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#disruption_budget DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#disruption_budget}
  */
  readonly disruptionBudget?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget;
  /**
  * EnableHealthCheckHttp10 is a toggle for adding HTTP1.0 support to Envoy health-check, default false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#enable_health_check_http10 DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#enable_health_check_http10}
  */
  readonly enableHealthCheckHttp10?: boolean | cdktf.IResolvable;
  /**
  * Envoy command line arguments
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#envoy_command_line_args DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#envoy_command_line_args}
  */
  readonly envoyCommandLineArgs?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs;
  /**
  * Envoy health-check port
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#health_check_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#health_check_port}
  */
  readonly healthCheckPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#image DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#image}
  */
  readonly image?: string;
  /**
  * ImagePullSecrets for the envoy image pull
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#image_pull_secrets DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#image_pull_secrets}
  */
  readonly imagePullSecrets?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets[] | cdktf.IResolvable;
  /**
  * LoadBalancerIP can be used to specify an exact IP for the LoadBalancer service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#load_balancer_ip DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#load_balancer_ip}
  */
  readonly loadBalancerIp?: string;
  /**
  * If specified and supported by the platform, traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature. More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#load_balancer_source_ranges DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#load_balancer_source_ranges}
  */
  readonly loadBalancerSourceRanges?: string[];
  /**
  * NodeSelector is the node selector expression for envoy pods
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * PodSecurityContext holds pod-level security attributes and common container settings for the Envoy pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pod_security_context DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pod_security_context}
  */
  readonly podSecurityContext?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext;
  /**
  * PriorityClassName specifies the priority class name for the Envoy pod(s) If specified, the PriorityClass resource with this PriorityClassName must be created beforehand If not specified, the Envoy pods' priority is default to zero
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#priority_class_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#priority_class_name}
  */
  readonly priorityClassName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#replicas DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * ResourceRequirements describes the compute resource requirements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource_requirements DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource_requirements}
  */
  readonly resourceRequirements?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements;
  /**
  * ServiceAccountName is the name of service account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#service_account_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#service_account_name}
  */
  readonly serviceAccountName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#tolerations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#tolerations}
  */
  readonly tolerations?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#topology_spread_constraints DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#topology_spread_constraints}
  */
  readonly topologySpreadConstraints?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints[] | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    admin_port: cdktf.numberToTerraform(struct!.adminPort),
    affinity: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityToTerraform(struct!.affinity),
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    disruption_budget: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudgetToTerraform(struct!.disruptionBudget),
    enable_health_check_http10: cdktf.booleanToTerraform(struct!.enableHealthCheckHttp10),
    envoy_command_line_args: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgsToTerraform(struct!.envoyCommandLineArgs),
    health_check_port: cdktf.numberToTerraform(struct!.healthCheckPort),
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_secrets: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsToTerraform, false)(struct!.imagePullSecrets),
    load_balancer_ip: cdktf.stringToTerraform(struct!.loadBalancerIp),
    load_balancer_source_ranges: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.loadBalancerSourceRanges),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    pod_security_context: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextToTerraform(struct!.podSecurityContext),
    priority_class_name: cdktf.stringToTerraform(struct!.priorityClassName),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resource_requirements: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsToTerraform(struct!.resourceRequirements),
    service_account_name: cdktf.stringToTerraform(struct!.serviceAccountName),
    tolerations: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsToTerraform, false)(struct!.tolerations),
    topology_spread_constraints: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsToTerraform, false)(struct!.topologySpreadConstraints),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    admin_port: {
      value: cdktf.numberToHclTerraform(struct!.adminPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    affinity: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityToHclTerraform(struct!.affinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity",
    },
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    disruption_budget: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudgetToHclTerraform(struct!.disruptionBudget),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget",
    },
    enable_health_check_http10: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheckHttp10),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    envoy_command_line_args: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgsToHclTerraform(struct!.envoyCommandLineArgs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs",
    },
    health_check_port: {
      value: cdktf.numberToHclTerraform(struct!.healthCheckPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secrets: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsToHclTerraform, false)(struct!.imagePullSecrets),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsList",
    },
    load_balancer_ip: {
      value: cdktf.stringToHclTerraform(struct!.loadBalancerIp),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balancer_source_ranges: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.loadBalancerSourceRanges),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    pod_security_context: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextToHclTerraform(struct!.podSecurityContext),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext",
    },
    priority_class_name: {
      value: cdktf.stringToHclTerraform(struct!.priorityClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resource_requirements: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsToHclTerraform(struct!.resourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements",
    },
    service_account_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsList",
    },
    topology_spread_constraints: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsToHclTerraform, false)(struct!.topologySpreadConstraints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._adminPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.adminPort = this._adminPort;
    }
    if (this._affinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.affinity = this._affinity?.internalValue;
    }
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._disruptionBudget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disruptionBudget = this._disruptionBudget?.internalValue;
    }
    if (this._enableHealthCheckHttp10 !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheckHttp10 = this._enableHealthCheckHttp10;
    }
    if (this._envoyCommandLineArgs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyCommandLineArgs = this._envoyCommandLineArgs?.internalValue;
    }
    if (this._healthCheckPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.healthCheckPort = this._healthCheckPort;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullSecrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecrets = this._imagePullSecrets?.internalValue;
    }
    if (this._loadBalancerIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerIp = this._loadBalancerIp;
    }
    if (this._loadBalancerSourceRanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSourceRanges = this._loadBalancerSourceRanges;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._podSecurityContext?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podSecurityContext = this._podSecurityContext?.internalValue;
    }
    if (this._priorityClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.priorityClassName = this._priorityClassName;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceRequirements = this._resourceRequirements?.internalValue;
    }
    if (this._serviceAccountName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountName = this._serviceAccountName;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._topologySpreadConstraints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologySpreadConstraints = this._topologySpreadConstraints?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._adminPort = undefined;
      this._affinity.internalValue = undefined;
      this._annotations = undefined;
      this._disruptionBudget.internalValue = undefined;
      this._enableHealthCheckHttp10 = undefined;
      this._envoyCommandLineArgs.internalValue = undefined;
      this._healthCheckPort = undefined;
      this._image = undefined;
      this._imagePullSecrets.internalValue = undefined;
      this._loadBalancerIp = undefined;
      this._loadBalancerSourceRanges = undefined;
      this._nodeSelector = undefined;
      this._podSecurityContext.internalValue = undefined;
      this._priorityClassName = undefined;
      this._replicas = undefined;
      this._resourceRequirements.internalValue = undefined;
      this._serviceAccountName = undefined;
      this._tolerations.internalValue = undefined;
      this._topologySpreadConstraints.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._adminPort = value.adminPort;
      this._affinity.internalValue = value.affinity;
      this._annotations = value.annotations;
      this._disruptionBudget.internalValue = value.disruptionBudget;
      this._enableHealthCheckHttp10 = value.enableHealthCheckHttp10;
      this._envoyCommandLineArgs.internalValue = value.envoyCommandLineArgs;
      this._healthCheckPort = value.healthCheckPort;
      this._image = value.image;
      this._imagePullSecrets.internalValue = value.imagePullSecrets;
      this._loadBalancerIp = value.loadBalancerIp;
      this._loadBalancerSourceRanges = value.loadBalancerSourceRanges;
      this._nodeSelector = value.nodeSelector;
      this._podSecurityContext.internalValue = value.podSecurityContext;
      this._priorityClassName = value.priorityClassName;
      this._replicas = value.replicas;
      this._resourceRequirements.internalValue = value.resourceRequirements;
      this._serviceAccountName = value.serviceAccountName;
      this._tolerations.internalValue = value.tolerations;
      this._topologySpreadConstraints.internalValue = value.topologySpreadConstraints;
    }
  }

  // admin_port - computed: false, optional: true, required: false
  private _adminPort?: number; 
  public get adminPort() {
    return this.getNumberAttribute('admin_port');
  }
  public set adminPort(value: number) {
    this._adminPort = value;
  }
  public resetAdminPort() {
    this._adminPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get adminPortInput() {
    return this._adminPort;
  }

  // affinity - computed: false, optional: true, required: false
  private _affinity = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinityOutputReference(this, "affinity");
  public get affinity() {
    return this._affinity;
  }
  public putAffinity(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigAffinity) {
    this._affinity.internalValue = value;
  }
  public resetAffinity() {
    this._affinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affinityInput() {
    return this._affinity.internalValue;
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // disruption_budget - computed: false, optional: true, required: false
  private _disruptionBudget = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudgetOutputReference(this, "disruption_budget");
  public get disruptionBudget() {
    return this._disruptionBudget;
  }
  public putDisruptionBudget(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigDisruptionBudget) {
    this._disruptionBudget.internalValue = value;
  }
  public resetDisruptionBudget() {
    this._disruptionBudget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disruptionBudgetInput() {
    return this._disruptionBudget.internalValue;
  }

  // enable_health_check_http10 - computed: false, optional: true, required: false
  private _enableHealthCheckHttp10?: boolean | cdktf.IResolvable; 
  public get enableHealthCheckHttp10() {
    return this.getBooleanAttribute('enable_health_check_http10');
  }
  public set enableHealthCheckHttp10(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheckHttp10 = value;
  }
  public resetEnableHealthCheckHttp10() {
    this._enableHealthCheckHttp10 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckHttp10Input() {
    return this._enableHealthCheckHttp10;
  }

  // envoy_command_line_args - computed: false, optional: true, required: false
  private _envoyCommandLineArgs = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgsOutputReference(this, "envoy_command_line_args");
  public get envoyCommandLineArgs() {
    return this._envoyCommandLineArgs;
  }
  public putEnvoyCommandLineArgs(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigEnvoyCommandLineArgs) {
    this._envoyCommandLineArgs.internalValue = value;
  }
  public resetEnvoyCommandLineArgs() {
    this._envoyCommandLineArgs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyCommandLineArgsInput() {
    return this._envoyCommandLineArgs.internalValue;
  }

  // health_check_port - computed: false, optional: true, required: false
  private _healthCheckPort?: number; 
  public get healthCheckPort() {
    return this.getNumberAttribute('health_check_port');
  }
  public set healthCheckPort(value: number) {
    this._healthCheckPort = value;
  }
  public resetHealthCheckPort() {
    this._healthCheckPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get healthCheckPortInput() {
    return this._healthCheckPort;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_secrets - computed: false, optional: true, required: false
  private _imagePullSecrets = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecretsList(this, "image_pull_secrets", false);
  public get imagePullSecrets() {
    return this._imagePullSecrets;
  }
  public putImagePullSecrets(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigImagePullSecrets[] | cdktf.IResolvable) {
    this._imagePullSecrets.internalValue = value;
  }
  public resetImagePullSecrets() {
    this._imagePullSecrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretsInput() {
    return this._imagePullSecrets.internalValue;
  }

  // load_balancer_ip - computed: false, optional: true, required: false
  private _loadBalancerIp?: string; 
  public get loadBalancerIp() {
    return this.getStringAttribute('load_balancer_ip');
  }
  public set loadBalancerIp(value: string) {
    this._loadBalancerIp = value;
  }
  public resetLoadBalancerIp() {
    this._loadBalancerIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerIpInput() {
    return this._loadBalancerIp;
  }

  // load_balancer_source_ranges - computed: false, optional: true, required: false
  private _loadBalancerSourceRanges?: string[]; 
  public get loadBalancerSourceRanges() {
    return this.getListAttribute('load_balancer_source_ranges');
  }
  public set loadBalancerSourceRanges(value: string[]) {
    this._loadBalancerSourceRanges = value;
  }
  public resetLoadBalancerSourceRanges() {
    this._loadBalancerSourceRanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSourceRangesInput() {
    return this._loadBalancerSourceRanges;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // pod_security_context - computed: false, optional: true, required: false
  private _podSecurityContext = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContextOutputReference(this, "pod_security_context");
  public get podSecurityContext() {
    return this._podSecurityContext;
  }
  public putPodSecurityContext(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigPodSecurityContext) {
    this._podSecurityContext.internalValue = value;
  }
  public resetPodSecurityContext() {
    this._podSecurityContext.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podSecurityContextInput() {
    return this._podSecurityContext.internalValue;
  }

  // priority_class_name - computed: false, optional: true, required: false
  private _priorityClassName?: string; 
  public get priorityClassName() {
    return this.getStringAttribute('priority_class_name');
  }
  public set priorityClassName(value: string) {
    this._priorityClassName = value;
  }
  public resetPriorityClassName() {
    this._priorityClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityClassNameInput() {
    return this._priorityClassName;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resource_requirements - computed: false, optional: true, required: false
  private _resourceRequirements = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirementsOutputReference(this, "resource_requirements");
  public get resourceRequirements() {
    return this._resourceRequirements;
  }
  public putResourceRequirements(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigResourceRequirements) {
    this._resourceRequirements.internalValue = value;
  }
  public resetResourceRequirements() {
    this._resourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceRequirementsInput() {
    return this._resourceRequirements.internalValue;
  }

  // service_account_name - computed: false, optional: true, required: false
  private _serviceAccountName?: string; 
  public get serviceAccountName() {
    return this.getStringAttribute('service_account_name');
  }
  public set serviceAccountName(value: string) {
    this._serviceAccountName = value;
  }
  public resetServiceAccountName() {
    this._serviceAccountName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountNameInput() {
    return this._serviceAccountName;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // topology_spread_constraints - computed: false, optional: true, required: false
  private _topologySpreadConstraints = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraintsList(this, "topology_spread_constraints", false);
  public get topologySpreadConstraints() {
    return this._topologySpreadConstraints;
  }
  public putTopologySpreadConstraints(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigTopologySpreadConstraints[] | cdktf.IResolvable) {
    this._topologySpreadConstraints.internalValue = value;
  }
  public resetTopologySpreadConstraints() {
    this._topologySpreadConstraints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologySpreadConstraintsInput() {
    return this._topologySpreadConstraints.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#optional DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#api_version DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#field_path DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#container_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#divisor DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#optional DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#config_map_key_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#field_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource_field_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#secret_key_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value_from DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig {
  /**
  * REQUIRED if mode is 'MUTUAL'. The path to a file containing certificate authority certificates to use in verifying a presented client side certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ca_certificates DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ca_certificates}
  */
  readonly caCertificates?: string;
  /**
  * Optional: If specified, only support the specified cipher list. Otherwise default to the default cipher list supported by Envoy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#cipher_suites DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#cipher_suites}
  */
  readonly cipherSuites?: string[];
  /**
  * The credentialName stands for a unique identifier that can be used to identify the serverCertificate and the privateKey. The credentialName appended with suffix '-cacert' is used to identify the CaCertificates associated with this server. Gateway workloads capable of fetching credentials from a remote credential store such as Kubernetes secrets, will be configured to retrieve the serverCertificate and the privateKey using credentialName, instead of using the file system paths specified above. If using mutual TLS, gateway workload instances will retrieve the CaCertificates using credentialName-cacert. The semantics of the name are platform dependent. In Kubernetes, the default Istio supplied credential server expects the credentialName to match the name of the Kubernetes secret that holds the server certificate, the private key, and the CA certificate (if using mutual TLS). Set the 'ISTIO_META_USER_SDS' metadata variable in the gateway's proxy to enable the dynamic credential fetching feature.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#credential_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#credential_name}
  */
  readonly credentialName?: string;
  /**
  * If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#https_redirect DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#https_redirect}
  */
  readonly httpsRedirect?: boolean | cdktf.IResolvable;
  /**
  * Optional: Maximum TLS protocol version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#max_protocol_version DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#max_protocol_version}
  */
  readonly maxProtocolVersion?: string;
  /**
  * Optional: Minimum TLS protocol version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#min_protocol_version DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#min_protocol_version}
  */
  readonly minProtocolVersion?: string;
  /**
  * Optional: Indicates whether connections to this port should be secured using TLS. The value of this field determines how TLS is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#mode DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * REQUIRED if mode is 'SIMPLE' or 'MUTUAL'. The path to the file holding the server's private key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#private_key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#private_key}
  */
  readonly privateKey?: string;
  /**
  * REQUIRED if mode is 'SIMPLE' or 'MUTUAL'. The path to the file holding the server-side TLS certificate to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#server_certificate DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#server_certificate}
  */
  readonly serverCertificate?: string;
  /**
  * A list of alternate names to verify the subject identity in the certificate presented by the client.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#subject_alt_names DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#subject_alt_names}
  */
  readonly subjectAltNames?: string[];
  /**
  * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates. Both simple and colon separated formats are acceptable. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#verify_certificate_hash DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#verify_certificate_hash}
  */
  readonly verifyCertificateHash?: string[];
  /**
  * An optional list of base64-encoded SHA-256 hashes of the SKPIs of authorized client certificates. Note: When both verify_certificate_hash and verify_certificate_spki are specified, a hash matching either value will result in the certificate being accepted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#verify_certificate_spki DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#verify_certificate_spki}
  */
  readonly verifyCertificateSpki?: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_certificates: cdktf.stringToTerraform(struct!.caCertificates),
    cipher_suites: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.cipherSuites),
    credential_name: cdktf.stringToTerraform(struct!.credentialName),
    https_redirect: cdktf.booleanToTerraform(struct!.httpsRedirect),
    max_protocol_version: cdktf.stringToTerraform(struct!.maxProtocolVersion),
    min_protocol_version: cdktf.stringToTerraform(struct!.minProtocolVersion),
    mode: cdktf.stringToTerraform(struct!.mode),
    private_key: cdktf.stringToTerraform(struct!.privateKey),
    server_certificate: cdktf.stringToTerraform(struct!.serverCertificate),
    subject_alt_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.subjectAltNames),
    verify_certificate_hash: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifyCertificateHash),
    verify_certificate_spki: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.verifyCertificateSpki),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_certificates: {
      value: cdktf.stringToHclTerraform(struct!.caCertificates),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cipher_suites: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.cipherSuites),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    credential_name: {
      value: cdktf.stringToHclTerraform(struct!.credentialName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    https_redirect: {
      value: cdktf.booleanToHclTerraform(struct!.httpsRedirect),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.maxProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_protocol_version: {
      value: cdktf.stringToHclTerraform(struct!.minProtocolVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    private_key: {
      value: cdktf.stringToHclTerraform(struct!.privateKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_certificate: {
      value: cdktf.stringToHclTerraform(struct!.serverCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subject_alt_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.subjectAltNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    verify_certificate_hash: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifyCertificateHash),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    verify_certificate_spki: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.verifyCertificateSpki),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caCertificates !== undefined) {
      hasAnyValues = true;
      internalValueResult.caCertificates = this._caCertificates;
    }
    if (this._cipherSuites !== undefined) {
      hasAnyValues = true;
      internalValueResult.cipherSuites = this._cipherSuites;
    }
    if (this._credentialName !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialName = this._credentialName;
    }
    if (this._httpsRedirect !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpsRedirect = this._httpsRedirect;
    }
    if (this._maxProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProtocolVersion = this._maxProtocolVersion;
    }
    if (this._minProtocolVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minProtocolVersion = this._minProtocolVersion;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._privateKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKey = this._privateKey;
    }
    if (this._serverCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverCertificate = this._serverCertificate;
    }
    if (this._subjectAltNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.subjectAltNames = this._subjectAltNames;
    }
    if (this._verifyCertificateHash !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyCertificateHash = this._verifyCertificateHash;
    }
    if (this._verifyCertificateSpki !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyCertificateSpki = this._verifyCertificateSpki;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caCertificates = undefined;
      this._cipherSuites = undefined;
      this._credentialName = undefined;
      this._httpsRedirect = undefined;
      this._maxProtocolVersion = undefined;
      this._minProtocolVersion = undefined;
      this._mode = undefined;
      this._privateKey = undefined;
      this._serverCertificate = undefined;
      this._subjectAltNames = undefined;
      this._verifyCertificateHash = undefined;
      this._verifyCertificateSpki = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caCertificates = value.caCertificates;
      this._cipherSuites = value.cipherSuites;
      this._credentialName = value.credentialName;
      this._httpsRedirect = value.httpsRedirect;
      this._maxProtocolVersion = value.maxProtocolVersion;
      this._minProtocolVersion = value.minProtocolVersion;
      this._mode = value.mode;
      this._privateKey = value.privateKey;
      this._serverCertificate = value.serverCertificate;
      this._subjectAltNames = value.subjectAltNames;
      this._verifyCertificateHash = value.verifyCertificateHash;
      this._verifyCertificateSpki = value.verifyCertificateSpki;
    }
  }

  // ca_certificates - computed: false, optional: true, required: false
  private _caCertificates?: string; 
  public get caCertificates() {
    return this.getStringAttribute('ca_certificates');
  }
  public set caCertificates(value: string) {
    this._caCertificates = value;
  }
  public resetCaCertificates() {
    this._caCertificates = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caCertificatesInput() {
    return this._caCertificates;
  }

  // cipher_suites - computed: false, optional: true, required: false
  private _cipherSuites?: string[]; 
  public get cipherSuites() {
    return this.getListAttribute('cipher_suites');
  }
  public set cipherSuites(value: string[]) {
    this._cipherSuites = value;
  }
  public resetCipherSuites() {
    this._cipherSuites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cipherSuitesInput() {
    return this._cipherSuites;
  }

  // credential_name - computed: false, optional: true, required: false
  private _credentialName?: string; 
  public get credentialName() {
    return this.getStringAttribute('credential_name');
  }
  public set credentialName(value: string) {
    this._credentialName = value;
  }
  public resetCredentialName() {
    this._credentialName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialNameInput() {
    return this._credentialName;
  }

  // https_redirect - computed: false, optional: true, required: false
  private _httpsRedirect?: boolean | cdktf.IResolvable; 
  public get httpsRedirect() {
    return this.getBooleanAttribute('https_redirect');
  }
  public set httpsRedirect(value: boolean | cdktf.IResolvable) {
    this._httpsRedirect = value;
  }
  public resetHttpsRedirect() {
    this._httpsRedirect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpsRedirectInput() {
    return this._httpsRedirect;
  }

  // max_protocol_version - computed: false, optional: true, required: false
  private _maxProtocolVersion?: string; 
  public get maxProtocolVersion() {
    return this.getStringAttribute('max_protocol_version');
  }
  public set maxProtocolVersion(value: string) {
    this._maxProtocolVersion = value;
  }
  public resetMaxProtocolVersion() {
    this._maxProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProtocolVersionInput() {
    return this._maxProtocolVersion;
  }

  // min_protocol_version - computed: false, optional: true, required: false
  private _minProtocolVersion?: string; 
  public get minProtocolVersion() {
    return this.getStringAttribute('min_protocol_version');
  }
  public set minProtocolVersion(value: string) {
    this._minProtocolVersion = value;
  }
  public resetMinProtocolVersion() {
    this._minProtocolVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minProtocolVersionInput() {
    return this._minProtocolVersion;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // private_key - computed: false, optional: true, required: false
  private _privateKey?: string; 
  public get privateKey() {
    return this.getStringAttribute('private_key');
  }
  public set privateKey(value: string) {
    this._privateKey = value;
  }
  public resetPrivateKey() {
    this._privateKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeyInput() {
    return this._privateKey;
  }

  // server_certificate - computed: false, optional: true, required: false
  private _serverCertificate?: string; 
  public get serverCertificate() {
    return this.getStringAttribute('server_certificate');
  }
  public set serverCertificate(value: string) {
    this._serverCertificate = value;
  }
  public resetServerCertificate() {
    this._serverCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverCertificateInput() {
    return this._serverCertificate;
  }

  // subject_alt_names - computed: false, optional: true, required: false
  private _subjectAltNames?: string[]; 
  public get subjectAltNames() {
    return this.getListAttribute('subject_alt_names');
  }
  public set subjectAltNames(value: string[]) {
    this._subjectAltNames = value;
  }
  public resetSubjectAltNames() {
    this._subjectAltNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subjectAltNamesInput() {
    return this._subjectAltNames;
  }

  // verify_certificate_hash - computed: false, optional: true, required: false
  private _verifyCertificateHash?: string[]; 
  public get verifyCertificateHash() {
    return this.getListAttribute('verify_certificate_hash');
  }
  public set verifyCertificateHash(value: string[]) {
    this._verifyCertificateHash = value;
  }
  public resetVerifyCertificateHash() {
    this._verifyCertificateHash = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyCertificateHashInput() {
    return this._verifyCertificateHash;
  }

  // verify_certificate_spki - computed: false, optional: true, required: false
  private _verifyCertificateSpki?: string[]; 
  public get verifyCertificateSpki() {
    return this.getListAttribute('verify_certificate_spki');
  }
  public set verifyCertificateSpki(value: string[]) {
    this._verifyCertificateSpki = value;
  }
  public resetVerifyCertificateSpki() {
    this._verifyCertificateSpki = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyCertificateSpkiInput() {
    return this._verifyCertificateSpki;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims {
  /**
  * Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements {
  /**
  * Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container. This is an alpha field and requires enabling the DynamicResourceAllocation feature gate. This field is immutable. It can only be set for containers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#claims DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#claims}
  */
  readonly claims?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims[] | cdktf.IResolvable;
  /**
  * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#limits DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#limits}
  */
  readonly limits?: { [key: string]: string };
  /**
  * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#requests DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#requests}
  */
  readonly requests?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claims: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsToTerraform, false)(struct!.claims),
    limits: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.limits),
    requests: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.requests),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claims: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsToHclTerraform, false)(struct!.claims),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsList",
    },
    limits: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.limits),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    requests: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.requests),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claims?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claims = this._claims?.internalValue;
    }
    if (this._limits !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits;
    }
    if (this._requests !== undefined) {
      hasAnyValues = true;
      internalValueResult.requests = this._requests;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claims.internalValue = undefined;
      this._limits = undefined;
      this._requests = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claims.internalValue = value.claims;
      this._limits = value.limits;
      this._requests = value.requests;
    }
  }

  // claims - computed: false, optional: true, required: false
  private _claims = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaimsList(this, "claims", false);
  public get claims() {
    return this._claims;
  }
  public putClaims(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsClaims[] | cdktf.IResolvable) {
    this._claims.internalValue = value;
  }
  public resetClaims() {
    this._claims.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsInput() {
    return this._claims.internalValue;
  }

  // limits - computed: false, optional: true, required: false
  private _limits?: { [key: string]: string }; 
  public get limits() {
    return this.getStringMapAttribute('limits');
  }
  public set limits(value: { [key: string]: string }) {
    this._limits = value;
  }
  public resetLimits() {
    this._limits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits;
  }

  // requests - computed: false, optional: true, required: false
  private _requests?: { [key: string]: string }; 
  public get requests() {
    return this.getStringMapAttribute('requests');
  }
  public set requests(value: { [key: string]: string }) {
    this._requests = value;
  }
  public resetRequests() {
    this._requests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsInput() {
    return this._requests;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#effect DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#key DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#operator DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#toleration_seconds DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#value DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig {
  /**
  * Annotations defines the annotations placed on the istio ingress controller deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Envs allows to add additional env vars to the istio meshgateway resource
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#envs DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#envs}
  */
  readonly envs?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#gateway_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#gateway_config}
  */
  readonly gatewayConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig;
  /**
  * If specified and supported by the platform, traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature.' More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#load_balancer_source_ranges DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#load_balancer_source_ranges}
  */
  readonly loadBalancerSourceRanges?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#node_selector DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#replicas DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#replicas}
  */
  readonly replicas?: number;
  /**
  * ResourceRequirements describes the compute resource requirements.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#resource_requirements DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#resource_requirements}
  */
  readonly resourceRequirements?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#tolerations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#tolerations}
  */
  readonly tolerations?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#virtual_service_annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#virtual_service_annotations}
  */
  readonly virtualServiceAnnotations?: { [key: string]: string };
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    envs: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsToTerraform, false)(struct!.envs),
    gateway_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfigToTerraform(struct!.gatewayConfig),
    load_balancer_source_ranges: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.loadBalancerSourceRanges),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    replicas: cdktf.numberToTerraform(struct!.replicas),
    resource_requirements: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsToTerraform(struct!.resourceRequirements),
    tolerations: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsToTerraform, false)(struct!.tolerations),
    virtual_service_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.virtualServiceAnnotations),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    envs: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsToHclTerraform, false)(struct!.envs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsList",
    },
    gateway_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfigToHclTerraform(struct!.gatewayConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig",
    },
    load_balancer_source_ranges: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.loadBalancerSourceRanges),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    replicas: {
      value: cdktf.numberToHclTerraform(struct!.replicas),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    resource_requirements: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsToHclTerraform(struct!.resourceRequirements),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsList",
    },
    virtual_service_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.virtualServiceAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._envs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envs = this._envs?.internalValue;
    }
    if (this._gatewayConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayConfig = this._gatewayConfig?.internalValue;
    }
    if (this._loadBalancerSourceRanges !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalancerSourceRanges = this._loadBalancerSourceRanges;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._replicas !== undefined) {
      hasAnyValues = true;
      internalValueResult.replicas = this._replicas;
    }
    if (this._resourceRequirements?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceRequirements = this._resourceRequirements?.internalValue;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._virtualServiceAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualServiceAnnotations = this._virtualServiceAnnotations;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._envs.internalValue = undefined;
      this._gatewayConfig.internalValue = undefined;
      this._loadBalancerSourceRanges = undefined;
      this._nodeSelector = undefined;
      this._replicas = undefined;
      this._resourceRequirements.internalValue = undefined;
      this._tolerations.internalValue = undefined;
      this._virtualServiceAnnotations = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._envs.internalValue = value.envs;
      this._gatewayConfig.internalValue = value.gatewayConfig;
      this._loadBalancerSourceRanges = value.loadBalancerSourceRanges;
      this._nodeSelector = value.nodeSelector;
      this._replicas = value.replicas;
      this._resourceRequirements.internalValue = value.resourceRequirements;
      this._tolerations.internalValue = value.tolerations;
      this._virtualServiceAnnotations = value.virtualServiceAnnotations;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // envs - computed: false, optional: true, required: false
  private _envs = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvsList(this, "envs", false);
  public get envs() {
    return this._envs;
  }
  public putEnvs(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigEnvs[] | cdktf.IResolvable) {
    this._envs.internalValue = value;
  }
  public resetEnvs() {
    this._envs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envsInput() {
    return this._envs.internalValue;
  }

  // gateway_config - computed: false, optional: true, required: false
  private _gatewayConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfigOutputReference(this, "gateway_config");
  public get gatewayConfig() {
    return this._gatewayConfig;
  }
  public putGatewayConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigGatewayConfig) {
    this._gatewayConfig.internalValue = value;
  }
  public resetGatewayConfig() {
    this._gatewayConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayConfigInput() {
    return this._gatewayConfig.internalValue;
  }

  // load_balancer_source_ranges - computed: false, optional: true, required: false
  private _loadBalancerSourceRanges?: string[]; 
  public get loadBalancerSourceRanges() {
    return this.getListAttribute('load_balancer_source_ranges');
  }
  public set loadBalancerSourceRanges(value: string[]) {
    this._loadBalancerSourceRanges = value;
  }
  public resetLoadBalancerSourceRanges() {
    this._loadBalancerSourceRanges = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancerSourceRangesInput() {
    return this._loadBalancerSourceRanges;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // replicas - computed: false, optional: true, required: false
  private _replicas?: number; 
  public get replicas() {
    return this.getNumberAttribute('replicas');
  }
  public set replicas(value: number) {
    this._replicas = value;
  }
  public resetReplicas() {
    this._replicas = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get replicasInput() {
    return this._replicas;
  }

  // resource_requirements - computed: false, optional: true, required: false
  private _resourceRequirements = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirementsOutputReference(this, "resource_requirements");
  public get resourceRequirements() {
    return this._resourceRequirements;
  }
  public putResourceRequirements(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigResourceRequirements) {
    this._resourceRequirements.internalValue = value;
  }
  public resetResourceRequirements() {
    this._resourceRequirements.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceRequirementsInput() {
    return this._resourceRequirements.internalValue;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // virtual_service_annotations - computed: false, optional: true, required: false
  private _virtualServiceAnnotations?: { [key: string]: string }; 
  public get virtualServiceAnnotations() {
    return this.getStringMapAttribute('virtual_service_annotations');
  }
  public set virtualServiceAnnotations(value: { [key: string]: string }) {
    this._virtualServiceAnnotations = value;
  }
  public resetVirtualServiceAnnotations() {
    this._virtualServiceAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualServiceAnnotationsInput() {
    return this._virtualServiceAnnotations;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig {
  /**
  * EnvoyConfig defines the config for Envoy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#envoy_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#envoy_config}
  */
  readonly envoyConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig;
  /**
  * externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. 'Local' preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. 'Cluster' obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#external_traffic_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#external_traffic_policy}
  */
  readonly externalTrafficPolicy?: string;
  /**
  * In case of external listeners using LoadBalancer access method the value of this field is used to advertise the Kafka broker external listener instead of the public IP of the provisioned LoadBalancer service (e.g. can be used to advertise the listener using a URL recorded in DNS instead of public IP). In case of external listeners using NodePort access method the broker instead of node public IP (see 'brokerConfig.nodePortExternalIP') is advertised on the address having the following format: <kafka-cluster-name>-<broker-id>.<namespace><value-specified-in-hostnameOverride-field>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#hostname_override DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#hostname_override}
  */
  readonly hostnameOverride?: string;
  /**
  * IstioIngressConfig defines the config for the Istio Ingress Controller
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#istio_ingress_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#istio_ingress_config}
  */
  readonly istioIngressConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig;
  /**
  * ServiceAnnotations defines annotations which will be placed to the service or services created for the external listener
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#service_annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#service_annotations}
  */
  readonly serviceAnnotations?: { [key: string]: string };
  /**
  * Service Type string describes ingress methods for a service Only 'NodePort' and 'LoadBalancer' is supported. Default value is LoadBalancer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#service_type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#service_type}
  */
  readonly serviceType?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    envoy_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigToTerraform(struct!.envoyConfig),
    external_traffic_policy: cdktf.stringToTerraform(struct!.externalTrafficPolicy),
    hostname_override: cdktf.stringToTerraform(struct!.hostnameOverride),
    istio_ingress_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigToTerraform(struct!.istioIngressConfig),
    service_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.serviceAnnotations),
    service_type: cdktf.stringToTerraform(struct!.serviceType),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    envoy_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigToHclTerraform(struct!.envoyConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig",
    },
    external_traffic_policy: {
      value: cdktf.stringToHclTerraform(struct!.externalTrafficPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname_override: {
      value: cdktf.stringToHclTerraform(struct!.hostnameOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    istio_ingress_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigToHclTerraform(struct!.istioIngressConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig",
    },
    service_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.serviceAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service_type: {
      value: cdktf.stringToHclTerraform(struct!.serviceType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._envoyConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyConfig = this._envoyConfig?.internalValue;
    }
    if (this._externalTrafficPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalTrafficPolicy = this._externalTrafficPolicy;
    }
    if (this._hostnameOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnameOverride = this._hostnameOverride;
    }
    if (this._istioIngressConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.istioIngressConfig = this._istioIngressConfig?.internalValue;
    }
    if (this._serviceAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAnnotations = this._serviceAnnotations;
    }
    if (this._serviceType !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceType = this._serviceType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._envoyConfig.internalValue = undefined;
      this._externalTrafficPolicy = undefined;
      this._hostnameOverride = undefined;
      this._istioIngressConfig.internalValue = undefined;
      this._serviceAnnotations = undefined;
      this._serviceType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._envoyConfig.internalValue = value.envoyConfig;
      this._externalTrafficPolicy = value.externalTrafficPolicy;
      this._hostnameOverride = value.hostnameOverride;
      this._istioIngressConfig.internalValue = value.istioIngressConfig;
      this._serviceAnnotations = value.serviceAnnotations;
      this._serviceType = value.serviceType;
    }
  }

  // envoy_config - computed: false, optional: true, required: false
  private _envoyConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfigOutputReference(this, "envoy_config");
  public get envoyConfig() {
    return this._envoyConfig;
  }
  public putEnvoyConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigEnvoyConfig) {
    this._envoyConfig.internalValue = value;
  }
  public resetEnvoyConfig() {
    this._envoyConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyConfigInput() {
    return this._envoyConfig.internalValue;
  }

  // external_traffic_policy - computed: false, optional: true, required: false
  private _externalTrafficPolicy?: string; 
  public get externalTrafficPolicy() {
    return this.getStringAttribute('external_traffic_policy');
  }
  public set externalTrafficPolicy(value: string) {
    this._externalTrafficPolicy = value;
  }
  public resetExternalTrafficPolicy() {
    this._externalTrafficPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalTrafficPolicyInput() {
    return this._externalTrafficPolicy;
  }

  // hostname_override - computed: false, optional: true, required: false
  private _hostnameOverride?: string; 
  public get hostnameOverride() {
    return this.getStringAttribute('hostname_override');
  }
  public set hostnameOverride(value: string) {
    this._hostnameOverride = value;
  }
  public resetHostnameOverride() {
    this._hostnameOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameOverrideInput() {
    return this._hostnameOverride;
  }

  // istio_ingress_config - computed: false, optional: true, required: false
  private _istioIngressConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfigOutputReference(this, "istio_ingress_config");
  public get istioIngressConfig() {
    return this._istioIngressConfig;
  }
  public putIstioIngressConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigIstioIngressConfig) {
    this._istioIngressConfig.internalValue = value;
  }
  public resetIstioIngressConfig() {
    this._istioIngressConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get istioIngressConfigInput() {
    return this._istioIngressConfig.internalValue;
  }

  // service_annotations - computed: false, optional: true, required: false
  private _serviceAnnotations?: { [key: string]: string }; 
  public get serviceAnnotations() {
    return this.getStringMapAttribute('service_annotations');
  }
  public set serviceAnnotations(value: { [key: string]: string }) {
    this._serviceAnnotations = value;
  }
  public resetServiceAnnotations() {
    this._serviceAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAnnotationsInput() {
    return this._serviceAnnotations;
  }

  // service_type - computed: false, optional: true, required: false
  private _serviceType?: string; 
  public get serviceType() {
    return this.getStringAttribute('service_type');
  }
  public set serviceType(value: string) {
    this._serviceType = value;
  }
  public resetServiceType() {
    this._serviceType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceTypeInput() {
    return this._serviceType;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#default_ingress_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#default_ingress_config}
  */
  readonly defaultIngressConfig: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ingress_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ingress_config}
  */
  readonly ingressConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_ingress_config: cdktf.stringToTerraform(struct!.defaultIngressConfig),
    ingress_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigToTerraform(struct!.ingressConfig),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_ingress_config: {
      value: cdktf.stringToHclTerraform(struct!.defaultIngressConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigToHclTerraform(struct!.ingressConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultIngressConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultIngressConfig = this._defaultIngressConfig;
    }
    if (this._ingressConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressConfig = this._ingressConfig?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultIngressConfig = undefined;
      this._ingressConfig.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultIngressConfig = value.defaultIngressConfig;
      this._ingressConfig.internalValue = value.ingressConfig;
    }
  }

  // default_ingress_config - computed: false, optional: false, required: true
  private _defaultIngressConfig?: string; 
  public get defaultIngressConfig() {
    return this.getStringAttribute('default_ingress_config');
  }
  public set defaultIngressConfig(value: string) {
    this._defaultIngressConfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultIngressConfigInput() {
    return this._defaultIngressConfig;
  }

  // ingress_config - computed: false, optional: true, required: false
  private _ingressConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfigOutputReference(this, "ingress_config");
  public get ingressConfig() {
    return this._ingressConfig;
  }
  public putIngressConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigIngressConfig) {
    this._ingressConfig.internalValue = value;
  }
  public resetIngressConfig() {
    this._ingressConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressConfigInput() {
    return this._ingressConfig.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret {
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecretToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecretToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners {
  /**
  * accessMethod defines the method which the external listener is exposed through. Two types are supported LoadBalancer and NodePort. The recommended and default is the LoadBalancer. NodePort should be used in Kubernetes environments with no support for provisioning Load Balancers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#access_method DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#access_method}
  */
  readonly accessMethod?: string;
  /**
  * configuring AnyCastPort allows kafka cluster access without specifying the exact broker If not defined, 29092 will be used for external clients to reach the kafka cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#any_cast_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#any_cast_port}
  */
  readonly anyCastPort?: number;
  /**
  * Config allows to specify ingress controller configuration per external listener if set, it overrides the default 'KafkaClusterSpec.IstioIngressConfig' or 'KafkaClusterSpec.EnvoyConfig' for this external listener.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#config}
  */
  readonly config?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#container_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#container_port}
  */
  readonly containerPort: number;
  /**
  * externalStartingPort is added to each broker ID to get the port number that will be used for external access to the broker. The choice of broker ID and externalStartingPort must satisfy 0 < broker ID + externalStartingPort <= 65535 If accessMethod is Nodeport and externalStartingPort is set to 0 then the broker IDs are not added and the Nodeport port numbers will be chosen automatically by the K8s Service controller
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#external_starting_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#external_starting_port}
  */
  readonly externalStartingPort: number;
  /**
  * externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. 'Local' preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. 'Cluster' obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#external_traffic_policy DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#external_traffic_policy}
  */
  readonly externalTrafficPolicy?: string;
  /**
  * In case of external listeners using LoadBalancer access method the value of this field is used to advertise the Kafka broker external listener instead of the public IP of the provisioned LoadBalancer service (e.g. can be used to advertise the listener using a URL recorded in DNS instead of public IP). In case of external listeners using NodePort access method the broker instead of node public IP (see 'brokerConfig.nodePortExternalIP') is advertised on the address having the following format: <kafka-cluster-name>-<broker-id>.<namespace><value-specified-in-hostnameOverride-field>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#hostname_override DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#hostname_override}
  */
  readonly hostnameOverride?: string;
  /**
  * IngressControllerTargetPort defines the container port that the ingress controller uses for handling external traffic. If not defined, 29092 will be used as the default IngressControllerTargetPort value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ingress_controller_target_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ingress_controller_target_port}
  */
  readonly ingressControllerTargetPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * ServerSSLCertSecret is a reference to the Kubernetes secret that contains the server certificate for the listener to be used for SSL communication. The secret must contain the keystore, truststore jks files and the password for them in base64 encoded format under the keystore.jks, truststore.jks, password data fields. If this field is omitted koperator will auto-create a self-signed server certificate using the configuration provided in 'sslSecrets' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#server_ssl_cert_secret DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#server_ssl_cert_secret}
  */
  readonly serverSslCertSecret?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret;
  /**
  * ServiceAnnotations defines annotations which will be placed to the service or services created for the external listener
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#service_annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#service_annotations}
  */
  readonly serviceAnnotations?: { [key: string]: string };
  /**
  * Service Type string describes ingress methods for a service Only 'NodePort' and 'LoadBalancer' is supported. Default value is LoadBalancer
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#service_type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#service_type}
  */
  readonly serviceType?: string;
  /**
  * SSLClientAuth specifies whether client authentication is required, requested, or not required. This field defaults to 'required' if it is omitted
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ssl_client_auth DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ssl_client_auth}
  */
  readonly sslClientAuth?: string;
  /**
  * SecurityProtocol is the protocol used to communicate with brokers. Valid values are: plaintext, ssl, sasl_plaintext, sasl_ssl.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_method: cdktf.stringToTerraform(struct!.accessMethod),
    any_cast_port: cdktf.numberToTerraform(struct!.anyCastPort),
    config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigToTerraform(struct!.config),
    container_port: cdktf.numberToTerraform(struct!.containerPort),
    external_starting_port: cdktf.numberToTerraform(struct!.externalStartingPort),
    external_traffic_policy: cdktf.stringToTerraform(struct!.externalTrafficPolicy),
    hostname_override: cdktf.stringToTerraform(struct!.hostnameOverride),
    ingress_controller_target_port: cdktf.numberToTerraform(struct!.ingressControllerTargetPort),
    name: cdktf.stringToTerraform(struct!.name),
    server_ssl_cert_secret: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecretToTerraform(struct!.serverSslCertSecret),
    service_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.serviceAnnotations),
    service_type: cdktf.stringToTerraform(struct!.serviceType),
    ssl_client_auth: cdktf.stringToTerraform(struct!.sslClientAuth),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_method: {
      value: cdktf.stringToHclTerraform(struct!.accessMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    any_cast_port: {
      value: cdktf.numberToHclTerraform(struct!.anyCastPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigToHclTerraform(struct!.config),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig",
    },
    container_port: {
      value: cdktf.numberToHclTerraform(struct!.containerPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    external_starting_port: {
      value: cdktf.numberToHclTerraform(struct!.externalStartingPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    external_traffic_policy: {
      value: cdktf.stringToHclTerraform(struct!.externalTrafficPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname_override: {
      value: cdktf.stringToHclTerraform(struct!.hostnameOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_controller_target_port: {
      value: cdktf.numberToHclTerraform(struct!.ingressControllerTargetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_ssl_cert_secret: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecretToHclTerraform(struct!.serverSslCertSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret",
    },
    service_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.serviceAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service_type: {
      value: cdktf.stringToHclTerraform(struct!.serviceType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ssl_client_auth: {
      value: cdktf.stringToHclTerraform(struct!.sslClientAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessMethod = this._accessMethod;
    }
    if (this._anyCastPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.anyCastPort = this._anyCastPort;
    }
    if (this._config?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config?.internalValue;
    }
    if (this._containerPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerPort = this._containerPort;
    }
    if (this._externalStartingPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalStartingPort = this._externalStartingPort;
    }
    if (this._externalTrafficPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalTrafficPolicy = this._externalTrafficPolicy;
    }
    if (this._hostnameOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostnameOverride = this._hostnameOverride;
    }
    if (this._ingressControllerTargetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressControllerTargetPort = this._ingressControllerTargetPort;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._serverSslCertSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSslCertSecret = this._serverSslCertSecret?.internalValue;
    }
    if (this._serviceAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAnnotations = this._serviceAnnotations;
    }
    if (this._serviceType !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceType = this._serviceType;
    }
    if (this._sslClientAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslClientAuth = this._sslClientAuth;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessMethod = undefined;
      this._anyCastPort = undefined;
      this._config.internalValue = undefined;
      this._containerPort = undefined;
      this._externalStartingPort = undefined;
      this._externalTrafficPolicy = undefined;
      this._hostnameOverride = undefined;
      this._ingressControllerTargetPort = undefined;
      this._name = undefined;
      this._serverSslCertSecret.internalValue = undefined;
      this._serviceAnnotations = undefined;
      this._serviceType = undefined;
      this._sslClientAuth = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessMethod = value.accessMethod;
      this._anyCastPort = value.anyCastPort;
      this._config.internalValue = value.config;
      this._containerPort = value.containerPort;
      this._externalStartingPort = value.externalStartingPort;
      this._externalTrafficPolicy = value.externalTrafficPolicy;
      this._hostnameOverride = value.hostnameOverride;
      this._ingressControllerTargetPort = value.ingressControllerTargetPort;
      this._name = value.name;
      this._serverSslCertSecret.internalValue = value.serverSslCertSecret;
      this._serviceAnnotations = value.serviceAnnotations;
      this._serviceType = value.serviceType;
      this._sslClientAuth = value.sslClientAuth;
      this._type = value.type;
    }
  }

  // access_method - computed: false, optional: true, required: false
  private _accessMethod?: string; 
  public get accessMethod() {
    return this.getStringAttribute('access_method');
  }
  public set accessMethod(value: string) {
    this._accessMethod = value;
  }
  public resetAccessMethod() {
    this._accessMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessMethodInput() {
    return this._accessMethod;
  }

  // any_cast_port - computed: false, optional: true, required: false
  private _anyCastPort?: number; 
  public get anyCastPort() {
    return this.getNumberAttribute('any_cast_port');
  }
  public set anyCastPort(value: number) {
    this._anyCastPort = value;
  }
  public resetAnyCastPort() {
    this._anyCastPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anyCastPortInput() {
    return this._anyCastPort;
  }

  // config - computed: false, optional: true, required: false
  private _config = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfigOutputReference(this, "config");
  public get config() {
    return this._config;
  }
  public putConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersConfig) {
    this._config.internalValue = value;
  }
  public resetConfig() {
    this._config.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config.internalValue;
  }

  // container_port - computed: false, optional: false, required: true
  private _containerPort?: number; 
  public get containerPort() {
    return this.getNumberAttribute('container_port');
  }
  public set containerPort(value: number) {
    this._containerPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get containerPortInput() {
    return this._containerPort;
  }

  // external_starting_port - computed: false, optional: false, required: true
  private _externalStartingPort?: number; 
  public get externalStartingPort() {
    return this.getNumberAttribute('external_starting_port');
  }
  public set externalStartingPort(value: number) {
    this._externalStartingPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get externalStartingPortInput() {
    return this._externalStartingPort;
  }

  // external_traffic_policy - computed: false, optional: true, required: false
  private _externalTrafficPolicy?: string; 
  public get externalTrafficPolicy() {
    return this.getStringAttribute('external_traffic_policy');
  }
  public set externalTrafficPolicy(value: string) {
    this._externalTrafficPolicy = value;
  }
  public resetExternalTrafficPolicy() {
    this._externalTrafficPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalTrafficPolicyInput() {
    return this._externalTrafficPolicy;
  }

  // hostname_override - computed: false, optional: true, required: false
  private _hostnameOverride?: string; 
  public get hostnameOverride() {
    return this.getStringAttribute('hostname_override');
  }
  public set hostnameOverride(value: string) {
    this._hostnameOverride = value;
  }
  public resetHostnameOverride() {
    this._hostnameOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameOverrideInput() {
    return this._hostnameOverride;
  }

  // ingress_controller_target_port - computed: false, optional: true, required: false
  private _ingressControllerTargetPort?: number; 
  public get ingressControllerTargetPort() {
    return this.getNumberAttribute('ingress_controller_target_port');
  }
  public set ingressControllerTargetPort(value: number) {
    this._ingressControllerTargetPort = value;
  }
  public resetIngressControllerTargetPort() {
    this._ingressControllerTargetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressControllerTargetPortInput() {
    return this._ingressControllerTargetPort;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // server_ssl_cert_secret - computed: false, optional: true, required: false
  private _serverSslCertSecret = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecretOutputReference(this, "server_ssl_cert_secret");
  public get serverSslCertSecret() {
    return this._serverSslCertSecret;
  }
  public putServerSslCertSecret(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersServerSslCertSecret) {
    this._serverSslCertSecret.internalValue = value;
  }
  public resetServerSslCertSecret() {
    this._serverSslCertSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSslCertSecretInput() {
    return this._serverSslCertSecret.internalValue;
  }

  // service_annotations - computed: false, optional: true, required: false
  private _serviceAnnotations?: { [key: string]: string }; 
  public get serviceAnnotations() {
    return this.getStringMapAttribute('service_annotations');
  }
  public set serviceAnnotations(value: { [key: string]: string }) {
    this._serviceAnnotations = value;
  }
  public resetServiceAnnotations() {
    this._serviceAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAnnotationsInput() {
    return this._serviceAnnotations;
  }

  // service_type - computed: false, optional: true, required: false
  private _serviceType?: string; 
  public get serviceType() {
    return this.getStringAttribute('service_type');
  }
  public set serviceType(value: string) {
    this._serviceType = value;
  }
  public resetServiceType() {
    this._serviceType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceTypeInput() {
    return this._serviceType;
  }

  // ssl_client_auth - computed: false, optional: true, required: false
  private _sslClientAuth?: string; 
  public get sslClientAuth() {
    return this.getStringAttribute('ssl_client_auth');
  }
  public set sslClientAuth(value: string) {
    this._sslClientAuth = value;
  }
  public resetSslClientAuth() {
    this._sslClientAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslClientAuthInput() {
    return this._sslClientAuth;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret {
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecretToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecretToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#container_port DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#container_port}
  */
  readonly containerPort: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * ServerSSLCertSecret is a reference to the Kubernetes secret that contains the server certificate for the listener to be used for SSL communication. The secret must contain the keystore, truststore jks files and the password for them in base64 encoded format under the keystore.jks, truststore.jks, password data fields. If this field is omitted koperator will auto-create a self-signed server certificate using the configuration provided in 'sslSecrets' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#server_ssl_cert_secret DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#server_ssl_cert_secret}
  */
  readonly serverSslCertSecret?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret;
  /**
  * SSLClientAuth specifies whether client authentication is required, requested, or not required. This field defaults to 'required' if it is omitted
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ssl_client_auth DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ssl_client_auth}
  */
  readonly sslClientAuth?: string;
  /**
  * SecurityProtocol is the protocol used to communicate with brokers. Valid values are: plaintext, ssl, sasl_plaintext, sasl_ssl.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#type DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#type}
  */
  readonly type: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#used_for_controller_communication DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#used_for_controller_communication}
  */
  readonly usedForControllerCommunication?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#used_for_inner_broker_communication DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#used_for_inner_broker_communication}
  */
  readonly usedForInnerBrokerCommunication: boolean | cdktf.IResolvable;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_port: cdktf.numberToTerraform(struct!.containerPort),
    name: cdktf.stringToTerraform(struct!.name),
    server_ssl_cert_secret: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecretToTerraform(struct!.serverSslCertSecret),
    ssl_client_auth: cdktf.stringToTerraform(struct!.sslClientAuth),
    type: cdktf.stringToTerraform(struct!.type),
    used_for_controller_communication: cdktf.booleanToTerraform(struct!.usedForControllerCommunication),
    used_for_inner_broker_communication: cdktf.booleanToTerraform(struct!.usedForInnerBrokerCommunication),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_port: {
      value: cdktf.numberToHclTerraform(struct!.containerPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_ssl_cert_secret: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecretToHclTerraform(struct!.serverSslCertSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret",
    },
    ssl_client_auth: {
      value: cdktf.stringToHclTerraform(struct!.sslClientAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    used_for_controller_communication: {
      value: cdktf.booleanToHclTerraform(struct!.usedForControllerCommunication),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    used_for_inner_broker_communication: {
      value: cdktf.booleanToHclTerraform(struct!.usedForInnerBrokerCommunication),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerPort = this._containerPort;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._serverSslCertSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSslCertSecret = this._serverSslCertSecret?.internalValue;
    }
    if (this._sslClientAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslClientAuth = this._sslClientAuth;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._usedForControllerCommunication !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedForControllerCommunication = this._usedForControllerCommunication;
    }
    if (this._usedForInnerBrokerCommunication !== undefined) {
      hasAnyValues = true;
      internalValueResult.usedForInnerBrokerCommunication = this._usedForInnerBrokerCommunication;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerPort = undefined;
      this._name = undefined;
      this._serverSslCertSecret.internalValue = undefined;
      this._sslClientAuth = undefined;
      this._type = undefined;
      this._usedForControllerCommunication = undefined;
      this._usedForInnerBrokerCommunication = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerPort = value.containerPort;
      this._name = value.name;
      this._serverSslCertSecret.internalValue = value.serverSslCertSecret;
      this._sslClientAuth = value.sslClientAuth;
      this._type = value.type;
      this._usedForControllerCommunication = value.usedForControllerCommunication;
      this._usedForInnerBrokerCommunication = value.usedForInnerBrokerCommunication;
    }
  }

  // container_port - computed: false, optional: false, required: true
  private _containerPort?: number; 
  public get containerPort() {
    return this.getNumberAttribute('container_port');
  }
  public set containerPort(value: number) {
    this._containerPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get containerPortInput() {
    return this._containerPort;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // server_ssl_cert_secret - computed: false, optional: true, required: false
  private _serverSslCertSecret = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecretOutputReference(this, "server_ssl_cert_secret");
  public get serverSslCertSecret() {
    return this._serverSslCertSecret;
  }
  public putServerSslCertSecret(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersServerSslCertSecret) {
    this._serverSslCertSecret.internalValue = value;
  }
  public resetServerSslCertSecret() {
    this._serverSslCertSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSslCertSecretInput() {
    return this._serverSslCertSecret.internalValue;
  }

  // ssl_client_auth - computed: false, optional: true, required: false
  private _sslClientAuth?: string; 
  public get sslClientAuth() {
    return this.getStringAttribute('ssl_client_auth');
  }
  public set sslClientAuth(value: string) {
    this._sslClientAuth = value;
  }
  public resetSslClientAuth() {
    this._sslClientAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslClientAuthInput() {
    return this._sslClientAuth;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // used_for_controller_communication - computed: false, optional: true, required: false
  private _usedForControllerCommunication?: boolean | cdktf.IResolvable; 
  public get usedForControllerCommunication() {
    return this.getBooleanAttribute('used_for_controller_communication');
  }
  public set usedForControllerCommunication(value: boolean | cdktf.IResolvable) {
    this._usedForControllerCommunication = value;
  }
  public resetUsedForControllerCommunication() {
    this._usedForControllerCommunication = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usedForControllerCommunicationInput() {
    return this._usedForControllerCommunication;
  }

  // used_for_inner_broker_communication - computed: false, optional: false, required: true
  private _usedForInnerBrokerCommunication?: boolean | cdktf.IResolvable; 
  public get usedForInnerBrokerCommunication() {
    return this.getBooleanAttribute('used_for_inner_broker_communication');
  }
  public set usedForInnerBrokerCommunication(value: boolean | cdktf.IResolvable) {
    this._usedForInnerBrokerCommunication = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usedForInnerBrokerCommunicationInput() {
    return this._usedForInnerBrokerCommunication;
  }
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersList extends cdktf.ComplexList {
  public internalValue? : DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersOutputReference {
    return new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef {
  /**
  * Group of the resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#group DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#group}
  */
  readonly group?: string;
  /**
  * Kind of the resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#kind DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#kind}
  */
  readonly kind?: string;
  /**
  * Name of the resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRefToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    group: cdktf.stringToTerraform(struct!.group),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRefToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    group: {
      value: cdktf.stringToHclTerraform(struct!.group),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._group !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._group = undefined;
      this._kind = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._group = value.group;
      this._kind = value.kind;
      this._name = value.name;
    }
  }

  // group - computed: false, optional: true, required: false
  private _group?: string; 
  public get group() {
    return this.getStringAttribute('group');
  }
  public set group(value: string) {
    this._group = value;
  }
  public resetGroup() {
    this._group = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#create DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#create}
  */
  readonly create?: boolean | cdktf.IResolvable;
  /**
  * ObjectReference is a reference to an object with a given name, kind and group.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#issuer_ref DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#issuer_ref}
  */
  readonly issuerRef?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#jks_password_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#jks_password_name}
  */
  readonly jksPasswordName?: string;
  /**
  * PKIBackend represents an interface implementing the PKIManager
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#pki_backend DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#pki_backend}
  */
  readonly pkiBackend?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#tls_secret_name DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#tls_secret_name}
  */
  readonly tlsSecretName: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    create: cdktf.booleanToTerraform(struct!.create),
    issuer_ref: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRefToTerraform(struct!.issuerRef),
    jks_password_name: cdktf.stringToTerraform(struct!.jksPasswordName),
    pki_backend: cdktf.stringToTerraform(struct!.pkiBackend),
    tls_secret_name: cdktf.stringToTerraform(struct!.tlsSecretName),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    create: {
      value: cdktf.booleanToHclTerraform(struct!.create),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    issuer_ref: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRefToHclTerraform(struct!.issuerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef",
    },
    jks_password_name: {
      value: cdktf.stringToHclTerraform(struct!.jksPasswordName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pki_backend: {
      value: cdktf.stringToHclTerraform(struct!.pkiBackend),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.tlsSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._create !== undefined) {
      hasAnyValues = true;
      internalValueResult.create = this._create;
    }
    if (this._issuerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuerRef = this._issuerRef?.internalValue;
    }
    if (this._jksPasswordName !== undefined) {
      hasAnyValues = true;
      internalValueResult.jksPasswordName = this._jksPasswordName;
    }
    if (this._pkiBackend !== undefined) {
      hasAnyValues = true;
      internalValueResult.pkiBackend = this._pkiBackend;
    }
    if (this._tlsSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSecretName = this._tlsSecretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._create = undefined;
      this._issuerRef.internalValue = undefined;
      this._jksPasswordName = undefined;
      this._pkiBackend = undefined;
      this._tlsSecretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._create = value.create;
      this._issuerRef.internalValue = value.issuerRef;
      this._jksPasswordName = value.jksPasswordName;
      this._pkiBackend = value.pkiBackend;
      this._tlsSecretName = value.tlsSecretName;
    }
  }

  // create - computed: false, optional: true, required: false
  private _create?: boolean | cdktf.IResolvable; 
  public get create() {
    return this.getBooleanAttribute('create');
  }
  public set create(value: boolean | cdktf.IResolvable) {
    this._create = value;
  }
  public resetCreate() {
    this._create = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createInput() {
    return this._create;
  }

  // issuer_ref - computed: false, optional: true, required: false
  private _issuerRef = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRefOutputReference(this, "issuer_ref");
  public get issuerRef() {
    return this._issuerRef;
  }
  public putIssuerRef(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsIssuerRef) {
    this._issuerRef.internalValue = value;
  }
  public resetIssuerRef() {
    this._issuerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerRefInput() {
    return this._issuerRef.internalValue;
  }

  // jks_password_name - computed: false, optional: true, required: false
  private _jksPasswordName?: string; 
  public get jksPasswordName() {
    return this.getStringAttribute('jks_password_name');
  }
  public set jksPasswordName(value: string) {
    this._jksPasswordName = value;
  }
  public resetJksPasswordName() {
    this._jksPasswordName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jksPasswordNameInput() {
    return this._jksPasswordName;
  }

  // pki_backend - computed: false, optional: true, required: false
  private _pkiBackend?: string; 
  public get pkiBackend() {
    return this.getStringAttribute('pki_backend');
  }
  public set pkiBackend(value: string) {
    this._pkiBackend = value;
  }
  public resetPkiBackend() {
    this._pkiBackend = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pkiBackendInput() {
    return this._pkiBackend;
  }

  // tls_secret_name - computed: false, optional: false, required: true
  private _tlsSecretName?: string; 
  public get tlsSecretName() {
    return this.getStringAttribute('tls_secret_name');
  }
  public set tlsSecretName(value: string) {
    this._tlsSecretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSecretNameInput() {
    return this._tlsSecretName;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#external_listeners DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#external_listeners}
  */
  readonly externalListeners?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#internal_listeners DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#internal_listeners}
  */
  readonly internalListeners: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#service_annotations DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#service_annotations}
  */
  readonly serviceAnnotations?: { [key: string]: string };
  /**
  * SSLSecrets defines the Kafka SSL secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ssl_secrets DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ssl_secrets}
  */
  readonly sslSecrets?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_listeners: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersToTerraform, false)(struct!.externalListeners),
    internal_listeners: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersToTerraform, false)(struct!.internalListeners),
    service_annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.serviceAnnotations),
    ssl_secrets: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsToTerraform(struct!.sslSecrets),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_listeners: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersToHclTerraform, false)(struct!.externalListeners),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersList",
    },
    internal_listeners: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersToHclTerraform, false)(struct!.internalListeners),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersList",
    },
    service_annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.serviceAnnotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    ssl_secrets: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsToHclTerraform(struct!.sslSecrets),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalListeners?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalListeners = this._externalListeners?.internalValue;
    }
    if (this._internalListeners?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.internalListeners = this._internalListeners?.internalValue;
    }
    if (this._serviceAnnotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAnnotations = this._serviceAnnotations;
    }
    if (this._sslSecrets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sslSecrets = this._sslSecrets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalListeners.internalValue = undefined;
      this._internalListeners.internalValue = undefined;
      this._serviceAnnotations = undefined;
      this._sslSecrets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalListeners.internalValue = value.externalListeners;
      this._internalListeners.internalValue = value.internalListeners;
      this._serviceAnnotations = value.serviceAnnotations;
      this._sslSecrets.internalValue = value.sslSecrets;
    }
  }

  // external_listeners - computed: false, optional: true, required: false
  private _externalListeners = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListenersList(this, "external_listeners", false);
  public get externalListeners() {
    return this._externalListeners;
  }
  public putExternalListeners(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigExternalListeners[] | cdktf.IResolvable) {
    this._externalListeners.internalValue = value;
  }
  public resetExternalListeners() {
    this._externalListeners.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalListenersInput() {
    return this._externalListeners.internalValue;
  }

  // internal_listeners - computed: false, optional: false, required: true
  private _internalListeners = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListenersList(this, "internal_listeners", false);
  public get internalListeners() {
    return this._internalListeners;
  }
  public putInternalListeners(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigInternalListeners[] | cdktf.IResolvable) {
    this._internalListeners.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get internalListenersInput() {
    return this._internalListeners.internalValue;
  }

  // service_annotations - computed: false, optional: true, required: false
  private _serviceAnnotations?: { [key: string]: string }; 
  public get serviceAnnotations() {
    return this.getStringMapAttribute('service_annotations');
  }
  public set serviceAnnotations(value: { [key: string]: string }) {
    this._serviceAnnotations = value;
  }
  public resetServiceAnnotations() {
    this._serviceAnnotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAnnotationsInput() {
    return this._serviceAnnotations;
  }

  // ssl_secrets - computed: false, optional: true, required: false
  private _sslSecrets = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecretsOutputReference(this, "ssl_secrets");
  public get sslSecrets() {
    return this._sslSecrets;
  }
  public putSslSecrets(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigSslSecrets) {
    this._sslSecrets.internalValue = value;
  }
  public resetSslSecrets() {
    this._sslSecrets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sslSecretsInput() {
    return this._sslSecrets.internalValue;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#c_cjmx_exporter_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#c_cjmx_exporter_config}
  */
  readonly cCjmxExporterConfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#jmx_image DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#jmx_image}
  */
  readonly jmxImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#kafka_jmx_exporter_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#kafka_jmx_exporter_config}
  */
  readonly kafkaJmxExporterConfig?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#path_to_jar DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#path_to_jar}
  */
  readonly pathToJar?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    c_cjmx_exporter_config: cdktf.stringToTerraform(struct!.cCjmxExporterConfig),
    jmx_image: cdktf.stringToTerraform(struct!.jmxImage),
    kafka_jmx_exporter_config: cdktf.stringToTerraform(struct!.kafkaJmxExporterConfig),
    path_to_jar: cdktf.stringToTerraform(struct!.pathToJar),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    c_cjmx_exporter_config: {
      value: cdktf.stringToHclTerraform(struct!.cCjmxExporterConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jmx_image: {
      value: cdktf.stringToHclTerraform(struct!.jmxImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kafka_jmx_exporter_config: {
      value: cdktf.stringToHclTerraform(struct!.kafkaJmxExporterConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path_to_jar: {
      value: cdktf.stringToHclTerraform(struct!.pathToJar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cCjmxExporterConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.cCjmxExporterConfig = this._cCjmxExporterConfig;
    }
    if (this._jmxImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.jmxImage = this._jmxImage;
    }
    if (this._kafkaJmxExporterConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaJmxExporterConfig = this._kafkaJmxExporterConfig;
    }
    if (this._pathToJar !== undefined) {
      hasAnyValues = true;
      internalValueResult.pathToJar = this._pathToJar;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cCjmxExporterConfig = undefined;
      this._jmxImage = undefined;
      this._kafkaJmxExporterConfig = undefined;
      this._pathToJar = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cCjmxExporterConfig = value.cCjmxExporterConfig;
      this._jmxImage = value.jmxImage;
      this._kafkaJmxExporterConfig = value.kafkaJmxExporterConfig;
      this._pathToJar = value.pathToJar;
    }
  }

  // c_cjmx_exporter_config - computed: false, optional: true, required: false
  private _cCjmxExporterConfig?: string; 
  public get cCjmxExporterConfig() {
    return this.getStringAttribute('c_cjmx_exporter_config');
  }
  public set cCjmxExporterConfig(value: string) {
    this._cCjmxExporterConfig = value;
  }
  public resetCCjmxExporterConfig() {
    this._cCjmxExporterConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cCjmxExporterConfigInput() {
    return this._cCjmxExporterConfig;
  }

  // jmx_image - computed: false, optional: true, required: false
  private _jmxImage?: string; 
  public get jmxImage() {
    return this.getStringAttribute('jmx_image');
  }
  public set jmxImage(value: string) {
    this._jmxImage = value;
  }
  public resetJmxImage() {
    this._jmxImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jmxImageInput() {
    return this._jmxImage;
  }

  // kafka_jmx_exporter_config - computed: false, optional: true, required: false
  private _kafkaJmxExporterConfig?: string; 
  public get kafkaJmxExporterConfig() {
    return this.getStringAttribute('kafka_jmx_exporter_config');
  }
  public set kafkaJmxExporterConfig(value: string) {
    this._kafkaJmxExporterConfig = value;
  }
  public resetKafkaJmxExporterConfig() {
    this._kafkaJmxExporterConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaJmxExporterConfigInput() {
    return this._kafkaJmxExporterConfig;
  }

  // path_to_jar - computed: false, optional: true, required: false
  private _pathToJar?: string; 
  public get pathToJar() {
    return this.getStringAttribute('path_to_jar');
  }
  public set pathToJar(value: string) {
    this._pathToJar = value;
  }
  public resetPathToJar() {
    this._pathToJar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathToJarInput() {
    return this._pathToJar;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#labels}
  */
  readonly labels: string[];
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwarenessToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    labels: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.labels),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwarenessToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    labels: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.labels),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwarenessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labels = value.labels;
    }
  }

  // labels - computed: false, optional: false, required: true
  private _labels?: string[]; 
  public get labels() {
    return this.getListAttribute('labels');
  }
  public set labels(value: string[]) {
    this._labels = value;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig {
  /**
  * ConcurrentBrokerRestartCountPerRack controls how many brokers can be restarted in parallel during a rolling upgrade. If it is set to a value greater than 1, the operator will restart up to that amount of brokers in parallel, if the brokers are within the same rack (as specified by 'broker.rack' in broker read-only configs). Since using Kafka broker racks spreads out the replicas, we know that restarting multiple brokers in the same rack will not cause more than 1/Nth of the replicas of a topic-partition to be unavailable at the same time, where N is the number of racks used. This is a safe way to speed up the rolling upgrade. Note that for the rack distribution explained above, Cruise Control requires 'com.linkedin.kafka.cruisecontrol.analyzer.goals.RackAwareDistributionGoal' to be configured. Default value is 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#concurrent_broker_restart_count_per_rack DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#concurrent_broker_restart_count_per_rack}
  */
  readonly concurrentBrokerRestartCountPerRack?: number;
  /**
  * FailureThreshold controls how many failures the cluster can tolerate during a rolling upgrade. Once the number of failures reaches this threshold a rolling upgrade flow stops. The number of failures is computed as the sum of distinct broker replicas with either offline replicas or out of sync replicas and the number of alerts triggered by alerts with 'rollingupgrade'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#failure_threshold DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#failure_threshold}
  */
  readonly failureThreshold: number;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfigToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    concurrent_broker_restart_count_per_rack: cdktf.numberToTerraform(struct!.concurrentBrokerRestartCountPerRack),
    failure_threshold: cdktf.numberToTerraform(struct!.failureThreshold),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfigToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    concurrent_broker_restart_count_per_rack: {
      value: cdktf.numberToHclTerraform(struct!.concurrentBrokerRestartCountPerRack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.failureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._concurrentBrokerRestartCountPerRack !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrentBrokerRestartCountPerRack = this._concurrentBrokerRestartCountPerRack;
    }
    if (this._failureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureThreshold = this._failureThreshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._concurrentBrokerRestartCountPerRack = undefined;
      this._failureThreshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._concurrentBrokerRestartCountPerRack = value.concurrentBrokerRestartCountPerRack;
      this._failureThreshold = value.failureThreshold;
    }
  }

  // concurrent_broker_restart_count_per_rack - computed: false, optional: true, required: false
  private _concurrentBrokerRestartCountPerRack?: number; 
  public get concurrentBrokerRestartCountPerRack() {
    return this.getNumberAttribute('concurrent_broker_restart_count_per_rack');
  }
  public set concurrentBrokerRestartCountPerRack(value: number) {
    this._concurrentBrokerRestartCountPerRack = value;
  }
  public resetConcurrentBrokerRestartCountPerRack() {
    this._concurrentBrokerRestartCountPerRack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrentBrokerRestartCountPerRackInput() {
    return this._concurrentBrokerRestartCountPerRack;
  }

  // failure_threshold - computed: false, optional: false, required: true
  private _failureThreshold?: number; 
  public get failureThreshold() {
    return this.getNumberAttribute('failure_threshold');
  }
  public set failureThreshold(value: number) {
    this._failureThreshold = value;
  }
  // Temporarily expose input value. Use with caution.
  public get failureThresholdInput() {
    return this._failureThreshold;
  }
}
export interface DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpec {
  /**
  * Custom ports to expose in the container. Example use case: a custom kafka distribution, that includes an integrated metrics api endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#additional_ports DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#additional_ports}
  */
  readonly additionalPorts?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPorts[] | cdktf.IResolvable;
  /**
  * AlertManagerConfig defines configuration for alert manager
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#alert_manager_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#alert_manager_config}
  */
  readonly alertManagerConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#broker_config_groups DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#broker_config_groups}
  */
  readonly brokerConfigGroups?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroups;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#brokers DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#brokers}
  */
  readonly brokers: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokers[] | cdktf.IResolvable;
  /**
  * ClientSSLCertSecret is a reference to the Kubernetes secret where custom client SSL certificate can be provided. It will be used by the koperator, cruise control, cruise control metrics reporter to communicate on SSL with that internal listener which is used for interbroker communication. The client certificate must share the same chain of trust as the server certificate used by the corresponding internal listener. The secret must contain the keystore, truststore jks files and the password for them in base64 encoded format under the keystore.jks, truststore.jks, password data fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#client_ssl_cert_secret DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#client_ssl_cert_secret}
  */
  readonly clientSslCertSecret?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecret;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#cluster_image DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#cluster_image}
  */
  readonly clusterImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#cluster_metrics_reporter_image DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#cluster_metrics_reporter_image}
  */
  readonly clusterMetricsReporterImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#cluster_wide_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#cluster_wide_config}
  */
  readonly clusterWideConfig?: string;
  /**
  * CruiseControlConfig defines the config for Cruise Control
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#cruise_control_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#cruise_control_config}
  */
  readonly cruiseControlConfig: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfig;
  /**
  * DisruptionBudget defines the configuration for PodDisruptionBudget where the workload is managed by the kafka-operator
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#disruption_budget DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#disruption_budget}
  */
  readonly disruptionBudget?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudget;
  /**
  * EnvoyConfig defines the config for Envoy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#envoy_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#envoy_config}
  */
  readonly envoyConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig;
  /**
  * Envs defines environment variables for Kafka broker Pods. Adding the '+' prefix to the name prepends the value to that environment variable instead of overwriting it. Add the '+' suffix to append.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#envs DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#envs}
  */
  readonly envs?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#headless_service_enabled DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#headless_service_enabled}
  */
  readonly headlessServiceEnabled: boolean | cdktf.IResolvable;
  /**
  * IngressController specifies the type of the ingress controller to be used for external listeners. The 'istioingress' ingress controller type requires the 'spec.istioControlPlane' field to be populated as well.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#ingress_controller DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#ingress_controller}
  */
  readonly ingressController?: string;
  /**
  * IstioControlPlane is a reference to the IstioControlPlane resource for envoy configuration. It must be specified if istio ingress is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#istio_control_plane DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#istio_control_plane}
  */
  readonly istioControlPlane?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane;
  /**
  * IstioIngressConfig defines the config for the Istio Ingress Controller
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#istio_ingress_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#istio_ingress_config}
  */
  readonly istioIngressConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#kubernetes_cluster_domain DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#kubernetes_cluster_domain}
  */
  readonly kubernetesClusterDomain?: string;
  /**
  * ListenersConfig defines the Kafka listener types
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#listeners_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#listeners_config}
  */
  readonly listenersConfig: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig;
  /**
  * MonitoringConfig defines the config for monitoring Kafka and Cruise Control
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#monitoring_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#monitoring_config}
  */
  readonly monitoringConfig?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig;
  /**
  * If true OneBrokerPerNode ensures that each kafka broker will be placed on a different node unless a custom Affinity definition overrides this behavior
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#one_broker_per_node DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#one_broker_per_node}
  */
  readonly oneBrokerPerNode: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#propagate_labels DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#propagate_labels}
  */
  readonly propagateLabels?: boolean | cdktf.IResolvable;
  /**
  * RackAwareness defines the required fields to enable kafka's rack aware feature
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#rack_awareness DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#rack_awareness}
  */
  readonly rackAwareness?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#read_only_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#read_only_config}
  */
  readonly readOnlyConfig?: string;
  /**
  * RemoveUnusedIngressResources when true, the unnecessary resources from the previous ingress state will be removed. when false, they will be kept so the Kafka cluster remains available for those Kafka clients which are still using the previous ingress setting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#remove_unused_ingress_resources DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#remove_unused_ingress_resources}
  */
  readonly removeUnusedIngressResources?: boolean | cdktf.IResolvable;
  /**
  * RollingUpgradeConfig defines the desired config of the RollingUpgrade
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#rolling_upgrade_config DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#rolling_upgrade_config}
  */
  readonly rollingUpgradeConfig: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig;
  /**
  * ZKAddresses specifies the ZooKeeper connection string in the form hostname:port where host and port are the host and port of a ZooKeeper server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#zk_addresses DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#zk_addresses}
  */
  readonly zkAddresses: string[];
  /**
  * ZKPath specifies the ZooKeeper chroot path as part of its ZooKeeper connection string which puts its data under some path in the global ZooKeeper namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.24/docs/data-sources/kafka_banzaicloud_io_kafka_cluster_v1beta1_manifest#zk_path DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1Manifest#zk_path}
  */
  readonly zkPath?: string;
}

export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecToTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_ports: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPortsToTerraform, false)(struct!.additionalPorts),
    alert_manager_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfigToTerraform(struct!.alertManagerConfig),
    broker_config_groups: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroupsToTerraform(struct!.brokerConfigGroups),
    brokers: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokersToTerraform, false)(struct!.brokers),
    client_ssl_cert_secret: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecretToTerraform(struct!.clientSslCertSecret),
    cluster_image: cdktf.stringToTerraform(struct!.clusterImage),
    cluster_metrics_reporter_image: cdktf.stringToTerraform(struct!.clusterMetricsReporterImage),
    cluster_wide_config: cdktf.stringToTerraform(struct!.clusterWideConfig),
    cruise_control_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfigToTerraform(struct!.cruiseControlConfig),
    disruption_budget: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudgetToTerraform(struct!.disruptionBudget),
    envoy_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigToTerraform(struct!.envoyConfig),
    envs: cdktf.listMapper(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsToTerraform, false)(struct!.envs),
    headless_service_enabled: cdktf.booleanToTerraform(struct!.headlessServiceEnabled),
    ingress_controller: cdktf.stringToTerraform(struct!.ingressController),
    istio_control_plane: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlaneToTerraform(struct!.istioControlPlane),
    istio_ingress_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigToTerraform(struct!.istioIngressConfig),
    kubernetes_cluster_domain: cdktf.stringToTerraform(struct!.kubernetesClusterDomain),
    listeners_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigToTerraform(struct!.listenersConfig),
    monitoring_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfigToTerraform(struct!.monitoringConfig),
    one_broker_per_node: cdktf.booleanToTerraform(struct!.oneBrokerPerNode),
    propagate_labels: cdktf.booleanToTerraform(struct!.propagateLabels),
    rack_awareness: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwarenessToTerraform(struct!.rackAwareness),
    read_only_config: cdktf.stringToTerraform(struct!.readOnlyConfig),
    remove_unused_ingress_resources: cdktf.booleanToTerraform(struct!.removeUnusedIngressResources),
    rolling_upgrade_config: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfigToTerraform(struct!.rollingUpgradeConfig),
    zk_addresses: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.zkAddresses),
    zk_path: cdktf.stringToTerraform(struct!.zkPath),
  }
}


export function dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecToHclTerraform(struct?: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_ports: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPortsToHclTerraform, false)(struct!.additionalPorts),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPortsList",
    },
    alert_manager_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfigToHclTerraform(struct!.alertManagerConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfig",
    },
    broker_config_groups: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroupsToHclTerraform(struct!.brokerConfigGroups),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroups",
    },
    brokers: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokersToHclTerraform, false)(struct!.brokers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokersList",
    },
    client_ssl_cert_secret: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecretToHclTerraform(struct!.clientSslCertSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecret",
    },
    cluster_image: {
      value: cdktf.stringToHclTerraform(struct!.clusterImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_metrics_reporter_image: {
      value: cdktf.stringToHclTerraform(struct!.clusterMetricsReporterImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_wide_config: {
      value: cdktf.stringToHclTerraform(struct!.clusterWideConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cruise_control_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfigToHclTerraform(struct!.cruiseControlConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfig",
    },
    disruption_budget: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudgetToHclTerraform(struct!.disruptionBudget),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudget",
    },
    envoy_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigToHclTerraform(struct!.envoyConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig",
    },
    envs: {
      value: cdktf.listMapperHcl(dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsToHclTerraform, false)(struct!.envs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsList",
    },
    headless_service_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.headlessServiceEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ingress_controller: {
      value: cdktf.stringToHclTerraform(struct!.ingressController),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    istio_control_plane: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlaneToHclTerraform(struct!.istioControlPlane),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane",
    },
    istio_ingress_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigToHclTerraform(struct!.istioIngressConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig",
    },
    kubernetes_cluster_domain: {
      value: cdktf.stringToHclTerraform(struct!.kubernetesClusterDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    listeners_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigToHclTerraform(struct!.listenersConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig",
    },
    monitoring_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfigToHclTerraform(struct!.monitoringConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig",
    },
    one_broker_per_node: {
      value: cdktf.booleanToHclTerraform(struct!.oneBrokerPerNode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    propagate_labels: {
      value: cdktf.booleanToHclTerraform(struct!.propagateLabels),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rack_awareness: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwarenessToHclTerraform(struct!.rackAwareness),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness",
    },
    read_only_config: {
      value: cdktf.stringToHclTerraform(struct!.readOnlyConfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_unused_ingress_resources: {
      value: cdktf.booleanToHclTerraform(struct!.removeUnusedIngressResources),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    rolling_upgrade_config: {
      value: dataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfigToHclTerraform(struct!.rollingUpgradeConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig",
    },
    zk_addresses: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.zkAddresses),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    zk_path: {
      value: cdktf.stringToHclTerraform(struct!.zkPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalPorts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalPorts = this._additionalPorts?.internalValue;
    }
    if (this._alertManagerConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.alertManagerConfig = this._alertManagerConfig?.internalValue;
    }
    if (this._brokerConfigGroups?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokerConfigGroups = this._brokerConfigGroups?.internalValue;
    }
    if (this._brokers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers?.internalValue;
    }
    if (this._clientSslCertSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSslCertSecret = this._clientSslCertSecret?.internalValue;
    }
    if (this._clusterImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterImage = this._clusterImage;
    }
    if (this._clusterMetricsReporterImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterMetricsReporterImage = this._clusterMetricsReporterImage;
    }
    if (this._clusterWideConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterWideConfig = this._clusterWideConfig;
    }
    if (this._cruiseControlConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cruiseControlConfig = this._cruiseControlConfig?.internalValue;
    }
    if (this._disruptionBudget?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disruptionBudget = this._disruptionBudget?.internalValue;
    }
    if (this._envoyConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envoyConfig = this._envoyConfig?.internalValue;
    }
    if (this._envs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.envs = this._envs?.internalValue;
    }
    if (this._headlessServiceEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.headlessServiceEnabled = this._headlessServiceEnabled;
    }
    if (this._ingressController !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressController = this._ingressController;
    }
    if (this._istioControlPlane?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.istioControlPlane = this._istioControlPlane?.internalValue;
    }
    if (this._istioIngressConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.istioIngressConfig = this._istioIngressConfig?.internalValue;
    }
    if (this._kubernetesClusterDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesClusterDomain = this._kubernetesClusterDomain;
    }
    if (this._listenersConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.listenersConfig = this._listenersConfig?.internalValue;
    }
    if (this._monitoringConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.monitoringConfig = this._monitoringConfig?.internalValue;
    }
    if (this._oneBrokerPerNode !== undefined) {
      hasAnyValues = true;
      internalValueResult.oneBrokerPerNode = this._oneBrokerPerNode;
    }
    if (this._propagateLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.propagateLabels = this._propagateLabels;
    }
    if (this._rackAwareness?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rackAwareness = this._rackAwareness?.internalValue;
    }
    if (this._readOnlyConfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnlyConfig = this._readOnlyConfig;
    }
    if (this._removeUnusedIngressResources !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeUnusedIngressResources = this._removeUnusedIngressResources;
    }
    if (this._rollingUpgradeConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rollingUpgradeConfig = this._rollingUpgradeConfig?.internalValue;
    }
    if (this._zkAddresses !== undefined) {
      hasAnyValues = true;
      internalValueResult.zkAddresses = this._zkAddresses;
    }
    if (this._zkPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.zkPath = this._zkPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalPorts.internalValue = undefined;
      this._alertManagerConfig.internalValue = undefined;
      this._brokerConfigGroups.internalValue = undefined;
      this._brokers.internalValue = undefined;
      this._clientSslCertSecret.internalValue = undefined;
      this._clusterImage = undefined;
      this._clusterMetricsReporterImage = undefined;
      this._clusterWideConfig = undefined;
      this._cruiseControlConfig.internalValue = undefined;
      this._disruptionBudget.internalValue = undefined;
      this._envoyConfig.internalValue = undefined;
      this._envs.internalValue = undefined;
      this._headlessServiceEnabled = undefined;
      this._ingressController = undefined;
      this._istioControlPlane.internalValue = undefined;
      this._istioIngressConfig.internalValue = undefined;
      this._kubernetesClusterDomain = undefined;
      this._listenersConfig.internalValue = undefined;
      this._monitoringConfig.internalValue = undefined;
      this._oneBrokerPerNode = undefined;
      this._propagateLabels = undefined;
      this._rackAwareness.internalValue = undefined;
      this._readOnlyConfig = undefined;
      this._removeUnusedIngressResources = undefined;
      this._rollingUpgradeConfig.internalValue = undefined;
      this._zkAddresses = undefined;
      this._zkPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalPorts.internalValue = value.additionalPorts;
      this._alertManagerConfig.internalValue = value.alertManagerConfig;
      this._brokerConfigGroups.internalValue = value.brokerConfigGroups;
      this._brokers.internalValue = value.brokers;
      this._clientSslCertSecret.internalValue = value.clientSslCertSecret;
      this._clusterImage = value.clusterImage;
      this._clusterMetricsReporterImage = value.clusterMetricsReporterImage;
      this._clusterWideConfig = value.clusterWideConfig;
      this._cruiseControlConfig.internalValue = value.cruiseControlConfig;
      this._disruptionBudget.internalValue = value.disruptionBudget;
      this._envoyConfig.internalValue = value.envoyConfig;
      this._envs.internalValue = value.envs;
      this._headlessServiceEnabled = value.headlessServiceEnabled;
      this._ingressController = value.ingressController;
      this._istioControlPlane.internalValue = value.istioControlPlane;
      this._istioIngressConfig.internalValue = value.istioIngressConfig;
      this._kubernetesClusterDomain = value.kubernetesClusterDomain;
      this._listenersConfig.internalValue = value.listenersConfig;
      this._monitoringConfig.internalValue = value.monitoringConfig;
      this._oneBrokerPerNode = value.oneBrokerPerNode;
      this._propagateLabels = value.propagateLabels;
      this._rackAwareness.internalValue = value.rackAwareness;
      this._readOnlyConfig = value.readOnlyConfig;
      this._removeUnusedIngressResources = value.removeUnusedIngressResources;
      this._rollingUpgradeConfig.internalValue = value.rollingUpgradeConfig;
      this._zkAddresses = value.zkAddresses;
      this._zkPath = value.zkPath;
    }
  }

  // additional_ports - computed: false, optional: true, required: false
  private _additionalPorts = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPortsList(this, "additional_ports", false);
  public get additionalPorts() {
    return this._additionalPorts;
  }
  public putAdditionalPorts(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAdditionalPorts[] | cdktf.IResolvable) {
    this._additionalPorts.internalValue = value;
  }
  public resetAdditionalPorts() {
    this._additionalPorts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalPortsInput() {
    return this._additionalPorts.internalValue;
  }

  // alert_manager_config - computed: false, optional: true, required: false
  private _alertManagerConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfigOutputReference(this, "alert_manager_config");
  public get alertManagerConfig() {
    return this._alertManagerConfig;
  }
  public putAlertManagerConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecAlertManagerConfig) {
    this._alertManagerConfig.internalValue = value;
  }
  public resetAlertManagerConfig() {
    this._alertManagerConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get alertManagerConfigInput() {
    return this._alertManagerConfig.internalValue;
  }

  // broker_config_groups - computed: false, optional: true, required: false
  private _brokerConfigGroups = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroupsOutputReference(this, "broker_config_groups");
  public get brokerConfigGroups() {
    return this._brokerConfigGroups;
  }
  public putBrokerConfigGroups(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokerConfigGroups) {
    this._brokerConfigGroups.internalValue = value;
  }
  public resetBrokerConfigGroups() {
    this._brokerConfigGroups.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get brokerConfigGroupsInput() {
    return this._brokerConfigGroups.internalValue;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokersList(this, "brokers", false);
  public get brokers() {
    return this._brokers;
  }
  public putBrokers(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecBrokers[] | cdktf.IResolvable) {
    this._brokers.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers.internalValue;
  }

  // client_ssl_cert_secret - computed: false, optional: true, required: false
  private _clientSslCertSecret = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecretOutputReference(this, "client_ssl_cert_secret");
  public get clientSslCertSecret() {
    return this._clientSslCertSecret;
  }
  public putClientSslCertSecret(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecClientSslCertSecret) {
    this._clientSslCertSecret.internalValue = value;
  }
  public resetClientSslCertSecret() {
    this._clientSslCertSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSslCertSecretInput() {
    return this._clientSslCertSecret.internalValue;
  }

  // cluster_image - computed: false, optional: true, required: false
  private _clusterImage?: string; 
  public get clusterImage() {
    return this.getStringAttribute('cluster_image');
  }
  public set clusterImage(value: string) {
    this._clusterImage = value;
  }
  public resetClusterImage() {
    this._clusterImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterImageInput() {
    return this._clusterImage;
  }

  // cluster_metrics_reporter_image - computed: false, optional: true, required: false
  private _clusterMetricsReporterImage?: string; 
  public get clusterMetricsReporterImage() {
    return this.getStringAttribute('cluster_metrics_reporter_image');
  }
  public set clusterMetricsReporterImage(value: string) {
    this._clusterMetricsReporterImage = value;
  }
  public resetClusterMetricsReporterImage() {
    this._clusterMetricsReporterImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterMetricsReporterImageInput() {
    return this._clusterMetricsReporterImage;
  }

  // cluster_wide_config - computed: false, optional: true, required: false
  private _clusterWideConfig?: string; 
  public get clusterWideConfig() {
    return this.getStringAttribute('cluster_wide_config');
  }
  public set clusterWideConfig(value: string) {
    this._clusterWideConfig = value;
  }
  public resetClusterWideConfig() {
    this._clusterWideConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterWideConfigInput() {
    return this._clusterWideConfig;
  }

  // cruise_control_config - computed: false, optional: false, required: true
  private _cruiseControlConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfigOutputReference(this, "cruise_control_config");
  public get cruiseControlConfig() {
    return this._cruiseControlConfig;
  }
  public putCruiseControlConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecCruiseControlConfig) {
    this._cruiseControlConfig.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get cruiseControlConfigInput() {
    return this._cruiseControlConfig.internalValue;
  }

  // disruption_budget - computed: false, optional: true, required: false
  private _disruptionBudget = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudgetOutputReference(this, "disruption_budget");
  public get disruptionBudget() {
    return this._disruptionBudget;
  }
  public putDisruptionBudget(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecDisruptionBudget) {
    this._disruptionBudget.internalValue = value;
  }
  public resetDisruptionBudget() {
    this._disruptionBudget.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disruptionBudgetInput() {
    return this._disruptionBudget.internalValue;
  }

  // envoy_config - computed: false, optional: true, required: false
  private _envoyConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfigOutputReference(this, "envoy_config");
  public get envoyConfig() {
    return this._envoyConfig;
  }
  public putEnvoyConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvoyConfig) {
    this._envoyConfig.internalValue = value;
  }
  public resetEnvoyConfig() {
    this._envoyConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envoyConfigInput() {
    return this._envoyConfig.internalValue;
  }

  // envs - computed: false, optional: true, required: false
  private _envs = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvsList(this, "envs", false);
  public get envs() {
    return this._envs;
  }
  public putEnvs(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecEnvs[] | cdktf.IResolvable) {
    this._envs.internalValue = value;
  }
  public resetEnvs() {
    this._envs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envsInput() {
    return this._envs.internalValue;
  }

  // headless_service_enabled - computed: false, optional: false, required: true
  private _headlessServiceEnabled?: boolean | cdktf.IResolvable; 
  public get headlessServiceEnabled() {
    return this.getBooleanAttribute('headless_service_enabled');
  }
  public set headlessServiceEnabled(value: boolean | cdktf.IResolvable) {
    this._headlessServiceEnabled = value;
  }
  // Temporarily expose input value. Use with caution.
  public get headlessServiceEnabledInput() {
    return this._headlessServiceEnabled;
  }

  // ingress_controller - computed: false, optional: true, required: false
  private _ingressController?: string; 
  public get ingressController() {
    return this.getStringAttribute('ingress_controller');
  }
  public set ingressController(value: string) {
    this._ingressController = value;
  }
  public resetIngressController() {
    this._ingressController = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressControllerInput() {
    return this._ingressController;
  }

  // istio_control_plane - computed: false, optional: true, required: false
  private _istioControlPlane = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlaneOutputReference(this, "istio_control_plane");
  public get istioControlPlane() {
    return this._istioControlPlane;
  }
  public putIstioControlPlane(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioControlPlane) {
    this._istioControlPlane.internalValue = value;
  }
  public resetIstioControlPlane() {
    this._istioControlPlane.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get istioControlPlaneInput() {
    return this._istioControlPlane.internalValue;
  }

  // istio_ingress_config - computed: false, optional: true, required: false
  private _istioIngressConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfigOutputReference(this, "istio_ingress_config");
  public get istioIngressConfig() {
    return this._istioIngressConfig;
  }
  public putIstioIngressConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecIstioIngressConfig) {
    this._istioIngressConfig.internalValue = value;
  }
  public resetIstioIngressConfig() {
    this._istioIngressConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get istioIngressConfigInput() {
    return this._istioIngressConfig.internalValue;
  }

  // kubernetes_cluster_domain - computed: false, optional: true, required: false
  private _kubernetesClusterDomain?: string; 
  public get kubernetesClusterDomain() {
    return this.getStringAttribute('kubernetes_cluster_domain');
  }
  public set kubernetesClusterDomain(value: string) {
    this._kubernetesClusterDomain = value;
  }
  public resetKubernetesClusterDomain() {
    this._kubernetesClusterDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesClusterDomainInput() {
    return this._kubernetesClusterDomain;
  }

  // listeners_config - computed: false, optional: false, required: true
  private _listenersConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfigOutputReference(this, "listeners_config");
  public get listenersConfig() {
    return this._listenersConfig;
  }
  public putListenersConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecListenersConfig) {
    this._listenersConfig.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get listenersConfigInput() {
    return this._listenersConfig.internalValue;
  }

  // monitoring_config - computed: false, optional: true, required: false
  private _monitoringConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfigOutputReference(this, "monitoring_config");
  public get monitoringConfig() {
    return this._monitoringConfig;
  }
  public putMonitoringConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecMonitoringConfig) {
    this._monitoringConfig.internalValue = value;
  }
  public resetMonitoringConfig() {
    this._monitoringConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get monitoringConfigInput() {
    return this._monitoringConfig.internalValue;
  }

  // one_broker_per_node - computed: false, optional: false, required: true
  private _oneBrokerPerNode?: boolean | cdktf.IResolvable; 
  public get oneBrokerPerNode() {
    return this.getBooleanAttribute('one_broker_per_node');
  }
  public set oneBrokerPerNode(value: boolean | cdktf.IResolvable) {
    this._oneBrokerPerNode = value;
  }
  // Temporarily expose input value. Use with caution.
  public get oneBrokerPerNodeInput() {
    return this._oneBrokerPerNode;
  }

  // propagate_labels - computed: false, optional: true, required: false
  private _propagateLabels?: boolean | cdktf.IResolvable; 
  public get propagateLabels() {
    return this.getBooleanAttribute('propagate_labels');
  }
  public set propagateLabels(value: boolean | cdktf.IResolvable) {
    this._propagateLabels = value;
  }
  public resetPropagateLabels() {
    this._propagateLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get propagateLabelsInput() {
    return this._propagateLabels;
  }

  // rack_awareness - computed: false, optional: true, required: false
  private _rackAwareness = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwarenessOutputReference(this, "rack_awareness");
  public get rackAwareness() {
    return this._rackAwareness;
  }
  public putRackAwareness(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRackAwareness) {
    this._rackAwareness.internalValue = value;
  }
  public resetRackAwareness() {
    this._rackAwareness.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rackAwarenessInput() {
    return this._rackAwareness.internalValue;
  }

  // read_only_config - computed: false, optional: true, required: false
  private _readOnlyConfig?: string; 
  public get readOnlyConfig() {
    return this.getStringAttribute('read_only_config');
  }
  public set readOnlyConfig(value: string) {
    this._readOnlyConfig = value;
  }
  public resetReadOnlyConfig() {
    this._readOnlyConfig = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyConfigInput() {
    return this._readOnlyConfig;
  }

  // remove_unused_ingress_resources - computed: false, optional: true, required: false
  private _removeUnusedIngressResources?: boolean | cdktf.IResolvable; 
  public get removeUnusedIngressResources() {
    return this.getBooleanAttribute('remove_unused_ingress_resources');
  }
  public set removeUnusedIngressResources(value: boolean | cdktf.IResolvable) {
    this._removeUnusedIngressResources = value;
  }
  public resetRemoveUnusedIngressResources() {
    this._removeUnusedIngressResources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeUnusedIngressResourcesInput() {
    return this._removeUnusedIngressResources;
  }

  // rolling_upgrade_config - computed: false, optional: false, required: true
  private _rollingUpgradeConfig = new DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfigOutputReference(this, "rolling_upgrade_config");
  public get rollingUpgradeConfig() {
    return this._rollingUpgradeConfig;
  }
  public putRollingUpgradeConfig(value: DataK8SKafkaBanzaicloudIoKafkaClusterV1Beta1ManifestSpecRollingUpgradeConfig) {
    this._rollingUpgradeConfig.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get rollingUpgradeConfigInput() {
    return this._rollingUpgradeConfig.internalValue;
  }

  // zk_addresses - computed: false, optional: false, required: true
  private _zkAddresses?: string[]; 
  public get zkAddresses() {
    return this.getListAttribute('zk_addresses');
  }
  public set zkAddresses(value: string[]) {
    this._zkAddresses = value;
  }
  // Temporarily expose input value. Use with caution.
  public get zkAddressesInput() {
    return this._zkAddresses;
  }

  // zk_path - computed: false, optional: true, required: false
  private _zkPath?: string; 
  public get zkPath() {
    return this.getStringAttribute('zk_path');
  }
  public set zkPath(value: string) {
    this._zkPath = value;
  }
  public resetZkPath() {
    this._zkPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get zkPathInput() {
    return this._zkPath;
  }
}
