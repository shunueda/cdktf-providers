// https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest
// generated from terraform resource schema

import { Construct } from 'constructs';
import * as cdktf from 'cdktf';

// Configuration

export interface DataK8SOrgEclipseCheCheClusterV1ManifestConfig extends cdktf.TerraformMetaArguments {
  /**
  * Data that helps uniquely identify this object. See https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#metadata DataK8SOrgEclipseCheCheClusterV1Manifest#metadata}
  */
  readonly metadata: DataK8SOrgEclipseCheCheClusterV1ManifestMetadata;
  /**
  * Desired configuration of the Che installation. Based on these settings, the Operator automatically creates and maintains several ConfigMaps that will contain the appropriate environment variables the various components of the Che installation. These generated ConfigMaps must NOT be updated manually.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#spec DataK8SOrgEclipseCheCheClusterV1Manifest#spec}
  */
  readonly spec?: DataK8SOrgEclipseCheCheClusterV1ManifestSpec;
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#namespace DataK8SOrgEclipseCheCheClusterV1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestMetadataToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestMetadataToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu DataK8SOrgEclipseCheCheClusterV1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory DataK8SOrgEclipseCheCheClusterV1Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu DataK8SOrgEclipseCheCheClusterV1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory DataK8SOrgEclipseCheCheClusterV1Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources {
  /**
  * Limits describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#limits DataK8SOrgEclipseCheCheClusterV1Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits;
  /**
  * Requests describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#request DataK8SOrgEclipseCheCheClusterV1Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngressToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngressToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Operator uses the domain to generate a hostname for a route. In a conjunction with labels it creates a route, which is served by a non-default Ingress controller. The generated host name will follow this pattern: '<route-name>-<route-namespace>.<domain>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#domain DataK8SOrgEclipseCheCheClusterV1Manifest#domain}
  */
  readonly domain?: string;
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRouteToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    domain: cdktf.stringToTerraform(struct!.domain),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRouteToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._domain = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._domain = value.domain;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth {
  /**
  * Deprecated. The value of this flag is ignored. Debug internal identity provider.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#debug DataK8SOrgEclipseCheCheClusterV1Manifest#debug}
  */
  readonly debug?: boolean | cdktf.IResolvable;
  /**
  * Deprecated. The value of this flag is ignored. Instructs the Operator on whether or not to deploy a dedicated Identity Provider (Keycloak or RH SSO instance). Instructs the Operator on whether to deploy a dedicated Identity Provider (Keycloak or RH-SSO instance). By default, a dedicated Identity Provider server is deployed as part of the Che installation. When 'externalIdentityProvider' is 'true', no dedicated identity provider will be deployed by the Operator and you will need to provide details about the external identity provider you are about to use. See also all the other fields starting with: 'identityProvider'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#external_identity_provider DataK8SOrgEclipseCheCheClusterV1Manifest#external_identity_provider}
  */
  readonly externalIdentityProvider?: boolean | cdktf.IResolvable;
  /**
  * Gateway sidecar responsible for authentication when NativeUserMode is enabled. See link:https://github.com/oauth2-proxy/oauth2-proxy[oauth2-proxy] or link:https://github.com/openshift/oauth-proxy[openshift/oauth-proxy].
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gateway_authentication_sidecar_image DataK8SOrgEclipseCheCheClusterV1Manifest#gateway_authentication_sidecar_image}
  */
  readonly gatewayAuthenticationSidecarImage?: string;
  /**
  * Gateway sidecar responsible for authorization when NativeUserMode is enabled. See link:https://github.com/brancz/kube-rbac-proxy[kube-rbac-proxy] or link:https://github.com/openshift/kube-rbac-proxy[openshift/kube-rbac-proxy]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gateway_authorization_sidecar_image DataK8SOrgEclipseCheCheClusterV1Manifest#gateway_authorization_sidecar_image}
  */
  readonly gatewayAuthorizationSidecarImage?: string;
  /**
  * List of environment variables to set in the Configbump container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gateway_config_bump_env DataK8SOrgEclipseCheCheClusterV1Manifest#gateway_config_bump_env}
  */
  readonly gatewayConfigBumpEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv[] | cdktf.IResolvable;
  /**
  * List of environment variables to set in the Gateway container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gateway_env DataK8SOrgEclipseCheCheClusterV1Manifest#gateway_env}
  */
  readonly gatewayEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv[] | cdktf.IResolvable;
  /**
  * Deprecated. The value of this flag is ignored. Sidecar functionality is now implemented in Traefik plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gateway_header_rewrite_sidecar_image DataK8SOrgEclipseCheCheClusterV1Manifest#gateway_header_rewrite_sidecar_image}
  */
  readonly gatewayHeaderRewriteSidecarImage?: string;
  /**
  * List of environment variables to set in the Kube rbac proxy container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gateway_kube_rbac_proxy_env DataK8SOrgEclipseCheCheClusterV1Manifest#gateway_kube_rbac_proxy_env}
  */
  readonly gatewayKubeRbacProxyEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv[] | cdktf.IResolvable;
  /**
  * List of environment variables to set in the OAuth proxy container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gateway_o_auth_proxy_env DataK8SOrgEclipseCheCheClusterV1Manifest#gateway_o_auth_proxy_env}
  */
  readonly gatewayOAuthProxyEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv[] | cdktf.IResolvable;
  /**
  * Deprecated. The value of this flag is ignored. Overrides the name of the Identity Provider administrator user. Defaults to 'admin'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_admin_user_name DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_admin_user_name}
  */
  readonly identityProviderAdminUserName?: string;
  /**
  * Deprecated. The value of this flag is ignored. Name of a Identity provider, Keycloak or RH-SSO, 'client-id' that is used for Che. Override this when an external Identity Provider is in use. See the 'externalIdentityProvider' field. When omitted or left blank, it is set to the value of the 'flavour' field suffixed with '-public'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_client_id DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_client_id}
  */
  readonly identityProviderClientId?: string;
  /**
  * Deprecated. The value of this flag is ignored. Identity provider container custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_container_resources DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_container_resources}
  */
  readonly identityProviderContainerResources?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources;
  /**
  * Deprecated. The value of this flag is ignored. Overrides the container image used in the Identity Provider, Keycloak or RH-SSO, deployment. This includes the image tag. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_image DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_image}
  */
  readonly identityProviderImage?: string;
  /**
  * Deprecated. The value of this flag is ignored. Overrides the image pull policy used in the Identity Provider, Keycloak or RH-SSO, deployment. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_image_pull_policy DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_image_pull_policy}
  */
  readonly identityProviderImagePullPolicy?: string;
  /**
  * Deprecated. The value of this flag is ignored. Ingress custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_ingress DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_ingress}
  */
  readonly identityProviderIngress?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress;
  /**
  * Deprecated. The value of this flag is ignored. Overrides the password of Keycloak administrator user. Override this when an external Identity Provider is in use. See the 'externalIdentityProvider' field. When omitted or left blank, it is set to an auto-generated password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_password DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_password}
  */
  readonly identityProviderPassword?: string;
  /**
  * Deprecated. The value of this flag is ignored. Password for a Identity Provider, Keycloak or RH-SSO, to connect to the database. Override this when an external Identity Provider is in use. See the 'externalIdentityProvider' field. When omitted or left blank, it is set to an auto-generated password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_postgres_password DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_postgres_password}
  */
  readonly identityProviderPostgresPassword?: string;
  /**
  * Deprecated. The value of this flag is ignored. The secret that contains 'password' for the Identity Provider, Keycloak or RH-SSO, to connect to the database. When the secret is defined, the 'identityProviderPostgresPassword' is ignored. When the value is omitted or left blank, the one of following scenarios applies: 1. 'identityProviderPostgresPassword' is defined, then it will be used to connect to the database. 2. 'identityProviderPostgresPassword' is not defined, then a new secret with the name 'che-identity-postgres-secret' will be created with an auto-generated value for 'password'. The secret must have 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_postgres_secret DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_postgres_secret}
  */
  readonly identityProviderPostgresSecret?: string;
  /**
  * Deprecated. The value of this flag is ignored. Name of a Identity provider, Keycloak or RH-SSO, realm that is used for Che. Override this when an external Identity Provider is in use. See the 'externalIdentityProvider' field. When omitted or left blank, it is set to the value of the 'flavour' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_realm DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_realm}
  */
  readonly identityProviderRealm?: string;
  /**
  * Deprecated. The value of this flag is ignored. Route custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_route DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_route}
  */
  readonly identityProviderRoute?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute;
  /**
  * Deprecated. The value of this flag is ignored. The secret that contains 'user' and 'password' for Identity Provider. When the secret is defined, the 'identityProviderAdminUserName' and 'identityProviderPassword' are ignored. When the value is omitted or left blank, the one of following scenarios applies: 1. 'identityProviderAdminUserName' and 'identityProviderPassword' are defined, then they will be used. 2. 'identityProviderAdminUserName' or 'identityProviderPassword' are not defined, then a new secret with the name 'che-identity-secret' will be created with default value 'admin' for 'user' and with an auto-generated value for 'password'. The secret must have 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_secret DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_secret}
  */
  readonly identityProviderSecret?: string;
  /**
  * Public URL of the Identity Provider server (Keycloak / RH-SSO server). Set this ONLY when a use of an external Identity Provider is needed. See the 'externalIdentityProvider' field. By default, this will be automatically calculated and set by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_provider_url DataK8SOrgEclipseCheCheClusterV1Manifest#identity_provider_url}
  */
  readonly identityProviderUrl?: string;
  /**
  * Identity token to be passed to upstream. There are two types of tokens supported: 'id_token' and 'access_token'. Default value is 'id_token'. This field is specific to Che installations made for Kubernetes only and ignored for OpenShift.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#identity_token DataK8SOrgEclipseCheCheClusterV1Manifest#identity_token}
  */
  readonly identityToken?: string;
  /**
  * Deprecated. The value of this flag is ignored. For operating with the OpenShift OAuth authentication, create a new user account since the kubeadmin can not be used. If the value is true, then a new OpenShift OAuth user will be created for the HTPasswd identity provider. If the value is false and the user has already been created, then it will be removed. If value is an empty, then do nothing. The user's credentials are stored in the 'openshift-oauth-user-credentials' secret in 'openshift-config' namespace by Operator. Note that this solution is Openshift 4 platform-specific.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#initial_open_shift_o_auth_user DataK8SOrgEclipseCheCheClusterV1Manifest#initial_open_shift_o_auth_user}
  */
  readonly initialOpenShiftOAuthUser?: boolean | cdktf.IResolvable;
  /**
  * Deprecated. The value of this flag is ignored. Enables native user mode. Currently works only on OpenShift and DevWorkspace engine. Native User mode uses OpenShift OAuth directly as identity provider, without Keycloak.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#native_user_mode DataK8SOrgEclipseCheCheClusterV1Manifest#native_user_mode}
  */
  readonly nativeUserMode?: boolean | cdktf.IResolvable;
  /**
  * Name of the OpenShift 'OAuthClient' resource used to setup identity federation on the OpenShift side. Auto-generated when left blank. See also the 'OpenShiftoAuth' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#o_auth_client_name DataK8SOrgEclipseCheCheClusterV1Manifest#o_auth_client_name}
  */
  readonly oAuthClientName?: string;
  /**
  * Access Token Scope. This field is specific to Che installations made for Kubernetes only and ignored for OpenShift.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#o_auth_scope DataK8SOrgEclipseCheCheClusterV1Manifest#o_auth_scope}
  */
  readonly oAuthScope?: string;
  /**
  * Name of the secret set in the OpenShift 'OAuthClient' resource used to setup identity federation on the OpenShift side. Auto-generated when left blank. See also the 'OAuthClientName' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#o_auth_secret DataK8SOrgEclipseCheCheClusterV1Manifest#o_auth_secret}
  */
  readonly oAuthSecret?: string;
  /**
  * Deprecated. The value of this flag is ignored. Enables the integration of the identity provider (Keycloak / RHSSO) with OpenShift OAuth. Empty value on OpenShift by default. This will allow users to directly login with their OpenShift user through the OpenShift login, and have their workspaces created under personal OpenShift namespaces. WARNING: the 'kubeadmin' user is NOT supported, and logging through it will NOT allow accessing the Che Dashboard.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#open_shifto_auth DataK8SOrgEclipseCheCheClusterV1Manifest#open_shifto_auth}
  */
  readonly openShiftoAuth?: boolean | cdktf.IResolvable;
  /**
  * Deprecated. The value of this flag is ignored. Forces the default 'admin' Che user to update password on first login. Defaults to 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#update_admin_password DataK8SOrgEclipseCheCheClusterV1Manifest#update_admin_password}
  */
  readonly updateAdminPassword?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    debug: cdktf.booleanToTerraform(struct!.debug),
    external_identity_provider: cdktf.booleanToTerraform(struct!.externalIdentityProvider),
    gateway_authentication_sidecar_image: cdktf.stringToTerraform(struct!.gatewayAuthenticationSidecarImage),
    gateway_authorization_sidecar_image: cdktf.stringToTerraform(struct!.gatewayAuthorizationSidecarImage),
    gateway_config_bump_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvToTerraform, false)(struct!.gatewayConfigBumpEnv),
    gateway_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvToTerraform, false)(struct!.gatewayEnv),
    gateway_header_rewrite_sidecar_image: cdktf.stringToTerraform(struct!.gatewayHeaderRewriteSidecarImage),
    gateway_kube_rbac_proxy_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvToTerraform, false)(struct!.gatewayKubeRbacProxyEnv),
    gateway_o_auth_proxy_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvToTerraform, false)(struct!.gatewayOAuthProxyEnv),
    identity_provider_admin_user_name: cdktf.stringToTerraform(struct!.identityProviderAdminUserName),
    identity_provider_client_id: cdktf.stringToTerraform(struct!.identityProviderClientId),
    identity_provider_container_resources: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesToTerraform(struct!.identityProviderContainerResources),
    identity_provider_image: cdktf.stringToTerraform(struct!.identityProviderImage),
    identity_provider_image_pull_policy: cdktf.stringToTerraform(struct!.identityProviderImagePullPolicy),
    identity_provider_ingress: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngressToTerraform(struct!.identityProviderIngress),
    identity_provider_password: cdktf.stringToTerraform(struct!.identityProviderPassword),
    identity_provider_postgres_password: cdktf.stringToTerraform(struct!.identityProviderPostgresPassword),
    identity_provider_postgres_secret: cdktf.stringToTerraform(struct!.identityProviderPostgresSecret),
    identity_provider_realm: cdktf.stringToTerraform(struct!.identityProviderRealm),
    identity_provider_route: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRouteToTerraform(struct!.identityProviderRoute),
    identity_provider_secret: cdktf.stringToTerraform(struct!.identityProviderSecret),
    identity_provider_url: cdktf.stringToTerraform(struct!.identityProviderUrl),
    identity_token: cdktf.stringToTerraform(struct!.identityToken),
    initial_open_shift_o_auth_user: cdktf.booleanToTerraform(struct!.initialOpenShiftOAuthUser),
    native_user_mode: cdktf.booleanToTerraform(struct!.nativeUserMode),
    o_auth_client_name: cdktf.stringToTerraform(struct!.oAuthClientName),
    o_auth_scope: cdktf.stringToTerraform(struct!.oAuthScope),
    o_auth_secret: cdktf.stringToTerraform(struct!.oAuthSecret),
    open_shifto_auth: cdktf.booleanToTerraform(struct!.openShiftoAuth),
    update_admin_password: cdktf.booleanToTerraform(struct!.updateAdminPassword),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    debug: {
      value: cdktf.booleanToHclTerraform(struct!.debug),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    external_identity_provider: {
      value: cdktf.booleanToHclTerraform(struct!.externalIdentityProvider),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    gateway_authentication_sidecar_image: {
      value: cdktf.stringToHclTerraform(struct!.gatewayAuthenticationSidecarImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway_authorization_sidecar_image: {
      value: cdktf.stringToHclTerraform(struct!.gatewayAuthorizationSidecarImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway_config_bump_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvToHclTerraform, false)(struct!.gatewayConfigBumpEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvList",
    },
    gateway_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvToHclTerraform, false)(struct!.gatewayEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvList",
    },
    gateway_header_rewrite_sidecar_image: {
      value: cdktf.stringToHclTerraform(struct!.gatewayHeaderRewriteSidecarImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    gateway_kube_rbac_proxy_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvToHclTerraform, false)(struct!.gatewayKubeRbacProxyEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvList",
    },
    gateway_o_auth_proxy_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvToHclTerraform, false)(struct!.gatewayOAuthProxyEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvList",
    },
    identity_provider_admin_user_name: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderAdminUserName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_client_id: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderClientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_container_resources: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesToHclTerraform(struct!.identityProviderContainerResources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources",
    },
    identity_provider_image: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderImagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_ingress: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngressToHclTerraform(struct!.identityProviderIngress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress",
    },
    identity_provider_password: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_postgres_password: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderPostgresPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_postgres_secret: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderPostgresSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_realm: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderRealm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_route: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRouteToHclTerraform(struct!.identityProviderRoute),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute",
    },
    identity_provider_secret: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_provider_url: {
      value: cdktf.stringToHclTerraform(struct!.identityProviderUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_token: {
      value: cdktf.stringToHclTerraform(struct!.identityToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_open_shift_o_auth_user: {
      value: cdktf.booleanToHclTerraform(struct!.initialOpenShiftOAuthUser),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    native_user_mode: {
      value: cdktf.booleanToHclTerraform(struct!.nativeUserMode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    o_auth_client_name: {
      value: cdktf.stringToHclTerraform(struct!.oAuthClientName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    o_auth_scope: {
      value: cdktf.stringToHclTerraform(struct!.oAuthScope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    o_auth_secret: {
      value: cdktf.stringToHclTerraform(struct!.oAuthSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    open_shifto_auth: {
      value: cdktf.booleanToHclTerraform(struct!.openShiftoAuth),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    update_admin_password: {
      value: cdktf.booleanToHclTerraform(struct!.updateAdminPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._debug !== undefined) {
      hasAnyValues = true;
      internalValueResult.debug = this._debug;
    }
    if (this._externalIdentityProvider !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalIdentityProvider = this._externalIdentityProvider;
    }
    if (this._gatewayAuthenticationSidecarImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayAuthenticationSidecarImage = this._gatewayAuthenticationSidecarImage;
    }
    if (this._gatewayAuthorizationSidecarImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayAuthorizationSidecarImage = this._gatewayAuthorizationSidecarImage;
    }
    if (this._gatewayConfigBumpEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayConfigBumpEnv = this._gatewayConfigBumpEnv?.internalValue;
    }
    if (this._gatewayEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayEnv = this._gatewayEnv?.internalValue;
    }
    if (this._gatewayHeaderRewriteSidecarImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayHeaderRewriteSidecarImage = this._gatewayHeaderRewriteSidecarImage;
    }
    if (this._gatewayKubeRbacProxyEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayKubeRbacProxyEnv = this._gatewayKubeRbacProxyEnv?.internalValue;
    }
    if (this._gatewayOAuthProxyEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gatewayOAuthProxyEnv = this._gatewayOAuthProxyEnv?.internalValue;
    }
    if (this._identityProviderAdminUserName !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderAdminUserName = this._identityProviderAdminUserName;
    }
    if (this._identityProviderClientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderClientId = this._identityProviderClientId;
    }
    if (this._identityProviderContainerResources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderContainerResources = this._identityProviderContainerResources?.internalValue;
    }
    if (this._identityProviderImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderImage = this._identityProviderImage;
    }
    if (this._identityProviderImagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderImagePullPolicy = this._identityProviderImagePullPolicy;
    }
    if (this._identityProviderIngress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderIngress = this._identityProviderIngress?.internalValue;
    }
    if (this._identityProviderPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderPassword = this._identityProviderPassword;
    }
    if (this._identityProviderPostgresPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderPostgresPassword = this._identityProviderPostgresPassword;
    }
    if (this._identityProviderPostgresSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderPostgresSecret = this._identityProviderPostgresSecret;
    }
    if (this._identityProviderRealm !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderRealm = this._identityProviderRealm;
    }
    if (this._identityProviderRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderRoute = this._identityProviderRoute?.internalValue;
    }
    if (this._identityProviderSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderSecret = this._identityProviderSecret;
    }
    if (this._identityProviderUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityProviderUrl = this._identityProviderUrl;
    }
    if (this._identityToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityToken = this._identityToken;
    }
    if (this._initialOpenShiftOAuthUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialOpenShiftOAuthUser = this._initialOpenShiftOAuthUser;
    }
    if (this._nativeUserMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.nativeUserMode = this._nativeUserMode;
    }
    if (this._oAuthClientName !== undefined) {
      hasAnyValues = true;
      internalValueResult.oAuthClientName = this._oAuthClientName;
    }
    if (this._oAuthScope !== undefined) {
      hasAnyValues = true;
      internalValueResult.oAuthScope = this._oAuthScope;
    }
    if (this._oAuthSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.oAuthSecret = this._oAuthSecret;
    }
    if (this._openShiftoAuth !== undefined) {
      hasAnyValues = true;
      internalValueResult.openShiftoAuth = this._openShiftoAuth;
    }
    if (this._updateAdminPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.updateAdminPassword = this._updateAdminPassword;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._debug = undefined;
      this._externalIdentityProvider = undefined;
      this._gatewayAuthenticationSidecarImage = undefined;
      this._gatewayAuthorizationSidecarImage = undefined;
      this._gatewayConfigBumpEnv.internalValue = undefined;
      this._gatewayEnv.internalValue = undefined;
      this._gatewayHeaderRewriteSidecarImage = undefined;
      this._gatewayKubeRbacProxyEnv.internalValue = undefined;
      this._gatewayOAuthProxyEnv.internalValue = undefined;
      this._identityProviderAdminUserName = undefined;
      this._identityProviderClientId = undefined;
      this._identityProviderContainerResources.internalValue = undefined;
      this._identityProviderImage = undefined;
      this._identityProviderImagePullPolicy = undefined;
      this._identityProviderIngress.internalValue = undefined;
      this._identityProviderPassword = undefined;
      this._identityProviderPostgresPassword = undefined;
      this._identityProviderPostgresSecret = undefined;
      this._identityProviderRealm = undefined;
      this._identityProviderRoute.internalValue = undefined;
      this._identityProviderSecret = undefined;
      this._identityProviderUrl = undefined;
      this._identityToken = undefined;
      this._initialOpenShiftOAuthUser = undefined;
      this._nativeUserMode = undefined;
      this._oAuthClientName = undefined;
      this._oAuthScope = undefined;
      this._oAuthSecret = undefined;
      this._openShiftoAuth = undefined;
      this._updateAdminPassword = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._debug = value.debug;
      this._externalIdentityProvider = value.externalIdentityProvider;
      this._gatewayAuthenticationSidecarImage = value.gatewayAuthenticationSidecarImage;
      this._gatewayAuthorizationSidecarImage = value.gatewayAuthorizationSidecarImage;
      this._gatewayConfigBumpEnv.internalValue = value.gatewayConfigBumpEnv;
      this._gatewayEnv.internalValue = value.gatewayEnv;
      this._gatewayHeaderRewriteSidecarImage = value.gatewayHeaderRewriteSidecarImage;
      this._gatewayKubeRbacProxyEnv.internalValue = value.gatewayKubeRbacProxyEnv;
      this._gatewayOAuthProxyEnv.internalValue = value.gatewayOAuthProxyEnv;
      this._identityProviderAdminUserName = value.identityProviderAdminUserName;
      this._identityProviderClientId = value.identityProviderClientId;
      this._identityProviderContainerResources.internalValue = value.identityProviderContainerResources;
      this._identityProviderImage = value.identityProviderImage;
      this._identityProviderImagePullPolicy = value.identityProviderImagePullPolicy;
      this._identityProviderIngress.internalValue = value.identityProviderIngress;
      this._identityProviderPassword = value.identityProviderPassword;
      this._identityProviderPostgresPassword = value.identityProviderPostgresPassword;
      this._identityProviderPostgresSecret = value.identityProviderPostgresSecret;
      this._identityProviderRealm = value.identityProviderRealm;
      this._identityProviderRoute.internalValue = value.identityProviderRoute;
      this._identityProviderSecret = value.identityProviderSecret;
      this._identityProviderUrl = value.identityProviderUrl;
      this._identityToken = value.identityToken;
      this._initialOpenShiftOAuthUser = value.initialOpenShiftOAuthUser;
      this._nativeUserMode = value.nativeUserMode;
      this._oAuthClientName = value.oAuthClientName;
      this._oAuthScope = value.oAuthScope;
      this._oAuthSecret = value.oAuthSecret;
      this._openShiftoAuth = value.openShiftoAuth;
      this._updateAdminPassword = value.updateAdminPassword;
    }
  }

  // debug - computed: false, optional: true, required: false
  private _debug?: boolean | cdktf.IResolvable; 
  public get debug() {
    return this.getBooleanAttribute('debug');
  }
  public set debug(value: boolean | cdktf.IResolvable) {
    this._debug = value;
  }
  public resetDebug() {
    this._debug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get debugInput() {
    return this._debug;
  }

  // external_identity_provider - computed: false, optional: true, required: false
  private _externalIdentityProvider?: boolean | cdktf.IResolvable; 
  public get externalIdentityProvider() {
    return this.getBooleanAttribute('external_identity_provider');
  }
  public set externalIdentityProvider(value: boolean | cdktf.IResolvable) {
    this._externalIdentityProvider = value;
  }
  public resetExternalIdentityProvider() {
    this._externalIdentityProvider = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdentityProviderInput() {
    return this._externalIdentityProvider;
  }

  // gateway_authentication_sidecar_image - computed: false, optional: true, required: false
  private _gatewayAuthenticationSidecarImage?: string; 
  public get gatewayAuthenticationSidecarImage() {
    return this.getStringAttribute('gateway_authentication_sidecar_image');
  }
  public set gatewayAuthenticationSidecarImage(value: string) {
    this._gatewayAuthenticationSidecarImage = value;
  }
  public resetGatewayAuthenticationSidecarImage() {
    this._gatewayAuthenticationSidecarImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayAuthenticationSidecarImageInput() {
    return this._gatewayAuthenticationSidecarImage;
  }

  // gateway_authorization_sidecar_image - computed: false, optional: true, required: false
  private _gatewayAuthorizationSidecarImage?: string; 
  public get gatewayAuthorizationSidecarImage() {
    return this.getStringAttribute('gateway_authorization_sidecar_image');
  }
  public set gatewayAuthorizationSidecarImage(value: string) {
    this._gatewayAuthorizationSidecarImage = value;
  }
  public resetGatewayAuthorizationSidecarImage() {
    this._gatewayAuthorizationSidecarImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayAuthorizationSidecarImageInput() {
    return this._gatewayAuthorizationSidecarImage;
  }

  // gateway_config_bump_env - computed: false, optional: true, required: false
  private _gatewayConfigBumpEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnvList(this, "gateway_config_bump_env", false);
  public get gatewayConfigBumpEnv() {
    return this._gatewayConfigBumpEnv;
  }
  public putGatewayConfigBumpEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayConfigBumpEnv[] | cdktf.IResolvable) {
    this._gatewayConfigBumpEnv.internalValue = value;
  }
  public resetGatewayConfigBumpEnv() {
    this._gatewayConfigBumpEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayConfigBumpEnvInput() {
    return this._gatewayConfigBumpEnv.internalValue;
  }

  // gateway_env - computed: false, optional: true, required: false
  private _gatewayEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnvList(this, "gateway_env", false);
  public get gatewayEnv() {
    return this._gatewayEnv;
  }
  public putGatewayEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayEnv[] | cdktf.IResolvable) {
    this._gatewayEnv.internalValue = value;
  }
  public resetGatewayEnv() {
    this._gatewayEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayEnvInput() {
    return this._gatewayEnv.internalValue;
  }

  // gateway_header_rewrite_sidecar_image - computed: false, optional: true, required: false
  private _gatewayHeaderRewriteSidecarImage?: string; 
  public get gatewayHeaderRewriteSidecarImage() {
    return this.getStringAttribute('gateway_header_rewrite_sidecar_image');
  }
  public set gatewayHeaderRewriteSidecarImage(value: string) {
    this._gatewayHeaderRewriteSidecarImage = value;
  }
  public resetGatewayHeaderRewriteSidecarImage() {
    this._gatewayHeaderRewriteSidecarImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayHeaderRewriteSidecarImageInput() {
    return this._gatewayHeaderRewriteSidecarImage;
  }

  // gateway_kube_rbac_proxy_env - computed: false, optional: true, required: false
  private _gatewayKubeRbacProxyEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnvList(this, "gateway_kube_rbac_proxy_env", false);
  public get gatewayKubeRbacProxyEnv() {
    return this._gatewayKubeRbacProxyEnv;
  }
  public putGatewayKubeRbacProxyEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayKubeRbacProxyEnv[] | cdktf.IResolvable) {
    this._gatewayKubeRbacProxyEnv.internalValue = value;
  }
  public resetGatewayKubeRbacProxyEnv() {
    this._gatewayKubeRbacProxyEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayKubeRbacProxyEnvInput() {
    return this._gatewayKubeRbacProxyEnv.internalValue;
  }

  // gateway_o_auth_proxy_env - computed: false, optional: true, required: false
  private _gatewayOAuthProxyEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnvList(this, "gateway_o_auth_proxy_env", false);
  public get gatewayOAuthProxyEnv() {
    return this._gatewayOAuthProxyEnv;
  }
  public putGatewayOAuthProxyEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthGatewayOAuthProxyEnv[] | cdktf.IResolvable) {
    this._gatewayOAuthProxyEnv.internalValue = value;
  }
  public resetGatewayOAuthProxyEnv() {
    this._gatewayOAuthProxyEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gatewayOAuthProxyEnvInput() {
    return this._gatewayOAuthProxyEnv.internalValue;
  }

  // identity_provider_admin_user_name - computed: false, optional: true, required: false
  private _identityProviderAdminUserName?: string; 
  public get identityProviderAdminUserName() {
    return this.getStringAttribute('identity_provider_admin_user_name');
  }
  public set identityProviderAdminUserName(value: string) {
    this._identityProviderAdminUserName = value;
  }
  public resetIdentityProviderAdminUserName() {
    this._identityProviderAdminUserName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderAdminUserNameInput() {
    return this._identityProviderAdminUserName;
  }

  // identity_provider_client_id - computed: false, optional: true, required: false
  private _identityProviderClientId?: string; 
  public get identityProviderClientId() {
    return this.getStringAttribute('identity_provider_client_id');
  }
  public set identityProviderClientId(value: string) {
    this._identityProviderClientId = value;
  }
  public resetIdentityProviderClientId() {
    this._identityProviderClientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderClientIdInput() {
    return this._identityProviderClientId;
  }

  // identity_provider_container_resources - computed: false, optional: true, required: false
  private _identityProviderContainerResources = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResourcesOutputReference(this, "identity_provider_container_resources");
  public get identityProviderContainerResources() {
    return this._identityProviderContainerResources;
  }
  public putIdentityProviderContainerResources(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderContainerResources) {
    this._identityProviderContainerResources.internalValue = value;
  }
  public resetIdentityProviderContainerResources() {
    this._identityProviderContainerResources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderContainerResourcesInput() {
    return this._identityProviderContainerResources.internalValue;
  }

  // identity_provider_image - computed: false, optional: true, required: false
  private _identityProviderImage?: string; 
  public get identityProviderImage() {
    return this.getStringAttribute('identity_provider_image');
  }
  public set identityProviderImage(value: string) {
    this._identityProviderImage = value;
  }
  public resetIdentityProviderImage() {
    this._identityProviderImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderImageInput() {
    return this._identityProviderImage;
  }

  // identity_provider_image_pull_policy - computed: false, optional: true, required: false
  private _identityProviderImagePullPolicy?: string; 
  public get identityProviderImagePullPolicy() {
    return this.getStringAttribute('identity_provider_image_pull_policy');
  }
  public set identityProviderImagePullPolicy(value: string) {
    this._identityProviderImagePullPolicy = value;
  }
  public resetIdentityProviderImagePullPolicy() {
    this._identityProviderImagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderImagePullPolicyInput() {
    return this._identityProviderImagePullPolicy;
  }

  // identity_provider_ingress - computed: false, optional: true, required: false
  private _identityProviderIngress = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngressOutputReference(this, "identity_provider_ingress");
  public get identityProviderIngress() {
    return this._identityProviderIngress;
  }
  public putIdentityProviderIngress(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderIngress) {
    this._identityProviderIngress.internalValue = value;
  }
  public resetIdentityProviderIngress() {
    this._identityProviderIngress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderIngressInput() {
    return this._identityProviderIngress.internalValue;
  }

  // identity_provider_password - computed: false, optional: true, required: false
  private _identityProviderPassword?: string; 
  public get identityProviderPassword() {
    return this.getStringAttribute('identity_provider_password');
  }
  public set identityProviderPassword(value: string) {
    this._identityProviderPassword = value;
  }
  public resetIdentityProviderPassword() {
    this._identityProviderPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderPasswordInput() {
    return this._identityProviderPassword;
  }

  // identity_provider_postgres_password - computed: false, optional: true, required: false
  private _identityProviderPostgresPassword?: string; 
  public get identityProviderPostgresPassword() {
    return this.getStringAttribute('identity_provider_postgres_password');
  }
  public set identityProviderPostgresPassword(value: string) {
    this._identityProviderPostgresPassword = value;
  }
  public resetIdentityProviderPostgresPassword() {
    this._identityProviderPostgresPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderPostgresPasswordInput() {
    return this._identityProviderPostgresPassword;
  }

  // identity_provider_postgres_secret - computed: false, optional: true, required: false
  private _identityProviderPostgresSecret?: string; 
  public get identityProviderPostgresSecret() {
    return this.getStringAttribute('identity_provider_postgres_secret');
  }
  public set identityProviderPostgresSecret(value: string) {
    this._identityProviderPostgresSecret = value;
  }
  public resetIdentityProviderPostgresSecret() {
    this._identityProviderPostgresSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderPostgresSecretInput() {
    return this._identityProviderPostgresSecret;
  }

  // identity_provider_realm - computed: false, optional: true, required: false
  private _identityProviderRealm?: string; 
  public get identityProviderRealm() {
    return this.getStringAttribute('identity_provider_realm');
  }
  public set identityProviderRealm(value: string) {
    this._identityProviderRealm = value;
  }
  public resetIdentityProviderRealm() {
    this._identityProviderRealm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderRealmInput() {
    return this._identityProviderRealm;
  }

  // identity_provider_route - computed: false, optional: true, required: false
  private _identityProviderRoute = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRouteOutputReference(this, "identity_provider_route");
  public get identityProviderRoute() {
    return this._identityProviderRoute;
  }
  public putIdentityProviderRoute(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthIdentityProviderRoute) {
    this._identityProviderRoute.internalValue = value;
  }
  public resetIdentityProviderRoute() {
    this._identityProviderRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderRouteInput() {
    return this._identityProviderRoute.internalValue;
  }

  // identity_provider_secret - computed: false, optional: true, required: false
  private _identityProviderSecret?: string; 
  public get identityProviderSecret() {
    return this.getStringAttribute('identity_provider_secret');
  }
  public set identityProviderSecret(value: string) {
    this._identityProviderSecret = value;
  }
  public resetIdentityProviderSecret() {
    this._identityProviderSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderSecretInput() {
    return this._identityProviderSecret;
  }

  // identity_provider_url - computed: false, optional: true, required: false
  private _identityProviderUrl?: string; 
  public get identityProviderUrl() {
    return this.getStringAttribute('identity_provider_url');
  }
  public set identityProviderUrl(value: string) {
    this._identityProviderUrl = value;
  }
  public resetIdentityProviderUrl() {
    this._identityProviderUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityProviderUrlInput() {
    return this._identityProviderUrl;
  }

  // identity_token - computed: false, optional: true, required: false
  private _identityToken?: string; 
  public get identityToken() {
    return this.getStringAttribute('identity_token');
  }
  public set identityToken(value: string) {
    this._identityToken = value;
  }
  public resetIdentityToken() {
    this._identityToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityTokenInput() {
    return this._identityToken;
  }

  // initial_open_shift_o_auth_user - computed: false, optional: true, required: false
  private _initialOpenShiftOAuthUser?: boolean | cdktf.IResolvable; 
  public get initialOpenShiftOAuthUser() {
    return this.getBooleanAttribute('initial_open_shift_o_auth_user');
  }
  public set initialOpenShiftOAuthUser(value: boolean | cdktf.IResolvable) {
    this._initialOpenShiftOAuthUser = value;
  }
  public resetInitialOpenShiftOAuthUser() {
    this._initialOpenShiftOAuthUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialOpenShiftOAuthUserInput() {
    return this._initialOpenShiftOAuthUser;
  }

  // native_user_mode - computed: false, optional: true, required: false
  private _nativeUserMode?: boolean | cdktf.IResolvable; 
  public get nativeUserMode() {
    return this.getBooleanAttribute('native_user_mode');
  }
  public set nativeUserMode(value: boolean | cdktf.IResolvable) {
    this._nativeUserMode = value;
  }
  public resetNativeUserMode() {
    this._nativeUserMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nativeUserModeInput() {
    return this._nativeUserMode;
  }

  // o_auth_client_name - computed: false, optional: true, required: false
  private _oAuthClientName?: string; 
  public get oAuthClientName() {
    return this.getStringAttribute('o_auth_client_name');
  }
  public set oAuthClientName(value: string) {
    this._oAuthClientName = value;
  }
  public resetOAuthClientName() {
    this._oAuthClientName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oAuthClientNameInput() {
    return this._oAuthClientName;
  }

  // o_auth_scope - computed: false, optional: true, required: false
  private _oAuthScope?: string; 
  public get oAuthScope() {
    return this.getStringAttribute('o_auth_scope');
  }
  public set oAuthScope(value: string) {
    this._oAuthScope = value;
  }
  public resetOAuthScope() {
    this._oAuthScope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oAuthScopeInput() {
    return this._oAuthScope;
  }

  // o_auth_secret - computed: false, optional: true, required: false
  private _oAuthSecret?: string; 
  public get oAuthSecret() {
    return this.getStringAttribute('o_auth_secret');
  }
  public set oAuthSecret(value: string) {
    this._oAuthSecret = value;
  }
  public resetOAuthSecret() {
    this._oAuthSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oAuthSecretInput() {
    return this._oAuthSecret;
  }

  // open_shifto_auth - computed: false, optional: true, required: false
  private _openShiftoAuth?: boolean | cdktf.IResolvable; 
  public get openShiftoAuth() {
    return this.getBooleanAttribute('open_shifto_auth');
  }
  public set openShiftoAuth(value: boolean | cdktf.IResolvable) {
    this._openShiftoAuth = value;
  }
  public resetOpenShiftoAuth() {
    this._openShiftoAuth = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openShiftoAuthInput() {
    return this._openShiftoAuth;
  }

  // update_admin_password - computed: false, optional: true, required: false
  private _updateAdminPassword?: boolean | cdktf.IResolvable; 
  public get updateAdminPassword() {
    return this.getBooleanAttribute('update_admin_password');
  }
  public set updateAdminPassword(value: boolean | cdktf.IResolvable) {
    this._updateAdminPassword = value;
  }
  public resetUpdateAdminPassword() {
    this._updateAdminPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get updateAdminPasswordInput() {
    return this._updateAdminPassword;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard {
  /**
  * Warning message that will be displayed on the User Dashboard
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#warning DataK8SOrgEclipseCheCheClusterV1Manifest#warning}
  */
  readonly warning?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboardToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    warning: cdktf.stringToTerraform(struct!.warning),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboardToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    warning: {
      value: cdktf.stringToHclTerraform(struct!.warning),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._warning !== undefined) {
      hasAnyValues = true;
      internalValueResult.warning = this._warning;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._warning = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._warning = value.warning;
    }
  }

  // warning - computed: false, optional: true, required: false
  private _warning?: string; 
  public get warning() {
    return this.getStringAttribute('warning');
  }
  public set warning(value: string) {
    this._warning = value;
  }
  public resetWarning() {
    this._warning = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get warningInput() {
    return this._warning;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits {
  /**
  * CPU, in cores. (500m = .5 cores)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu DataK8SOrgEclipseCheCheClusterV1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory DataK8SOrgEclipseCheCheClusterV1Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimitsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimitsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest {
  /**
  * CPU, in cores. (500m = .5 cores)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu DataK8SOrgEclipseCheCheClusterV1Manifest#cpu}
  */
  readonly cpu?: string;
  /**
  * Memory, in bytes. (500Gi = 500GiB = 500 * 1024 * 1024 * 1024)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory DataK8SOrgEclipseCheCheClusterV1Manifest#memory}
  */
  readonly memory?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequestToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: cdktf.stringToTerraform(struct!.cpu),
    memory: cdktf.stringToTerraform(struct!.memory),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequestToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: cdktf.stringToHclTerraform(struct!.cpu),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory: {
      value: cdktf.stringToHclTerraform(struct!.memory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu;
    }
    if (this._memory !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu = undefined;
      this._memory = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu = value.cpu;
      this._memory = value.memory;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu?: string; 
  public get cpu() {
    return this.getStringAttribute('cpu');
  }
  public set cpu(value: string) {
    this._cpu = value;
  }
  public resetCpu() {
    this._cpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu;
  }

  // memory - computed: false, optional: true, required: false
  private _memory?: string; 
  public get memory() {
    return this.getStringAttribute('memory');
  }
  public set memory(value: string) {
    this._memory = value;
  }
  public resetMemory() {
    this._memory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources {
  /**
  * Limits describes the maximum amount of compute resources allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#limits DataK8SOrgEclipseCheCheClusterV1Manifest#limits}
  */
  readonly limits?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits;
  /**
  * Requests describes the minimum amount of compute resources required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#request DataK8SOrgEclipseCheCheClusterV1Manifest#request}
  */
  readonly request?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    limits: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimitsToTerraform(struct!.limits),
    request: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequestToTerraform(struct!.request),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    limits: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimitsToHclTerraform(struct!.limits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits",
    },
    request: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._limits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limits = this._limits?.internalValue;
    }
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._limits.internalValue = undefined;
      this._request.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._limits.internalValue = value.limits;
      this._request.internalValue = value.request;
    }
  }

  // limits - computed: false, optional: true, required: false
  private _limits = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimitsOutputReference(this, "limits");
  public get limits() {
    return this._limits;
  }
  public putLimits(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesLimits) {
    this._limits.internalValue = value;
  }
  public resetLimits() {
    this._limits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitsInput() {
    return this._limits.internalValue;
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase {
  /**
  * PostgreSQL container custom settings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_postgres_container_resources DataK8SOrgEclipseCheCheClusterV1Manifest#che_postgres_container_resources}
  */
  readonly chePostgresContainerResources?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources;
  /**
  * PostgreSQL database name that the Che server uses to connect to the DB. Defaults to 'dbche'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_postgres_db DataK8SOrgEclipseCheCheClusterV1Manifest#che_postgres_db}
  */
  readonly chePostgresDb?: string;
  /**
  * PostgreSQL Database host name that the Che server uses to connect to. Defaults is 'postgres'. Override this value ONLY when using an external database. See field 'externalDb'. In the default case it will be automatically set by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_postgres_host_name DataK8SOrgEclipseCheCheClusterV1Manifest#che_postgres_host_name}
  */
  readonly chePostgresHostName?: string;
  /**
  * PostgreSQL password that the Che server uses to connect to the DB. When omitted or left blank, it will be set to an automatically generated value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_postgres_password DataK8SOrgEclipseCheCheClusterV1Manifest#che_postgres_password}
  */
  readonly chePostgresPassword?: string;
  /**
  * PostgreSQL Database port that the Che server uses to connect to. Defaults to 5432. Override this value ONLY when using an external database. See field 'externalDb'. In the default case it will be automatically set by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_postgres_port DataK8SOrgEclipseCheCheClusterV1Manifest#che_postgres_port}
  */
  readonly chePostgresPort?: string;
  /**
  * The secret that contains PostgreSQL'user' and 'password' that the Che server uses to connect to the DB. When the secret is defined, the 'chePostgresUser' and 'chePostgresPassword' are ignored. When the value is omitted or left blank, the one of following scenarios applies: 1. 'chePostgresUser' and 'chePostgresPassword' are defined, then they will be used to connect to the DB. 2. 'chePostgresUser' or 'chePostgresPassword' are not defined, then a new secret with the name 'postgres-credentials' will be created with default value of 'pgche' for 'user' and with an auto-generated value for 'password'. The secret must have 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_postgres_secret DataK8SOrgEclipseCheCheClusterV1Manifest#che_postgres_secret}
  */
  readonly chePostgresSecret?: string;
  /**
  * PostgreSQL user that the Che server uses to connect to the DB. Defaults to 'pgche'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_postgres_user DataK8SOrgEclipseCheCheClusterV1Manifest#che_postgres_user}
  */
  readonly chePostgresUser?: string;
  /**
  * Instructs the Operator on whether to deploy a dedicated database. By default, a dedicated PostgreSQL database is deployed as part of the Che installation. When 'externalDb' is 'true', no dedicated database will be deployed by the Operator and you will need to provide connection details to the external DB you are about to use. See also all the fields starting with: 'chePostgres'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#external_db DataK8SOrgEclipseCheCheClusterV1Manifest#external_db}
  */
  readonly externalDb?: boolean | cdktf.IResolvable;
  /**
  * List of environment variables to set in the PostgreSQL container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#postgres_env DataK8SOrgEclipseCheCheClusterV1Manifest#postgres_env}
  */
  readonly postgresEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv[] | cdktf.IResolvable;
  /**
  * Overrides the container image used in the PostgreSQL database deployment. This includes the image tag. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#postgres_image DataK8SOrgEclipseCheCheClusterV1Manifest#postgres_image}
  */
  readonly postgresImage?: string;
  /**
  * Overrides the image pull policy used in the PostgreSQL database deployment. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#postgres_image_pull_policy DataK8SOrgEclipseCheCheClusterV1Manifest#postgres_image_pull_policy}
  */
  readonly postgresImagePullPolicy?: string;
  /**
  * Indicates a PostgreSQL version image to use. Allowed values are: '9.6' and '13.3'. Migrate your PostgreSQL database to switch from one version to another.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#postgres_version DataK8SOrgEclipseCheCheClusterV1Manifest#postgres_version}
  */
  readonly postgresVersion?: string;
  /**
  * Size of the persistent volume claim for database. Defaults to '1Gi'. To update pvc storageclass that provisions it must support resize when Eclipse Che has been already deployed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#pvc_claim_size DataK8SOrgEclipseCheCheClusterV1Manifest#pvc_claim_size}
  */
  readonly pvcClaimSize?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    che_postgres_container_resources: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesToTerraform(struct!.chePostgresContainerResources),
    che_postgres_db: cdktf.stringToTerraform(struct!.chePostgresDb),
    che_postgres_host_name: cdktf.stringToTerraform(struct!.chePostgresHostName),
    che_postgres_password: cdktf.stringToTerraform(struct!.chePostgresPassword),
    che_postgres_port: cdktf.stringToTerraform(struct!.chePostgresPort),
    che_postgres_secret: cdktf.stringToTerraform(struct!.chePostgresSecret),
    che_postgres_user: cdktf.stringToTerraform(struct!.chePostgresUser),
    external_db: cdktf.booleanToTerraform(struct!.externalDb),
    postgres_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvToTerraform, false)(struct!.postgresEnv),
    postgres_image: cdktf.stringToTerraform(struct!.postgresImage),
    postgres_image_pull_policy: cdktf.stringToTerraform(struct!.postgresImagePullPolicy),
    postgres_version: cdktf.stringToTerraform(struct!.postgresVersion),
    pvc_claim_size: cdktf.stringToTerraform(struct!.pvcClaimSize),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    che_postgres_container_resources: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesToHclTerraform(struct!.chePostgresContainerResources),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources",
    },
    che_postgres_db: {
      value: cdktf.stringToHclTerraform(struct!.chePostgresDb),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_postgres_host_name: {
      value: cdktf.stringToHclTerraform(struct!.chePostgresHostName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_postgres_password: {
      value: cdktf.stringToHclTerraform(struct!.chePostgresPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_postgres_port: {
      value: cdktf.stringToHclTerraform(struct!.chePostgresPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_postgres_secret: {
      value: cdktf.stringToHclTerraform(struct!.chePostgresSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_postgres_user: {
      value: cdktf.stringToHclTerraform(struct!.chePostgresUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    external_db: {
      value: cdktf.booleanToHclTerraform(struct!.externalDb),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    postgres_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvToHclTerraform, false)(struct!.postgresEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvList",
    },
    postgres_image: {
      value: cdktf.stringToHclTerraform(struct!.postgresImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.postgresImagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_version: {
      value: cdktf.stringToHclTerraform(struct!.postgresVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pvc_claim_size: {
      value: cdktf.stringToHclTerraform(struct!.pvcClaimSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._chePostgresContainerResources?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.chePostgresContainerResources = this._chePostgresContainerResources?.internalValue;
    }
    if (this._chePostgresDb !== undefined) {
      hasAnyValues = true;
      internalValueResult.chePostgresDb = this._chePostgresDb;
    }
    if (this._chePostgresHostName !== undefined) {
      hasAnyValues = true;
      internalValueResult.chePostgresHostName = this._chePostgresHostName;
    }
    if (this._chePostgresPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.chePostgresPassword = this._chePostgresPassword;
    }
    if (this._chePostgresPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.chePostgresPort = this._chePostgresPort;
    }
    if (this._chePostgresSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.chePostgresSecret = this._chePostgresSecret;
    }
    if (this._chePostgresUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.chePostgresUser = this._chePostgresUser;
    }
    if (this._externalDb !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalDb = this._externalDb;
    }
    if (this._postgresEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresEnv = this._postgresEnv?.internalValue;
    }
    if (this._postgresImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresImage = this._postgresImage;
    }
    if (this._postgresImagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresImagePullPolicy = this._postgresImagePullPolicy;
    }
    if (this._postgresVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresVersion = this._postgresVersion;
    }
    if (this._pvcClaimSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pvcClaimSize = this._pvcClaimSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._chePostgresContainerResources.internalValue = undefined;
      this._chePostgresDb = undefined;
      this._chePostgresHostName = undefined;
      this._chePostgresPassword = undefined;
      this._chePostgresPort = undefined;
      this._chePostgresSecret = undefined;
      this._chePostgresUser = undefined;
      this._externalDb = undefined;
      this._postgresEnv.internalValue = undefined;
      this._postgresImage = undefined;
      this._postgresImagePullPolicy = undefined;
      this._postgresVersion = undefined;
      this._pvcClaimSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._chePostgresContainerResources.internalValue = value.chePostgresContainerResources;
      this._chePostgresDb = value.chePostgresDb;
      this._chePostgresHostName = value.chePostgresHostName;
      this._chePostgresPassword = value.chePostgresPassword;
      this._chePostgresPort = value.chePostgresPort;
      this._chePostgresSecret = value.chePostgresSecret;
      this._chePostgresUser = value.chePostgresUser;
      this._externalDb = value.externalDb;
      this._postgresEnv.internalValue = value.postgresEnv;
      this._postgresImage = value.postgresImage;
      this._postgresImagePullPolicy = value.postgresImagePullPolicy;
      this._postgresVersion = value.postgresVersion;
      this._pvcClaimSize = value.pvcClaimSize;
    }
  }

  // che_postgres_container_resources - computed: false, optional: true, required: false
  private _chePostgresContainerResources = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResourcesOutputReference(this, "che_postgres_container_resources");
  public get chePostgresContainerResources() {
    return this._chePostgresContainerResources;
  }
  public putChePostgresContainerResources(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseChePostgresContainerResources) {
    this._chePostgresContainerResources.internalValue = value;
  }
  public resetChePostgresContainerResources() {
    this._chePostgresContainerResources.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chePostgresContainerResourcesInput() {
    return this._chePostgresContainerResources.internalValue;
  }

  // che_postgres_db - computed: false, optional: true, required: false
  private _chePostgresDb?: string; 
  public get chePostgresDb() {
    return this.getStringAttribute('che_postgres_db');
  }
  public set chePostgresDb(value: string) {
    this._chePostgresDb = value;
  }
  public resetChePostgresDb() {
    this._chePostgresDb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chePostgresDbInput() {
    return this._chePostgresDb;
  }

  // che_postgres_host_name - computed: false, optional: true, required: false
  private _chePostgresHostName?: string; 
  public get chePostgresHostName() {
    return this.getStringAttribute('che_postgres_host_name');
  }
  public set chePostgresHostName(value: string) {
    this._chePostgresHostName = value;
  }
  public resetChePostgresHostName() {
    this._chePostgresHostName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chePostgresHostNameInput() {
    return this._chePostgresHostName;
  }

  // che_postgres_password - computed: false, optional: true, required: false
  private _chePostgresPassword?: string; 
  public get chePostgresPassword() {
    return this.getStringAttribute('che_postgres_password');
  }
  public set chePostgresPassword(value: string) {
    this._chePostgresPassword = value;
  }
  public resetChePostgresPassword() {
    this._chePostgresPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chePostgresPasswordInput() {
    return this._chePostgresPassword;
  }

  // che_postgres_port - computed: false, optional: true, required: false
  private _chePostgresPort?: string; 
  public get chePostgresPort() {
    return this.getStringAttribute('che_postgres_port');
  }
  public set chePostgresPort(value: string) {
    this._chePostgresPort = value;
  }
  public resetChePostgresPort() {
    this._chePostgresPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chePostgresPortInput() {
    return this._chePostgresPort;
  }

  // che_postgres_secret - computed: false, optional: true, required: false
  private _chePostgresSecret?: string; 
  public get chePostgresSecret() {
    return this.getStringAttribute('che_postgres_secret');
  }
  public set chePostgresSecret(value: string) {
    this._chePostgresSecret = value;
  }
  public resetChePostgresSecret() {
    this._chePostgresSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chePostgresSecretInput() {
    return this._chePostgresSecret;
  }

  // che_postgres_user - computed: false, optional: true, required: false
  private _chePostgresUser?: string; 
  public get chePostgresUser() {
    return this.getStringAttribute('che_postgres_user');
  }
  public set chePostgresUser(value: string) {
    this._chePostgresUser = value;
  }
  public resetChePostgresUser() {
    this._chePostgresUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get chePostgresUserInput() {
    return this._chePostgresUser;
  }

  // external_db - computed: false, optional: true, required: false
  private _externalDb?: boolean | cdktf.IResolvable; 
  public get externalDb() {
    return this.getBooleanAttribute('external_db');
  }
  public set externalDb(value: boolean | cdktf.IResolvable) {
    this._externalDb = value;
  }
  public resetExternalDb() {
    this._externalDb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalDbInput() {
    return this._externalDb;
  }

  // postgres_env - computed: false, optional: true, required: false
  private _postgresEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnvList(this, "postgres_env", false);
  public get postgresEnv() {
    return this._postgresEnv;
  }
  public putPostgresEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabasePostgresEnv[] | cdktf.IResolvable) {
    this._postgresEnv.internalValue = value;
  }
  public resetPostgresEnv() {
    this._postgresEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresEnvInput() {
    return this._postgresEnv.internalValue;
  }

  // postgres_image - computed: false, optional: true, required: false
  private _postgresImage?: string; 
  public get postgresImage() {
    return this.getStringAttribute('postgres_image');
  }
  public set postgresImage(value: string) {
    this._postgresImage = value;
  }
  public resetPostgresImage() {
    this._postgresImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresImageInput() {
    return this._postgresImage;
  }

  // postgres_image_pull_policy - computed: false, optional: true, required: false
  private _postgresImagePullPolicy?: string; 
  public get postgresImagePullPolicy() {
    return this.getStringAttribute('postgres_image_pull_policy');
  }
  public set postgresImagePullPolicy(value: string) {
    this._postgresImagePullPolicy = value;
  }
  public resetPostgresImagePullPolicy() {
    this._postgresImagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresImagePullPolicyInput() {
    return this._postgresImagePullPolicy;
  }

  // postgres_version - computed: false, optional: true, required: false
  private _postgresVersion?: string; 
  public get postgresVersion() {
    return this.getStringAttribute('postgres_version');
  }
  public set postgresVersion(value: string) {
    this._postgresVersion = value;
  }
  public resetPostgresVersion() {
    this._postgresVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresVersionInput() {
    return this._postgresVersion;
  }

  // pvc_claim_size - computed: false, optional: true, required: false
  private _pvcClaimSize?: string; 
  public get pvcClaimSize() {
    return this.getStringAttribute('pvc_claim_size');
  }
  public set pvcClaimSize(value: string) {
    this._pvcClaimSize = value;
  }
  public resetPvcClaimSize() {
    this._pvcClaimSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pvcClaimSizeInput() {
    return this._pvcClaimSize;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace {
  /**
  * Overrides the container image used in the DevWorkspace controller deployment. This includes the image tag. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#controller_image DataK8SOrgEclipseCheCheClusterV1Manifest#controller_image}
  */
  readonly controllerImage?: string;
  /**
  * Deploys the DevWorkspace Operator in the cluster. Does nothing when a matching version of the Operator is already installed. Fails when a non-matching version of the Operator is already installed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#enable DataK8SOrgEclipseCheCheClusterV1Manifest#enable}
  */
  readonly enable: boolean | cdktf.IResolvable;
  /**
  * List of environment variables to set in the DevWorkspace container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#env DataK8SOrgEclipseCheCheClusterV1Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv[] | cdktf.IResolvable;
  /**
  * Maximum number of the running workspaces per user.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#running_limit DataK8SOrgEclipseCheCheClusterV1Manifest#running_limit}
  */
  readonly runningLimit?: string;
  /**
  * Idle timeout for workspaces in seconds. This timeout is the duration after which a workspace will be idled if there is no activity. To disable workspace idling due to inactivity, set this value to -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#seconds_of_inactivity_before_idling DataK8SOrgEclipseCheCheClusterV1Manifest#seconds_of_inactivity_before_idling}
  */
  readonly secondsOfInactivityBeforeIdling?: number;
  /**
  * Run timeout for workspaces in seconds. This timeout is the maximum duration a workspace runs. To disable workspace run timeout, set this value to -1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#seconds_of_run_before_idling DataK8SOrgEclipseCheCheClusterV1Manifest#seconds_of_run_before_idling}
  */
  readonly secondsOfRunBeforeIdling?: number;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    controller_image: cdktf.stringToTerraform(struct!.controllerImage),
    enable: cdktf.booleanToTerraform(struct!.enable),
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvToTerraform, false)(struct!.env),
    running_limit: cdktf.stringToTerraform(struct!.runningLimit),
    seconds_of_inactivity_before_idling: cdktf.numberToTerraform(struct!.secondsOfInactivityBeforeIdling),
    seconds_of_run_before_idling: cdktf.numberToTerraform(struct!.secondsOfRunBeforeIdling),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    controller_image: {
      value: cdktf.stringToHclTerraform(struct!.controllerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvList",
    },
    running_limit: {
      value: cdktf.stringToHclTerraform(struct!.runningLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    seconds_of_inactivity_before_idling: {
      value: cdktf.numberToHclTerraform(struct!.secondsOfInactivityBeforeIdling),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    seconds_of_run_before_idling: {
      value: cdktf.numberToHclTerraform(struct!.secondsOfRunBeforeIdling),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._controllerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.controllerImage = this._controllerImage;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._runningLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.runningLimit = this._runningLimit;
    }
    if (this._secondsOfInactivityBeforeIdling !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondsOfInactivityBeforeIdling = this._secondsOfInactivityBeforeIdling;
    }
    if (this._secondsOfRunBeforeIdling !== undefined) {
      hasAnyValues = true;
      internalValueResult.secondsOfRunBeforeIdling = this._secondsOfRunBeforeIdling;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._controllerImage = undefined;
      this._enable = undefined;
      this._env.internalValue = undefined;
      this._runningLimit = undefined;
      this._secondsOfInactivityBeforeIdling = undefined;
      this._secondsOfRunBeforeIdling = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._controllerImage = value.controllerImage;
      this._enable = value.enable;
      this._env.internalValue = value.env;
      this._runningLimit = value.runningLimit;
      this._secondsOfInactivityBeforeIdling = value.secondsOfInactivityBeforeIdling;
      this._secondsOfRunBeforeIdling = value.secondsOfRunBeforeIdling;
    }
  }

  // controller_image - computed: false, optional: true, required: false
  private _controllerImage?: string; 
  public get controllerImage() {
    return this.getStringAttribute('controller_image');
  }
  public set controllerImage(value: string) {
    this._controllerImage = value;
  }
  public resetControllerImage() {
    this._controllerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get controllerImageInput() {
    return this._controllerImage;
  }

  // enable - computed: false, optional: false, required: true
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // running_limit - computed: false, optional: true, required: false
  private _runningLimit?: string; 
  public get runningLimit() {
    return this.getStringAttribute('running_limit');
  }
  public set runningLimit(value: string) {
    this._runningLimit = value;
  }
  public resetRunningLimit() {
    this._runningLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runningLimitInput() {
    return this._runningLimit;
  }

  // seconds_of_inactivity_before_idling - computed: false, optional: true, required: false
  private _secondsOfInactivityBeforeIdling?: number; 
  public get secondsOfInactivityBeforeIdling() {
    return this.getNumberAttribute('seconds_of_inactivity_before_idling');
  }
  public set secondsOfInactivityBeforeIdling(value: number) {
    this._secondsOfInactivityBeforeIdling = value;
  }
  public resetSecondsOfInactivityBeforeIdling() {
    this._secondsOfInactivityBeforeIdling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsOfInactivityBeforeIdlingInput() {
    return this._secondsOfInactivityBeforeIdling;
  }

  // seconds_of_run_before_idling - computed: false, optional: true, required: false
  private _secondsOfRunBeforeIdling?: number; 
  public get secondsOfRunBeforeIdling() {
    return this.getNumberAttribute('seconds_of_run_before_idling');
  }
  public set secondsOfRunBeforeIdling(value: number) {
    this._secondsOfRunBeforeIdling = value;
  }
  public resetSecondsOfRunBeforeIdling() {
    this._secondsOfRunBeforeIdling = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secondsOfRunBeforeIdlingInput() {
    return this._secondsOfRunBeforeIdling;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket {
  /**
  * Bitbucket server endpoint URL. Deprecated in favor of 'che.eclipse.org/scm-server-endpoint' annotation. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-1-for-a-bitbucket-server/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoint DataK8SOrgEclipseCheCheClusterV1Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Kubernetes secret, that contains Base64-encoded Bitbucket OAuth 1.0 or OAuth 2.0 data. See the following pages for details: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-1-for-a-bitbucket-server/ and https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-the-bitbucket-cloud/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_name DataK8SOrgEclipseCheCheClusterV1Manifest#secret_name}
  */
  readonly secretName: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint = value.endpoint;
      this._secretName = value.secretName;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub {
  /**
  * GitHub server endpoint URL. Deprecated in favor of 'che.eclipse.org/scm-server-endpoint' annotation. See the following page for details: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-github/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoint DataK8SOrgEclipseCheCheClusterV1Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Kubernetes secret, that contains Base64-encoded GitHub OAuth Client id and GitHub OAuth Client secret. See the following page for details: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-github/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_name DataK8SOrgEclipseCheCheClusterV1Manifest#secret_name}
  */
  readonly secretName: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint = value.endpoint;
      this._secretName = value.secretName;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab {
  /**
  * GitLab server endpoint URL. Deprecated in favor of 'che.eclipse.org/scm-server-endpoint' annotation. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-gitlab/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoint DataK8SOrgEclipseCheCheClusterV1Manifest#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Kubernetes secret, that contains Base64-encoded GitHub Application id and GitLab Application Client secret. See the following page: https://www.eclipse.org/che/docs/stable/administration-guide/configuring-oauth-2-for-gitlab/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_name DataK8SOrgEclipseCheCheClusterV1Manifest#secret_name}
  */
  readonly secretName: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._endpoint = undefined;
      this._secretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._endpoint = value.endpoint;
      this._secretName = value.secretName;
    }
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // secret_name - computed: false, optional: false, required: true
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices {
  /**
  * Enables users to work with repositories hosted on Bitbucket (bitbucket.org or self-hosted).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#bitbucket DataK8SOrgEclipseCheCheClusterV1Manifest#bitbucket}
  */
  readonly bitbucket?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket[] | cdktf.IResolvable;
  /**
  * Enables users to work with repositories hosted on GitHub (github.com or GitHub Enterprise).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#github DataK8SOrgEclipseCheCheClusterV1Manifest#github}
  */
  readonly github?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub[] | cdktf.IResolvable;
  /**
  * Enables users to work with repositories hosted on GitLab (gitlab.com or self-hosted).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#gitlab DataK8SOrgEclipseCheCheClusterV1Manifest#gitlab}
  */
  readonly gitlab?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bitbucket: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketToTerraform, false)(struct!.bitbucket),
    github: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubToTerraform, false)(struct!.github),
    gitlab: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabToTerraform, false)(struct!.gitlab),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bitbucket: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketToHclTerraform, false)(struct!.bitbucket),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketList",
    },
    github: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubToHclTerraform, false)(struct!.github),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubList",
    },
    gitlab: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabToHclTerraform, false)(struct!.gitlab),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bitbucket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bitbucket = this._bitbucket?.internalValue;
    }
    if (this._github?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.github = this._github?.internalValue;
    }
    if (this._gitlab?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitlab = this._gitlab?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bitbucket.internalValue = undefined;
      this._github.internalValue = undefined;
      this._gitlab.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bitbucket.internalValue = value.bitbucket;
      this._github.internalValue = value.github;
      this._gitlab.internalValue = value.gitlab;
    }
  }

  // bitbucket - computed: false, optional: true, required: false
  private _bitbucket = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucketList(this, "bitbucket", false);
  public get bitbucket() {
    return this._bitbucket;
  }
  public putBitbucket(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesBitbucket[] | cdktf.IResolvable) {
    this._bitbucket.internalValue = value;
  }
  public resetBitbucket() {
    this._bitbucket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitbucketInput() {
    return this._bitbucket.internalValue;
  }

  // github - computed: false, optional: true, required: false
  private _github = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithubList(this, "github", false);
  public get github() {
    return this._github;
  }
  public putGithub(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGithub[] | cdktf.IResolvable) {
    this._github.internalValue = value;
  }
  public resetGithub() {
    this._github.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get githubInput() {
    return this._github.internalValue;
  }

  // gitlab - computed: false, optional: true, required: false
  private _gitlab = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlabList(this, "gitlab", false);
  public get gitlab() {
    return this._gitlab;
  }
  public putGitlab(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesGitlab[] | cdktf.IResolvable) {
    this._gitlab.internalValue = value;
  }
  public resetGitlab() {
    this._gitlab.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitlabInput() {
    return this._gitlab.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#affinity DataK8SOrgEclipseCheCheClusterV1Manifest#affinity}
  */
  readonly affinity?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#caching_cpu_limit DataK8SOrgEclipseCheCheClusterV1Manifest#caching_cpu_limit}
  */
  readonly cachingCpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#caching_cpu_request DataK8SOrgEclipseCheCheClusterV1Manifest#caching_cpu_request}
  */
  readonly cachingCpuRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#caching_interval_hours DataK8SOrgEclipseCheCheClusterV1Manifest#caching_interval_hours}
  */
  readonly cachingIntervalHours?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#caching_memory_limit DataK8SOrgEclipseCheCheClusterV1Manifest#caching_memory_limit}
  */
  readonly cachingMemoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#caching_memory_request DataK8SOrgEclipseCheCheClusterV1Manifest#caching_memory_request}
  */
  readonly cachingMemoryRequest?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_name DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_name}
  */
  readonly configMapName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#daemonset_name DataK8SOrgEclipseCheCheClusterV1Manifest#daemonset_name}
  */
  readonly daemonsetName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#deployment_name DataK8SOrgEclipseCheCheClusterV1Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image_pull_secrets DataK8SOrgEclipseCheCheClusterV1Manifest#image_pull_secrets}
  */
  readonly imagePullSecrets?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image_puller_image DataK8SOrgEclipseCheCheClusterV1Manifest#image_puller_image}
  */
  readonly imagePullerImage?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#images DataK8SOrgEclipseCheCheClusterV1Manifest#images}
  */
  readonly images?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#node_selector DataK8SOrgEclipseCheCheClusterV1Manifest#node_selector}
  */
  readonly nodeSelector?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpecToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    affinity: cdktf.stringToTerraform(struct!.affinity),
    caching_cpu_limit: cdktf.stringToTerraform(struct!.cachingCpuLimit),
    caching_cpu_request: cdktf.stringToTerraform(struct!.cachingCpuRequest),
    caching_interval_hours: cdktf.stringToTerraform(struct!.cachingIntervalHours),
    caching_memory_limit: cdktf.stringToTerraform(struct!.cachingMemoryLimit),
    caching_memory_request: cdktf.stringToTerraform(struct!.cachingMemoryRequest),
    config_map_name: cdktf.stringToTerraform(struct!.configMapName),
    daemonset_name: cdktf.stringToTerraform(struct!.daemonsetName),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    image_pull_secrets: cdktf.stringToTerraform(struct!.imagePullSecrets),
    image_puller_image: cdktf.stringToTerraform(struct!.imagePullerImage),
    images: cdktf.stringToTerraform(struct!.images),
    node_selector: cdktf.stringToTerraform(struct!.nodeSelector),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpecToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    affinity: {
      value: cdktf.stringToHclTerraform(struct!.affinity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cachingCpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cachingCpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_interval_hours: {
      value: cdktf.stringToHclTerraform(struct!.cachingIntervalHours),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.cachingMemoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    caching_memory_request: {
      value: cdktf.stringToHclTerraform(struct!.cachingMemoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    config_map_name: {
      value: cdktf.stringToHclTerraform(struct!.configMapName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    daemonset_name: {
      value: cdktf.stringToHclTerraform(struct!.daemonsetName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secrets: {
      value: cdktf.stringToHclTerraform(struct!.imagePullSecrets),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_puller_image: {
      value: cdktf.stringToHclTerraform(struct!.imagePullerImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    images: {
      value: cdktf.stringToHclTerraform(struct!.images),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_selector: {
      value: cdktf.stringToHclTerraform(struct!.nodeSelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._affinity !== undefined) {
      hasAnyValues = true;
      internalValueResult.affinity = this._affinity;
    }
    if (this._cachingCpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingCpuLimit = this._cachingCpuLimit;
    }
    if (this._cachingCpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingCpuRequest = this._cachingCpuRequest;
    }
    if (this._cachingIntervalHours !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingIntervalHours = this._cachingIntervalHours;
    }
    if (this._cachingMemoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingMemoryLimit = this._cachingMemoryLimit;
    }
    if (this._cachingMemoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cachingMemoryRequest = this._cachingMemoryRequest;
    }
    if (this._configMapName !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapName = this._configMapName;
    }
    if (this._daemonsetName !== undefined) {
      hasAnyValues = true;
      internalValueResult.daemonsetName = this._daemonsetName;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._imagePullSecrets !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecrets = this._imagePullSecrets;
    }
    if (this._imagePullerImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullerImage = this._imagePullerImage;
    }
    if (this._images !== undefined) {
      hasAnyValues = true;
      internalValueResult.images = this._images;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._affinity = undefined;
      this._cachingCpuLimit = undefined;
      this._cachingCpuRequest = undefined;
      this._cachingIntervalHours = undefined;
      this._cachingMemoryLimit = undefined;
      this._cachingMemoryRequest = undefined;
      this._configMapName = undefined;
      this._daemonsetName = undefined;
      this._deploymentName = undefined;
      this._imagePullSecrets = undefined;
      this._imagePullerImage = undefined;
      this._images = undefined;
      this._nodeSelector = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._affinity = value.affinity;
      this._cachingCpuLimit = value.cachingCpuLimit;
      this._cachingCpuRequest = value.cachingCpuRequest;
      this._cachingIntervalHours = value.cachingIntervalHours;
      this._cachingMemoryLimit = value.cachingMemoryLimit;
      this._cachingMemoryRequest = value.cachingMemoryRequest;
      this._configMapName = value.configMapName;
      this._daemonsetName = value.daemonsetName;
      this._deploymentName = value.deploymentName;
      this._imagePullSecrets = value.imagePullSecrets;
      this._imagePullerImage = value.imagePullerImage;
      this._images = value.images;
      this._nodeSelector = value.nodeSelector;
    }
  }

  // affinity - computed: false, optional: true, required: false
  private _affinity?: string; 
  public get affinity() {
    return this.getStringAttribute('affinity');
  }
  public set affinity(value: string) {
    this._affinity = value;
  }
  public resetAffinity() {
    this._affinity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affinityInput() {
    return this._affinity;
  }

  // caching_cpu_limit - computed: false, optional: true, required: false
  private _cachingCpuLimit?: string; 
  public get cachingCpuLimit() {
    return this.getStringAttribute('caching_cpu_limit');
  }
  public set cachingCpuLimit(value: string) {
    this._cachingCpuLimit = value;
  }
  public resetCachingCpuLimit() {
    this._cachingCpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingCpuLimitInput() {
    return this._cachingCpuLimit;
  }

  // caching_cpu_request - computed: false, optional: true, required: false
  private _cachingCpuRequest?: string; 
  public get cachingCpuRequest() {
    return this.getStringAttribute('caching_cpu_request');
  }
  public set cachingCpuRequest(value: string) {
    this._cachingCpuRequest = value;
  }
  public resetCachingCpuRequest() {
    this._cachingCpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingCpuRequestInput() {
    return this._cachingCpuRequest;
  }

  // caching_interval_hours - computed: false, optional: true, required: false
  private _cachingIntervalHours?: string; 
  public get cachingIntervalHours() {
    return this.getStringAttribute('caching_interval_hours');
  }
  public set cachingIntervalHours(value: string) {
    this._cachingIntervalHours = value;
  }
  public resetCachingIntervalHours() {
    this._cachingIntervalHours = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingIntervalHoursInput() {
    return this._cachingIntervalHours;
  }

  // caching_memory_limit - computed: false, optional: true, required: false
  private _cachingMemoryLimit?: string; 
  public get cachingMemoryLimit() {
    return this.getStringAttribute('caching_memory_limit');
  }
  public set cachingMemoryLimit(value: string) {
    this._cachingMemoryLimit = value;
  }
  public resetCachingMemoryLimit() {
    this._cachingMemoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingMemoryLimitInput() {
    return this._cachingMemoryLimit;
  }

  // caching_memory_request - computed: false, optional: true, required: false
  private _cachingMemoryRequest?: string; 
  public get cachingMemoryRequest() {
    return this.getStringAttribute('caching_memory_request');
  }
  public set cachingMemoryRequest(value: string) {
    this._cachingMemoryRequest = value;
  }
  public resetCachingMemoryRequest() {
    this._cachingMemoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cachingMemoryRequestInput() {
    return this._cachingMemoryRequest;
  }

  // config_map_name - computed: false, optional: true, required: false
  private _configMapName?: string; 
  public get configMapName() {
    return this.getStringAttribute('config_map_name');
  }
  public set configMapName(value: string) {
    this._configMapName = value;
  }
  public resetConfigMapName() {
    this._configMapName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapNameInput() {
    return this._configMapName;
  }

  // daemonset_name - computed: false, optional: true, required: false
  private _daemonsetName?: string; 
  public get daemonsetName() {
    return this.getStringAttribute('daemonset_name');
  }
  public set daemonsetName(value: string) {
    this._daemonsetName = value;
  }
  public resetDaemonsetName() {
    this._daemonsetName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get daemonsetNameInput() {
    return this._daemonsetName;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // image_pull_secrets - computed: false, optional: true, required: false
  private _imagePullSecrets?: string; 
  public get imagePullSecrets() {
    return this.getStringAttribute('image_pull_secrets');
  }
  public set imagePullSecrets(value: string) {
    this._imagePullSecrets = value;
  }
  public resetImagePullSecrets() {
    this._imagePullSecrets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretsInput() {
    return this._imagePullSecrets;
  }

  // image_puller_image - computed: false, optional: true, required: false
  private _imagePullerImage?: string; 
  public get imagePullerImage() {
    return this.getStringAttribute('image_puller_image');
  }
  public set imagePullerImage(value: string) {
    this._imagePullerImage = value;
  }
  public resetImagePullerImage() {
    this._imagePullerImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullerImageInput() {
    return this._imagePullerImage;
  }

  // images - computed: false, optional: true, required: false
  private _images?: string; 
  public get images() {
    return this.getStringAttribute('images');
  }
  public set images(value: string) {
    this._images = value;
  }
  public resetImages() {
    this._images = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagesInput() {
    return this._images;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: string; 
  public get nodeSelector() {
    return this.getStringAttribute('node_selector');
  }
  public set nodeSelector(value: string) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller {
  /**
  * Install and configure the Community Supported Kubernetes Image Puller Operator. When set to 'true' and no spec is provided, it will create a default KubernetesImagePuller object to be managed by the Operator. When set to 'false', the KubernetesImagePuller object will be deleted, and the Operator will be uninstalled, regardless of whether a spec is provided. If the 'spec.images' field is empty, a set of recommended workspace-related images will be automatically detected and pre-pulled after installation. Note that while this Operator and its behavior is community-supported, its payload may be commercially-supported for pulling commercially-supported images.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#enable DataK8SOrgEclipseCheCheClusterV1Manifest#enable}
  */
  readonly enable: boolean | cdktf.IResolvable;
  /**
  * A KubernetesImagePullerSpec to configure the image puller in the CheCluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#spec DataK8SOrgEclipseCheCheClusterV1Manifest#spec}
  */
  readonly spec?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
    spec: dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpecToTerraform(struct!.spec),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    spec: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
      this._spec.internalValue = value.spec;
    }
  }

  // enable - computed: false, optional: false, required: true
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S {
  /**
  * Ingress class that will define the which controller will manage ingresses. Defaults to 'nginx'. NB: This drives the 'kubernetes.io/ingress.class' annotation on Che-related ingresses.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#ingress_class DataK8SOrgEclipseCheCheClusterV1Manifest#ingress_class}
  */
  readonly ingressClass?: string;
  /**
  * Global ingress domain for a Kubernetes cluster. This MUST be explicitly specified: there are no defaults.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#ingress_domain DataK8SOrgEclipseCheCheClusterV1Manifest#ingress_domain}
  */
  readonly ingressDomain?: string;
  /**
  * Deprecated. The value of this flag is ignored. Strategy for ingress creation. Options are: 'multi-host' (host is explicitly provided in ingress), 'single-host' (host is provided, path-based rules) and 'default-host' (no host is provided, path-based rules). Defaults to 'multi-host' Deprecated in favor of 'serverExposureStrategy' in the 'server' section, which defines this regardless of the cluster type. When both are defined, the 'serverExposureStrategy' option takes precedence.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#ingress_strategy DataK8SOrgEclipseCheCheClusterV1Manifest#ingress_strategy}
  */
  readonly ingressStrategy?: string;
  /**
  * The FSGroup in which the Che Pod and workspace Pods containers runs in. Default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#security_context_fs_group DataK8SOrgEclipseCheCheClusterV1Manifest#security_context_fs_group}
  */
  readonly securityContextFsGroup?: string;
  /**
  * ID of the user the Che Pod and workspace Pods containers run as. Default value is '1724'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#security_context_run_as_user DataK8SOrgEclipseCheCheClusterV1Manifest#security_context_run_as_user}
  */
  readonly securityContextRunAsUser?: string;
  /**
  * Deprecated. The value of this flag is ignored. When the serverExposureStrategy is set to 'single-host', the way the server, registries and workspaces are exposed is further configured by this property. The possible values are 'native', which means that the server and workspaces are exposed using ingresses on K8s or 'gateway' where the server and workspaces are exposed using a custom gateway based on link:https://doc.traefik.io/traefik/[Traefik]. All the endpoints whether backed by the ingress or gateway 'route' always point to the subpaths on the same domain. Defaults to 'native'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#single_host_exposure_type DataK8SOrgEclipseCheCheClusterV1Manifest#single_host_exposure_type}
  */
  readonly singleHostExposureType?: string;
  /**
  * Name of a secret that will be used to setup ingress TLS termination when TLS is enabled. When the field is empty string, the default cluster certificate will be used. See also the 'tlsSupport' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#tls_secret_name DataK8SOrgEclipseCheCheClusterV1Manifest#tls_secret_name}
  */
  readonly tlsSecretName?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecK8SToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ingress_class: cdktf.stringToTerraform(struct!.ingressClass),
    ingress_domain: cdktf.stringToTerraform(struct!.ingressDomain),
    ingress_strategy: cdktf.stringToTerraform(struct!.ingressStrategy),
    security_context_fs_group: cdktf.stringToTerraform(struct!.securityContextFsGroup),
    security_context_run_as_user: cdktf.stringToTerraform(struct!.securityContextRunAsUser),
    single_host_exposure_type: cdktf.stringToTerraform(struct!.singleHostExposureType),
    tls_secret_name: cdktf.stringToTerraform(struct!.tlsSecretName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecK8SToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ingress_class: {
      value: cdktf.stringToHclTerraform(struct!.ingressClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_domain: {
      value: cdktf.stringToHclTerraform(struct!.ingressDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingress_strategy: {
      value: cdktf.stringToHclTerraform(struct!.ingressStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    security_context_fs_group: {
      value: cdktf.stringToHclTerraform(struct!.securityContextFsGroup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    security_context_run_as_user: {
      value: cdktf.stringToHclTerraform(struct!.securityContextRunAsUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    single_host_exposure_type: {
      value: cdktf.stringToHclTerraform(struct!.singleHostExposureType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_secret_name: {
      value: cdktf.stringToHclTerraform(struct!.tlsSecretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8SOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ingressClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressClass = this._ingressClass;
    }
    if (this._ingressDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressDomain = this._ingressDomain;
    }
    if (this._ingressStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingressStrategy = this._ingressStrategy;
    }
    if (this._securityContextFsGroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityContextFsGroup = this._securityContextFsGroup;
    }
    if (this._securityContextRunAsUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.securityContextRunAsUser = this._securityContextRunAsUser;
    }
    if (this._singleHostExposureType !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleHostExposureType = this._singleHostExposureType;
    }
    if (this._tlsSecretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSecretName = this._tlsSecretName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ingressClass = undefined;
      this._ingressDomain = undefined;
      this._ingressStrategy = undefined;
      this._securityContextFsGroup = undefined;
      this._securityContextRunAsUser = undefined;
      this._singleHostExposureType = undefined;
      this._tlsSecretName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ingressClass = value.ingressClass;
      this._ingressDomain = value.ingressDomain;
      this._ingressStrategy = value.ingressStrategy;
      this._securityContextFsGroup = value.securityContextFsGroup;
      this._securityContextRunAsUser = value.securityContextRunAsUser;
      this._singleHostExposureType = value.singleHostExposureType;
      this._tlsSecretName = value.tlsSecretName;
    }
  }

  // ingress_class - computed: false, optional: true, required: false
  private _ingressClass?: string; 
  public get ingressClass() {
    return this.getStringAttribute('ingress_class');
  }
  public set ingressClass(value: string) {
    this._ingressClass = value;
  }
  public resetIngressClass() {
    this._ingressClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressClassInput() {
    return this._ingressClass;
  }

  // ingress_domain - computed: false, optional: true, required: false
  private _ingressDomain?: string; 
  public get ingressDomain() {
    return this.getStringAttribute('ingress_domain');
  }
  public set ingressDomain(value: string) {
    this._ingressDomain = value;
  }
  public resetIngressDomain() {
    this._ingressDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressDomainInput() {
    return this._ingressDomain;
  }

  // ingress_strategy - computed: false, optional: true, required: false
  private _ingressStrategy?: string; 
  public get ingressStrategy() {
    return this.getStringAttribute('ingress_strategy');
  }
  public set ingressStrategy(value: string) {
    this._ingressStrategy = value;
  }
  public resetIngressStrategy() {
    this._ingressStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingressStrategyInput() {
    return this._ingressStrategy;
  }

  // security_context_fs_group - computed: false, optional: true, required: false
  private _securityContextFsGroup?: string; 
  public get securityContextFsGroup() {
    return this.getStringAttribute('security_context_fs_group');
  }
  public set securityContextFsGroup(value: string) {
    this._securityContextFsGroup = value;
  }
  public resetSecurityContextFsGroup() {
    this._securityContextFsGroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityContextFsGroupInput() {
    return this._securityContextFsGroup;
  }

  // security_context_run_as_user - computed: false, optional: true, required: false
  private _securityContextRunAsUser?: string; 
  public get securityContextRunAsUser() {
    return this.getStringAttribute('security_context_run_as_user');
  }
  public set securityContextRunAsUser(value: string) {
    this._securityContextRunAsUser = value;
  }
  public resetSecurityContextRunAsUser() {
    this._securityContextRunAsUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get securityContextRunAsUserInput() {
    return this._securityContextRunAsUser;
  }

  // single_host_exposure_type - computed: false, optional: true, required: false
  private _singleHostExposureType?: string; 
  public get singleHostExposureType() {
    return this.getStringAttribute('single_host_exposure_type');
  }
  public set singleHostExposureType(value: string) {
    this._singleHostExposureType = value;
  }
  public resetSingleHostExposureType() {
    this._singleHostExposureType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleHostExposureTypeInput() {
    return this._singleHostExposureType;
  }

  // tls_secret_name - computed: false, optional: true, required: false
  private _tlsSecretName?: string; 
  public get tlsSecretName() {
    return this.getStringAttribute('tls_secret_name');
  }
  public set tlsSecretName(value: string) {
    this._tlsSecretName = value;
  }
  public resetTlsSecretName() {
    this._tlsSecretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSecretNameInput() {
    return this._tlsSecretName;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics {
  /**
  * Enables 'metrics' the Che server endpoint. Default to 'true'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#enable DataK8SOrgEclipseCheCheClusterV1Manifest#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecMetricsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecMetricsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: false, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngressToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngressToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Operator uses the domain to generate a hostname for a route. In a conjunction with labels it creates a route, which is served by a non-default Ingress controller. The generated host name will follow this pattern: '<route-name>-<route-namespace>.<domain>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#domain DataK8SOrgEclipseCheCheClusterV1Manifest#domain}
  */
  readonly domain?: string;
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRouteToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    domain: cdktf.stringToTerraform(struct!.domain),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRouteToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._domain = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._domain = value.domain;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngressToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngressToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Operator uses the domain to generate a hostname for a route. In a conjunction with labels it creates a route, which is served by a non-default Ingress controller. The generated host name will follow this pattern: '<route-name>-<route-namespace>.<domain>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#domain DataK8SOrgEclipseCheCheClusterV1Manifest#domain}
  */
  readonly domain?: string;
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRouteToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    domain: cdktf.stringToTerraform(struct!.domain),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRouteToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._domain = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._domain = value.domain;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngressToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngressToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Operator uses the domain to generate a hostname for a route. In a conjunction with labels it creates a route, which is served by a non-default Ingress controller. The generated host name will follow this pattern: '<route-name>-<route-namespace>.<domain>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#domain DataK8SOrgEclipseCheCheClusterV1Manifest#domain}
  */
  readonly domain?: string;
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRouteToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    domain: cdktf.stringToTerraform(struct!.domain),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRouteToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._domain = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._domain = value.domain;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries {
  /**
  * Public URL of the devfile registry.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#url DataK8SOrgEclipseCheCheClusterV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
    }
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef {
  /**
  * The key to select.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#api_version DataK8SOrgEclipseCheCheClusterV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_path DataK8SOrgEclipseCheCheClusterV1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container_name DataK8SOrgEclipseCheCheClusterV1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#divisor DataK8SOrgEclipseCheCheClusterV1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource DataK8SOrgEclipseCheCheClusterV1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef {
  /**
  * The key of the secret to select from. Must be a valid secret key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the Secret or its key must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#optional DataK8SOrgEclipseCheCheClusterV1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRefToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRefToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._optional = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._optional = value.optional;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom {
  /**
  * Selects a key of a ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#config_map_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#config_map_key_ref}
  */
  readonly configMapKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef;
  /**
  * Selects a field of the pod: supports metadata.name, metadata.namespace, 'metadata.labels['<KEY>']', 'metadata.annotations['<KEY>']', spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#resource_field_ref DataK8SOrgEclipseCheCheClusterV1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef;
  /**
  * Selects a key of a secret in the pod's namespace
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secret_key_ref DataK8SOrgEclipseCheCheClusterV1Manifest#secret_key_ref}
  */
  readonly secretKeyRef?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRefToTerraform(struct!.configMapKeyRef),
    field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRefToTerraform(struct!.fieldRef),
    resource_field_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRefToTerraform(struct!.resourceFieldRef),
    secret_key_ref: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRefToTerraform(struct!.secretKeyRef),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRefToHclTerraform(struct!.configMapKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef",
    },
    field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef",
    },
    resource_field_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef",
    },
    secret_key_ref: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRefToHclTerraform(struct!.secretKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMapKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMapKeyRef = this._configMapKeyRef?.internalValue;
    }
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    if (this._secretKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKeyRef = this._secretKeyRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._resourceFieldRef.internalValue = undefined;
      this._secretKeyRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMapKeyRef.internalValue = value.configMapKeyRef;
      this._fieldRef.internalValue = value.fieldRef;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
      this._secretKeyRef.internalValue = value.secretKeyRef;
    }
  }

  // config_map_key_ref - computed: false, optional: true, required: false
  private _configMapKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRefOutputReference(this, "config_map_key_ref");
  public get configMapKeyRef() {
    return this._configMapKeyRef;
  }
  public putConfigMapKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromConfigMapKeyRef) {
    this._configMapKeyRef.internalValue = value;
  }
  public resetConfigMapKeyRef() {
    this._configMapKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapKeyRefInput() {
    return this._configMapKeyRef.internalValue;
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }

  // secret_key_ref - computed: false, optional: true, required: false
  private _secretKeyRef = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRefOutputReference(this, "secret_key_ref");
  public get secretKeyRef() {
    return this._secretKeyRef;
  }
  public putSecretKeyRef(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromSecretKeyRef) {
    this._secretKeyRef.internalValue = value;
  }
  public resetSecretKeyRef() {
    this._secretKeyRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyRefInput() {
    return this._secretKeyRef.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv {
  /**
  * Name of the environment variable. Must be a C_IDENTIFIER.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Variable references $(VAR_NAME) are expanded using the previously defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. '$$(VAR_NAME)' will produce the string literal '$(VAR_NAME)'. Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to ''.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
  /**
  * Source for the environment variable's value. Cannot be used if value is not empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value_from DataK8SOrgEclipseCheCheClusterV1Manifest#value_from}
  */
  readonly valueFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
    value_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromToTerraform(struct!.valueFrom),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromToHclTerraform(struct!.valueFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFrom = this._valueFrom?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
      this._valueFrom.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
      this._valueFrom.internalValue = value.valueFrom;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_from - computed: false, optional: true, required: false
  private _valueFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFromOutputReference(this, "value_from");
  public get valueFrom() {
    return this._valueFrom;
  }
  public putValueFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvValueFrom) {
    this._valueFrom.internalValue = value;
  }
  public resetValueFrom() {
    this._valueFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFromInput() {
    return this._valueFrom.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngressToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngressToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngressOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute {
  /**
  * Unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotations DataK8SOrgEclipseCheCheClusterV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Operator uses the domain to generate a hostname for a route. In a conjunction with labels it creates a route, which is served by a non-default Ingress controller. The generated host name will follow this pattern: '<route-name>-<route-namespace>.<domain>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#domain DataK8SOrgEclipseCheCheClusterV1Manifest#domain}
  */
  readonly domain?: string;
  /**
  * Comma separated list of labels that can be used to organize and categorize objects by scoping and selecting.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#labels DataK8SOrgEclipseCheCheClusterV1Manifest#labels}
  */
  readonly labels?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRouteToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    domain: cdktf.stringToTerraform(struct!.domain),
    labels: cdktf.stringToTerraform(struct!.labels),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRouteToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.stringToHclTerraform(struct!.labels),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._domain = undefined;
      this._labels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._domain = value.domain;
      this._labels = value.labels;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // domain - computed: false, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: string; 
  public get labels() {
    return this.getStringAttribute('labels');
  }
  public set labels(value: string) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation {
  /**
  * Annotations to be added to deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#deployment DataK8SOrgEclipseCheCheClusterV1Manifest#deployment}
  */
  readonly deployment?: { [key: string]: string };
  /**
  * Annotations to be added to service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#service DataK8SOrgEclipseCheCheClusterV1Manifest#service}
  */
  readonly service?: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotationToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deployment),
    service: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.service),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotationToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deployment),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.service),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment = value.deployment;
      this._service = value.service;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment?: { [key: string]: string }; 
  public get deployment() {
    return this.getStringMapAttribute('deployment');
  }
  public set deployment(value: { [key: string]: string }) {
    this._deployment = value;
  }
  public resetDeployment() {
    this._deployment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment;
  }

  // service - computed: false, optional: true, required: false
  private _service?: { [key: string]: string }; 
  public get service() {
    return this.getStringMapAttribute('service');
  }
  public set service(value: { [key: string]: string }) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#exposure DataK8SOrgEclipseCheCheClusterV1Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#protocol DataK8SOrgEclipseCheCheClusterV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secure DataK8SOrgEclipseCheCheClusterV1Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#target_port DataK8SOrgEclipseCheCheClusterV1Manifest#target_port}
  */
  readonly targetPort: number;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: false, required: true
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts {
  /**
  * The volume mount name is the name of an existing 'Volume' component. If several containers mount the same volume name then they will reuse the same volume and will be able to access to the same files.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * The path in the component container where the volume should be mounted. If not path is mentioned, default path is the is '/<name>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer {
  /**
  * Annotations that should be added to specific resources for this container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation;
  /**
  * The arguments to supply to the command running the dockerimage component. The arguments are supplied either to the default command provided in the image or to the overridden command. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#args DataK8SOrgEclipseCheCheClusterV1Manifest#args}
  */
  readonly args?: string[];
  /**
  * The command to run in the dockerimage component instead of the default one provided in the image. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#command DataK8SOrgEclipseCheCheClusterV1Manifest#command}
  */
  readonly command?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu_limit DataK8SOrgEclipseCheCheClusterV1Manifest#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu_request DataK8SOrgEclipseCheCheClusterV1Manifest#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Specify if a container should run in its own separated pod, instead of running as part of the main development environment pod. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dedicated_pod DataK8SOrgEclipseCheCheClusterV1Manifest#dedicated_pod}
  */
  readonly dedicatedPod?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoints DataK8SOrgEclipseCheCheClusterV1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints[] | cdktf.IResolvable;
  /**
  * Environment variables used in this container. The following variables are reserved and cannot be overridden via env: - '$PROJECTS_ROOT' - '$PROJECT_SOURCE'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#env DataK8SOrgEclipseCheCheClusterV1Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image DataK8SOrgEclipseCheCheClusterV1Manifest#image}
  */
  readonly image: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory_limit DataK8SOrgEclipseCheCheClusterV1Manifest#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory_request DataK8SOrgEclipseCheCheClusterV1Manifest#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Toggles whether or not the project source code should be mounted in the component. Defaults to true for all component types except plugins and components that set 'dedicatedPod' to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#mount_sources DataK8SOrgEclipseCheCheClusterV1Manifest#mount_sources}
  */
  readonly mountSources?: boolean | cdktf.IResolvable;
  /**
  * Optional specification of the path in the container where project sources should be transferred/mounted when 'mountSources' is 'true'. When omitted, the default value of /projects is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#source_mapping DataK8SOrgEclipseCheCheClusterV1Manifest#source_mapping}
  */
  readonly sourceMapping?: string;
  /**
  * List of volumes mounts that should be mounted is this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#volume_mounts DataK8SOrgEclipseCheCheClusterV1Manifest#volume_mounts}
  */
  readonly volumeMounts?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotationToTerraform(struct!.annotation),
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    dedicated_pod: cdktf.booleanToTerraform(struct!.dedicatedPod),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsToTerraform, false)(struct!.endpoints),
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    mount_sources: cdktf.booleanToTerraform(struct!.mountSources),
    source_mapping: cdktf.stringToTerraform(struct!.sourceMapping),
    volume_mounts: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsToTerraform, false)(struct!.volumeMounts),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotationToHclTerraform(struct!.annotation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation",
    },
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dedicated_pod: {
      value: cdktf.booleanToHclTerraform(struct!.dedicatedPod),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsList",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mount_sources: {
      value: cdktf.booleanToHclTerraform(struct!.mountSources),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source_mapping: {
      value: cdktf.stringToHclTerraform(struct!.sourceMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_mounts: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsToHclTerraform, false)(struct!.volumeMounts),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation?.internalValue;
    }
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._dedicatedPod !== undefined) {
      hasAnyValues = true;
      internalValueResult.dedicatedPod = this._dedicatedPod;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._mountSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountSources = this._mountSources;
    }
    if (this._sourceMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceMapping = this._sourceMapping;
    }
    if (this._volumeMounts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeMounts = this._volumeMounts?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation.internalValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._dedicatedPod = undefined;
      this._endpoints.internalValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._mountSources = undefined;
      this._sourceMapping = undefined;
      this._volumeMounts.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation.internalValue = value.annotation;
      this._args = value.args;
      this._command = value.command;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._dedicatedPod = value.dedicatedPod;
      this._endpoints.internalValue = value.endpoints;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._mountSources = value.mountSources;
      this._sourceMapping = value.sourceMapping;
      this._volumeMounts.internalValue = value.volumeMounts;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotationOutputReference(this, "annotation");
  public get annotation() {
    return this._annotation;
  }
  public putAnnotation(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerAnnotation) {
    this._annotation.internalValue = value;
  }
  public resetAnnotation() {
    this._annotation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation.internalValue;
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // dedicated_pod - computed: false, optional: true, required: false
  private _dedicatedPod?: boolean | cdktf.IResolvable; 
  public get dedicatedPod() {
    return this.getBooleanAttribute('dedicated_pod');
  }
  public set dedicatedPod(value: boolean | cdktf.IResolvable) {
    this._dedicatedPod = value;
  }
  public resetDedicatedPod() {
    this._dedicatedPod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dedicatedPodInput() {
    return this._dedicatedPod;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: false, required: true
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // mount_sources - computed: false, optional: true, required: false
  private _mountSources?: boolean | cdktf.IResolvable; 
  public get mountSources() {
    return this.getBooleanAttribute('mount_sources');
  }
  public set mountSources(value: boolean | cdktf.IResolvable) {
    this._mountSources = value;
  }
  public resetMountSources() {
    this._mountSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountSourcesInput() {
    return this._mountSources;
  }

  // source_mapping - computed: false, optional: true, required: false
  private _sourceMapping?: string; 
  public get sourceMapping() {
    return this.getStringAttribute('source_mapping');
  }
  public set sourceMapping(value: string) {
    this._sourceMapping = value;
  }
  public resetSourceMapping() {
    this._sourceMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceMappingInput() {
    return this._sourceMapping;
  }

  // volume_mounts - computed: false, optional: true, required: false
  private _volumeMounts = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMountsList(this, "volume_mounts", false);
  public get volumeMounts() {
    return this._volumeMounts;
  }
  public putVolumeMounts(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerVolumeMounts[] | cdktf.IResolvable) {
    this._volumeMounts.internalValue = value;
  }
  public resetVolumeMounts() {
    this._volumeMounts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeMountsInput() {
    return this._volumeMounts.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom {
  /**
  * Class of component that the associated implementation controller should use to process this command with the appropriate logic
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#component_class DataK8SOrgEclipseCheCheClusterV1Manifest#component_class}
  */
  readonly componentClass: string;
  /**
  * Additional free-form configuration for this custom component that the implementation controller will know how to use
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#embedded_resource DataK8SOrgEclipseCheCheClusterV1Manifest#embedded_resource}
  */
  readonly embeddedResource: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustomToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    component_class: cdktf.stringToTerraform(struct!.componentClass),
    embedded_resource: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.embeddedResource),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustomToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    component_class: {
      value: cdktf.stringToHclTerraform(struct!.componentClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    embedded_resource: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.embeddedResource),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._componentClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.componentClass = this._componentClass;
    }
    if (this._embeddedResource !== undefined) {
      hasAnyValues = true;
      internalValueResult.embeddedResource = this._embeddedResource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._componentClass = undefined;
      this._embeddedResource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._componentClass = value.componentClass;
      this._embeddedResource = value.embeddedResource;
    }
  }

  // component_class - computed: false, optional: false, required: true
  private _componentClass?: string; 
  public get componentClass() {
    return this.getStringAttribute('component_class');
  }
  public set componentClass(value: string) {
    this._componentClass = value;
  }
  // Temporarily expose input value. Use with caution.
  public get componentClassInput() {
    return this._componentClass;
  }

  // embedded_resource - computed: false, optional: false, required: true
  private _embeddedResource?: { [key: string]: string }; 
  public get embeddedResource() {
    return this.getStringMapAttribute('embedded_resource');
  }
  public set embeddedResource(value: { [key: string]: string }) {
    this._embeddedResource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get embeddedResourceInput() {
    return this._embeddedResource;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry {
  /**
  * Id in a devfile registry that contains a Dockerfile. The src in the OCI registry required for the Dockerfile build will be downloaded for building the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#id DataK8SOrgEclipseCheCheClusterV1Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Devfile Registry URL to pull the Dockerfile from when using the Devfile Registry as Dockerfile src. To ensure the Dockerfile gets resolved consistently in different environments, it is recommended to always specify the 'devfileRegistryUrl' when 'Id' is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#registry_url DataK8SOrgEclipseCheCheClusterV1Manifest#registry_url}
  */
  readonly registryUrl?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistryToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    registry_url: cdktf.stringToTerraform(struct!.registryUrl),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistryToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    registry_url: {
      value: cdktf.stringToHclTerraform(struct!.registryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._registryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryUrl = this._registryUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._registryUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._registryUrl = value.registryUrl;
    }
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // registry_url - computed: false, optional: true, required: false
  private _registryUrl?: string; 
  public get registryUrl() {
    return this.getStringAttribute('registry_url');
  }
  public set registryUrl(value: string) {
    this._registryUrl = value;
  }
  public resetRegistryUrl() {
    this._registryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryUrlInput() {
    return this._registryUrl;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom {
  /**
  * The remote name should be used as init. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#remote DataK8SOrgEclipseCheCheClusterV1Manifest#remote}
  */
  readonly remote?: string;
  /**
  * The revision to checkout from. Should be branch name, tag or commit id. Default branch is used if missing or specified revision is not found.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#revision DataK8SOrgEclipseCheCheClusterV1Manifest#revision}
  */
  readonly revision?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    remote: cdktf.stringToTerraform(struct!.remote),
    revision: cdktf.stringToTerraform(struct!.revision),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    remote: {
      value: cdktf.stringToHclTerraform(struct!.remote),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    revision: {
      value: cdktf.stringToHclTerraform(struct!.revision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._remote !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote;
    }
    if (this._revision !== undefined) {
      hasAnyValues = true;
      internalValueResult.revision = this._revision;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._remote = undefined;
      this._revision = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._remote = value.remote;
      this._revision = value.revision;
    }
  }

  // remote - computed: false, optional: true, required: false
  private _remote?: string; 
  public get remote() {
    return this.getStringAttribute('remote');
  }
  public set remote(value: string) {
    this._remote = value;
  }
  public resetRemote() {
    this._remote = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote;
  }

  // revision - computed: false, optional: true, required: false
  private _revision?: string; 
  public get revision() {
    return this.getStringAttribute('revision');
  }
  public set revision(value: string) {
    this._revision = value;
  }
  public resetRevision() {
    this._revision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get revisionInput() {
    return this._revision;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit {
  /**
  * Defines from what the project should be checked out. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#checkout_from DataK8SOrgEclipseCheCheClusterV1Manifest#checkout_from}
  */
  readonly checkoutFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom;
  /**
  * Location of the Dockerfile in the Git repository when using git as Dockerfile src. Defaults to Dockerfile.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#file_location DataK8SOrgEclipseCheCheClusterV1Manifest#file_location}
  */
  readonly fileLocation?: string;
  /**
  * The remotes map which should be initialized in the git project. Projects must have at least one remote configured while StarterProjects & Image Component's Git source can only have at most one remote configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#remotes DataK8SOrgEclipseCheCheClusterV1Manifest#remotes}
  */
  readonly remotes: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    checkout_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFromToTerraform(struct!.checkoutFrom),
    file_location: cdktf.stringToTerraform(struct!.fileLocation),
    remotes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remotes),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    checkout_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct!.checkoutFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom",
    },
    file_location: {
      value: cdktf.stringToHclTerraform(struct!.fileLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remotes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remotes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._checkoutFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkoutFrom = this._checkoutFrom?.internalValue;
    }
    if (this._fileLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileLocation = this._fileLocation;
    }
    if (this._remotes !== undefined) {
      hasAnyValues = true;
      internalValueResult.remotes = this._remotes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = undefined;
      this._fileLocation = undefined;
      this._remotes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = value.checkoutFrom;
      this._fileLocation = value.fileLocation;
      this._remotes = value.remotes;
    }
  }

  // checkout_from - computed: false, optional: true, required: false
  private _checkoutFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFromOutputReference(this, "checkout_from");
  public get checkoutFrom() {
    return this._checkoutFrom;
  }
  public putCheckoutFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitCheckoutFrom) {
    this._checkoutFrom.internalValue = value;
  }
  public resetCheckoutFrom() {
    this._checkoutFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkoutFromInput() {
    return this._checkoutFrom.internalValue;
  }

  // file_location - computed: false, optional: true, required: false
  private _fileLocation?: string; 
  public get fileLocation() {
    return this.getStringAttribute('file_location');
  }
  public set fileLocation(value: string) {
    this._fileLocation = value;
  }
  public resetFileLocation() {
    this._fileLocation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileLocationInput() {
    return this._fileLocation;
  }

  // remotes - computed: false, optional: false, required: true
  private _remotes?: { [key: string]: string }; 
  public get remotes() {
    return this.getStringMapAttribute('remotes');
  }
  public set remotes(value: { [key: string]: string }) {
    this._remotes = value;
  }
  // Temporarily expose input value. Use with caution.
  public get remotesInput() {
    return this._remotes;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile {
  /**
  * The arguments to supply to the dockerfile build.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#args DataK8SOrgEclipseCheCheClusterV1Manifest#args}
  */
  readonly args?: string[];
  /**
  * Path of source directory to establish build context. Defaults to ${PROJECT_SOURCE} in the container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#build_context DataK8SOrgEclipseCheCheClusterV1Manifest#build_context}
  */
  readonly buildContext?: string;
  /**
  * Dockerfile's Devfile Registry source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry}
  */
  readonly devfileRegistry?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry;
  /**
  * Dockerfile's Git source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#git DataK8SOrgEclipseCheCheClusterV1Manifest#git}
  */
  readonly git?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit;
  /**
  * Specify if a privileged builder pod is required. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#root_required DataK8SOrgEclipseCheCheClusterV1Manifest#root_required}
  */
  readonly rootRequired?: boolean | cdktf.IResolvable;
  /**
  * Type of Dockerfile src
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#src_type DataK8SOrgEclipseCheCheClusterV1Manifest#src_type}
  */
  readonly srcType?: string;
  /**
  * URI Reference of a Dockerfile. It can be a full URL or a relative URI from the current devfile as the base URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#uri DataK8SOrgEclipseCheCheClusterV1Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    build_context: cdktf.stringToTerraform(struct!.buildContext),
    devfile_registry: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistryToTerraform(struct!.devfileRegistry),
    git: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitToTerraform(struct!.git),
    root_required: cdktf.booleanToTerraform(struct!.rootRequired),
    src_type: cdktf.stringToTerraform(struct!.srcType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    build_context: {
      value: cdktf.stringToHclTerraform(struct!.buildContext),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistryToHclTerraform(struct!.devfileRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry",
    },
    git: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitToHclTerraform(struct!.git),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit",
    },
    root_required: {
      value: cdktf.booleanToHclTerraform(struct!.rootRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    src_type: {
      value: cdktf.stringToHclTerraform(struct!.srcType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._buildContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.buildContext = this._buildContext;
    }
    if (this._devfileRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistry = this._devfileRegistry?.internalValue;
    }
    if (this._git?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.git = this._git?.internalValue;
    }
    if (this._rootRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootRequired = this._rootRequired;
    }
    if (this._srcType !== undefined) {
      hasAnyValues = true;
      internalValueResult.srcType = this._srcType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._buildContext = undefined;
      this._devfileRegistry.internalValue = undefined;
      this._git.internalValue = undefined;
      this._rootRequired = undefined;
      this._srcType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._buildContext = value.buildContext;
      this._devfileRegistry.internalValue = value.devfileRegistry;
      this._git.internalValue = value.git;
      this._rootRequired = value.rootRequired;
      this._srcType = value.srcType;
      this._uri = value.uri;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // build_context - computed: false, optional: true, required: false
  private _buildContext?: string; 
  public get buildContext() {
    return this.getStringAttribute('build_context');
  }
  public set buildContext(value: string) {
    this._buildContext = value;
  }
  public resetBuildContext() {
    this._buildContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get buildContextInput() {
    return this._buildContext;
  }

  // devfile_registry - computed: false, optional: true, required: false
  private _devfileRegistry = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistryOutputReference(this, "devfile_registry");
  public get devfileRegistry() {
    return this._devfileRegistry;
  }
  public putDevfileRegistry(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileDevfileRegistry) {
    this._devfileRegistry.internalValue = value;
  }
  public resetDevfileRegistry() {
    this._devfileRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryInput() {
    return this._devfileRegistry.internalValue;
  }

  // git - computed: false, optional: true, required: false
  private _git = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGitOutputReference(this, "git");
  public get git() {
    return this._git;
  }
  public putGit(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileGit) {
    this._git.internalValue = value;
  }
  public resetGit() {
    this._git.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitInput() {
    return this._git.internalValue;
  }

  // root_required - computed: false, optional: true, required: false
  private _rootRequired?: boolean | cdktf.IResolvable; 
  public get rootRequired() {
    return this.getBooleanAttribute('root_required');
  }
  public set rootRequired(value: boolean | cdktf.IResolvable) {
    this._rootRequired = value;
  }
  public resetRootRequired() {
    this._rootRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootRequiredInput() {
    return this._rootRequired;
  }

  // src_type - computed: false, optional: true, required: false
  private _srcType?: string; 
  public get srcType() {
    return this.getStringAttribute('src_type');
  }
  public set srcType(value: string) {
    this._srcType = value;
  }
  public resetSrcType() {
    this._srcType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srcTypeInput() {
    return this._srcType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage {
  /**
  * Defines if the image should be built during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#auto_build DataK8SOrgEclipseCheCheClusterV1Manifest#auto_build}
  */
  readonly autoBuild?: boolean | cdktf.IResolvable;
  /**
  * Allows specifying dockerfile type build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dockerfile DataK8SOrgEclipseCheCheClusterV1Manifest#dockerfile}
  */
  readonly dockerfile?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile;
  /**
  * Name of the image for the resulting outerloop build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image_name DataK8SOrgEclipseCheCheClusterV1Manifest#image_name}
  */
  readonly imageName: string;
  /**
  * Type of image
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image_type DataK8SOrgEclipseCheCheClusterV1Manifest#image_type}
  */
  readonly imageType?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_build: cdktf.booleanToTerraform(struct!.autoBuild),
    dockerfile: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileToTerraform(struct!.dockerfile),
    image_name: cdktf.stringToTerraform(struct!.imageName),
    image_type: cdktf.stringToTerraform(struct!.imageType),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_build: {
      value: cdktf.booleanToHclTerraform(struct!.autoBuild),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dockerfile: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileToHclTerraform(struct!.dockerfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile",
    },
    image_name: {
      value: cdktf.stringToHclTerraform(struct!.imageName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_type: {
      value: cdktf.stringToHclTerraform(struct!.imageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoBuild !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBuild = this._autoBuild;
    }
    if (this._dockerfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerfile = this._dockerfile?.internalValue;
    }
    if (this._imageName !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageName = this._imageName;
    }
    if (this._imageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageType = this._imageType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoBuild = undefined;
      this._dockerfile.internalValue = undefined;
      this._imageName = undefined;
      this._imageType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoBuild = value.autoBuild;
      this._dockerfile.internalValue = value.dockerfile;
      this._imageName = value.imageName;
      this._imageType = value.imageType;
    }
  }

  // auto_build - computed: false, optional: true, required: false
  private _autoBuild?: boolean | cdktf.IResolvable; 
  public get autoBuild() {
    return this.getBooleanAttribute('auto_build');
  }
  public set autoBuild(value: boolean | cdktf.IResolvable) {
    this._autoBuild = value;
  }
  public resetAutoBuild() {
    this._autoBuild = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBuildInput() {
    return this._autoBuild;
  }

  // dockerfile - computed: false, optional: true, required: false
  private _dockerfile = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfileOutputReference(this, "dockerfile");
  public get dockerfile() {
    return this._dockerfile;
  }
  public putDockerfile(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageDockerfile) {
    this._dockerfile.internalValue = value;
  }
  public resetDockerfile() {
    this._dockerfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerfileInput() {
    return this._dockerfile.internalValue;
  }

  // image_name - computed: false, optional: false, required: true
  private _imageName?: string; 
  public get imageName() {
    return this.getStringAttribute('image_name');
  }
  public set imageName(value: string) {
    this._imageName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageNameInput() {
    return this._imageName;
  }

  // image_type - computed: false, optional: true, required: false
  private _imageType?: string; 
  public get imageType() {
    return this.getStringAttribute('image_type');
  }
  public set imageType(value: string) {
    this._imageType = value;
  }
  public resetImageType() {
    this._imageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageTypeInput() {
    return this._imageType;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#exposure DataK8SOrgEclipseCheCheClusterV1Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#protocol DataK8SOrgEclipseCheCheClusterV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secure DataK8SOrgEclipseCheCheClusterV1Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#target_port DataK8SOrgEclipseCheCheClusterV1Manifest#target_port}
  */
  readonly targetPort: number;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: false, required: true
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV1Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoints DataK8SOrgEclipseCheCheClusterV1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#inlined DataK8SOrgEclipseCheCheClusterV1Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#location_type DataK8SOrgEclipseCheCheClusterV1Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#uri DataK8SOrgEclipseCheCheClusterV1Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#exposure DataK8SOrgEclipseCheCheClusterV1Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#protocol DataK8SOrgEclipseCheCheClusterV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secure DataK8SOrgEclipseCheCheClusterV1Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#target_port DataK8SOrgEclipseCheCheClusterV1Manifest#target_port}
  */
  readonly targetPort: number;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: false, required: true
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV1Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoints DataK8SOrgEclipseCheCheClusterV1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#inlined DataK8SOrgEclipseCheCheClusterV1Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#location_type DataK8SOrgEclipseCheCheClusterV1Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#uri DataK8SOrgEclipseCheCheClusterV1Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup {
  /**
  * Identifies the default command for a given group kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#is_default DataK8SOrgEclipseCheCheClusterV1Manifest#is_default}
  */
  readonly isDefault?: boolean | cdktf.IResolvable;
  /**
  * Kind of group the command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#kind DataK8SOrgEclipseCheCheClusterV1Manifest#kind}
  */
  readonly kind?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroupToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    is_default: cdktf.booleanToTerraform(struct!.isDefault),
    kind: cdktf.stringToTerraform(struct!.kind),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroupToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    is_default: {
      value: cdktf.booleanToHclTerraform(struct!.isDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.isDefault = this._isDefault;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isDefault = undefined;
      this._kind = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isDefault = value.isDefault;
      this._kind = value.kind;
    }
  }

  // is_default - computed: false, optional: true, required: false
  private _isDefault?: boolean | cdktf.IResolvable; 
  public get isDefault() {
    return this.getBooleanAttribute('is_default');
  }
  public set isDefault(value: boolean | cdktf.IResolvable) {
    this._isDefault = value;
  }
  public resetIsDefault() {
    this._isDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isDefaultInput() {
    return this._isDefault;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply {
  /**
  * Describes component that will be applied
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#component DataK8SOrgEclipseCheCheClusterV1Manifest#component}
  */
  readonly component?: string;
  /**
  * Defines the group this command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#group DataK8SOrgEclipseCheCheClusterV1Manifest#group}
  */
  readonly group?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup;
  /**
  * Optional label that provides a label for this command to be used in Editor UI menus for example
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#label DataK8SOrgEclipseCheCheClusterV1Manifest#label}
  */
  readonly label?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    component: cdktf.stringToTerraform(struct!.component),
    group: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroupToTerraform(struct!.group),
    label: cdktf.stringToTerraform(struct!.label),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    component: {
      value: cdktf.stringToHclTerraform(struct!.component),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroupToHclTerraform(struct!.group),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._component !== undefined) {
      hasAnyValues = true;
      internalValueResult.component = this._component;
    }
    if (this._group?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group?.internalValue;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._component = undefined;
      this._group.internalValue = undefined;
      this._label = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._component = value.component;
      this._group.internalValue = value.group;
      this._label = value.label;
    }
  }

  // component - computed: false, optional: true, required: false
  private _component?: string; 
  public get component() {
    return this.getStringAttribute('component');
  }
  public set component(value: string) {
    this._component = value;
  }
  public resetComponent() {
    this._component = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentInput() {
    return this._component;
  }

  // group - computed: false, optional: true, required: false
  private _group = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroupOutputReference(this, "group");
  public get group() {
    return this._group;
  }
  public putGroup(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyGroup) {
    this._group.internalValue = value;
  }
  public resetGroup() {
    this._group.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group.internalValue;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup {
  /**
  * Identifies the default command for a given group kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#is_default DataK8SOrgEclipseCheCheClusterV1Manifest#is_default}
  */
  readonly isDefault?: boolean | cdktf.IResolvable;
  /**
  * Kind of group the command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#kind DataK8SOrgEclipseCheCheClusterV1Manifest#kind}
  */
  readonly kind?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroupToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    is_default: cdktf.booleanToTerraform(struct!.isDefault),
    kind: cdktf.stringToTerraform(struct!.kind),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroupToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    is_default: {
      value: cdktf.booleanToHclTerraform(struct!.isDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.isDefault = this._isDefault;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isDefault = undefined;
      this._kind = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isDefault = value.isDefault;
      this._kind = value.kind;
    }
  }

  // is_default - computed: false, optional: true, required: false
  private _isDefault?: boolean | cdktf.IResolvable; 
  public get isDefault() {
    return this.getBooleanAttribute('is_default');
  }
  public set isDefault(value: boolean | cdktf.IResolvable) {
    this._isDefault = value;
  }
  public resetIsDefault() {
    this._isDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isDefaultInput() {
    return this._isDefault;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite {
  /**
  * The commands that comprise this composite command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#commands DataK8SOrgEclipseCheCheClusterV1Manifest#commands}
  */
  readonly commands?: string[];
  /**
  * Defines the group this command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#group DataK8SOrgEclipseCheCheClusterV1Manifest#group}
  */
  readonly group?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup;
  /**
  * Optional label that provides a label for this command to be used in Editor UI menus for example
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#label DataK8SOrgEclipseCheCheClusterV1Manifest#label}
  */
  readonly label?: string;
  /**
  * Indicates if the sub-commands should be executed concurrently
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#parallel DataK8SOrgEclipseCheCheClusterV1Manifest#parallel}
  */
  readonly parallel?: boolean | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commands: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.commands),
    group: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroupToTerraform(struct!.group),
    label: cdktf.stringToTerraform(struct!.label),
    parallel: cdktf.booleanToTerraform(struct!.parallel),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commands: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.commands),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    group: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroupToHclTerraform(struct!.group),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parallel: {
      value: cdktf.booleanToHclTerraform(struct!.parallel),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commands !== undefined) {
      hasAnyValues = true;
      internalValueResult.commands = this._commands;
    }
    if (this._group?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group?.internalValue;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._parallel !== undefined) {
      hasAnyValues = true;
      internalValueResult.parallel = this._parallel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commands = undefined;
      this._group.internalValue = undefined;
      this._label = undefined;
      this._parallel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commands = value.commands;
      this._group.internalValue = value.group;
      this._label = value.label;
      this._parallel = value.parallel;
    }
  }

  // commands - computed: false, optional: true, required: false
  private _commands?: string[]; 
  public get commands() {
    return this.getListAttribute('commands');
  }
  public set commands(value: string[]) {
    this._commands = value;
  }
  public resetCommands() {
    this._commands = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandsInput() {
    return this._commands;
  }

  // group - computed: false, optional: true, required: false
  private _group = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroupOutputReference(this, "group");
  public get group() {
    return this._group;
  }
  public putGroup(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeGroup) {
    this._group.internalValue = value;
  }
  public resetGroup() {
    this._group.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group.internalValue;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // parallel - computed: false, optional: true, required: false
  private _parallel?: boolean | cdktf.IResolvable; 
  public get parallel() {
    return this.getBooleanAttribute('parallel');
  }
  public set parallel(value: boolean | cdktf.IResolvable) {
    this._parallel = value;
  }
  public resetParallel() {
    this._parallel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parallelInput() {
    return this._parallel;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup {
  /**
  * Identifies the default command for a given group kind
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#is_default DataK8SOrgEclipseCheCheClusterV1Manifest#is_default}
  */
  readonly isDefault?: boolean | cdktf.IResolvable;
  /**
  * Kind of group the command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#kind DataK8SOrgEclipseCheCheClusterV1Manifest#kind}
  */
  readonly kind?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroupToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    is_default: cdktf.booleanToTerraform(struct!.isDefault),
    kind: cdktf.stringToTerraform(struct!.kind),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroupToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    is_default: {
      value: cdktf.booleanToHclTerraform(struct!.isDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._isDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.isDefault = this._isDefault;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._isDefault = undefined;
      this._kind = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._isDefault = value.isDefault;
      this._kind = value.kind;
    }
  }

  // is_default - computed: false, optional: true, required: false
  private _isDefault?: boolean | cdktf.IResolvable; 
  public get isDefault() {
    return this.getBooleanAttribute('is_default');
  }
  public set isDefault(value: boolean | cdktf.IResolvable) {
    this._isDefault = value;
  }
  public resetIsDefault() {
    this._isDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isDefaultInput() {
    return this._isDefault;
  }

  // kind - computed: false, optional: true, required: false
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  public resetKind() {
    this._kind = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec {
  /**
  * The actual command-line string Special variables that can be used: - '$PROJECTS_ROOT': A path where projects sources are mounted as defined by container component's sourceMapping. - '$PROJECT_SOURCE': A path to a project source ($PROJECTS_ROOT/<project-name>). If there are multiple projects, this will point to the directory of the first one.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#command_line DataK8SOrgEclipseCheCheClusterV1Manifest#command_line}
  */
  readonly commandLine?: string;
  /**
  * Describes component to which given action relates
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#component DataK8SOrgEclipseCheCheClusterV1Manifest#component}
  */
  readonly component?: string;
  /**
  * Optional list of environment variables that have to be set before running the command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#env DataK8SOrgEclipseCheCheClusterV1Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv[] | cdktf.IResolvable;
  /**
  * Defines the group this command is part of
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#group DataK8SOrgEclipseCheCheClusterV1Manifest#group}
  */
  readonly group?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup;
  /**
  * Specify whether the command is restarted or not when the source code changes. If set to 'true' the command won't be restarted. A *hotReloadCapable* 'run' or 'debug' command is expected to handle file changes on its own and won't be restarted. A *hotReloadCapable* 'build' command is expected to be executed only once and won't be executed again. This field is taken into account only for commands 'build', 'run' and 'debug' with 'isDefault' set to 'true'. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#hot_reload_capable DataK8SOrgEclipseCheCheClusterV1Manifest#hot_reload_capable}
  */
  readonly hotReloadCapable?: boolean | cdktf.IResolvable;
  /**
  * Optional label that provides a label for this command to be used in Editor UI menus for example
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#label DataK8SOrgEclipseCheCheClusterV1Manifest#label}
  */
  readonly label?: string;
  /**
  * Working directory where the command should be executed Special variables that can be used: - '$PROJECTS_ROOT': A path where projects sources are mounted as defined by container component's sourceMapping. - '$PROJECT_SOURCE': A path to a project source ($PROJECTS_ROOT/<project-name>). If there are multiple projects, this will point to the directory of the first one.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#working_dir DataK8SOrgEclipseCheCheClusterV1Manifest#working_dir}
  */
  readonly workingDir?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command_line: cdktf.stringToTerraform(struct!.commandLine),
    component: cdktf.stringToTerraform(struct!.component),
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvToTerraform, false)(struct!.env),
    group: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroupToTerraform(struct!.group),
    hot_reload_capable: cdktf.booleanToTerraform(struct!.hotReloadCapable),
    label: cdktf.stringToTerraform(struct!.label),
    working_dir: cdktf.stringToTerraform(struct!.workingDir),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command_line: {
      value: cdktf.stringToHclTerraform(struct!.commandLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    component: {
      value: cdktf.stringToHclTerraform(struct!.component),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvList",
    },
    group: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroupToHclTerraform(struct!.group),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup",
    },
    hot_reload_capable: {
      value: cdktf.booleanToHclTerraform(struct!.hotReloadCapable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    working_dir: {
      value: cdktf.stringToHclTerraform(struct!.workingDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commandLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.commandLine = this._commandLine;
    }
    if (this._component !== undefined) {
      hasAnyValues = true;
      internalValueResult.component = this._component;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._group?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.group = this._group?.internalValue;
    }
    if (this._hotReloadCapable !== undefined) {
      hasAnyValues = true;
      internalValueResult.hotReloadCapable = this._hotReloadCapable;
    }
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._workingDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workingDir = this._workingDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commandLine = undefined;
      this._component = undefined;
      this._env.internalValue = undefined;
      this._group.internalValue = undefined;
      this._hotReloadCapable = undefined;
      this._label = undefined;
      this._workingDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commandLine = value.commandLine;
      this._component = value.component;
      this._env.internalValue = value.env;
      this._group.internalValue = value.group;
      this._hotReloadCapable = value.hotReloadCapable;
      this._label = value.label;
      this._workingDir = value.workingDir;
    }
  }

  // command_line - computed: false, optional: true, required: false
  private _commandLine?: string; 
  public get commandLine() {
    return this.getStringAttribute('command_line');
  }
  public set commandLine(value: string) {
    this._commandLine = value;
  }
  public resetCommandLine() {
    this._commandLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandLineInput() {
    return this._commandLine;
  }

  // component - computed: false, optional: true, required: false
  private _component?: string; 
  public get component() {
    return this.getStringAttribute('component');
  }
  public set component(value: string) {
    this._component = value;
  }
  public resetComponent() {
    this._component = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentInput() {
    return this._component;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // group - computed: false, optional: true, required: false
  private _group = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroupOutputReference(this, "group");
  public get group() {
    return this._group;
  }
  public putGroup(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecGroup) {
    this._group.internalValue = value;
  }
  public resetGroup() {
    this._group.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupInput() {
    return this._group.internalValue;
  }

  // hot_reload_capable - computed: false, optional: true, required: false
  private _hotReloadCapable?: boolean | cdktf.IResolvable; 
  public get hotReloadCapable() {
    return this.getBooleanAttribute('hot_reload_capable');
  }
  public set hotReloadCapable(value: boolean | cdktf.IResolvable) {
    this._hotReloadCapable = value;
  }
  public resetHotReloadCapable() {
    this._hotReloadCapable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hotReloadCapableInput() {
    return this._hotReloadCapable;
  }

  // label - computed: false, optional: true, required: false
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  public resetLabel() {
    this._label = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // working_dir - computed: false, optional: true, required: false
  private _workingDir?: string; 
  public get workingDir() {
    return this.getStringAttribute('working_dir');
  }
  public set workingDir(value: string) {
    this._workingDir = value;
  }
  public resetWorkingDir() {
    this._workingDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workingDirInput() {
    return this._workingDir;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands {
  /**
  * Command that consists in applying a given component definition, typically bound to a devworkspace event. For example, when an 'apply' command is bound to a 'preStart' event, and references a 'container' component, it will start the container as a K8S initContainer in the devworkspace POD, unless the component has its 'dedicatedPod' field set to 'true'. When no 'apply' command exist for a given component, it is assumed the component will be applied at devworkspace start by default, unless 'deployByDefault' for that component is set to false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#apply DataK8SOrgEclipseCheCheClusterV1Manifest#apply}
  */
  readonly apply?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply;
  /**
  * Map of implementation-dependant free-form YAML attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Type of devworkspace command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#command_type DataK8SOrgEclipseCheCheClusterV1Manifest#command_type}
  */
  readonly commandType?: string;
  /**
  * Composite command that allows executing several sub-commands either sequentially or concurrently
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#composite DataK8SOrgEclipseCheCheClusterV1Manifest#composite}
  */
  readonly composite?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite;
  /**
  * CLI Command executed in an existing component container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#exec DataK8SOrgEclipseCheCheClusterV1Manifest#exec}
  */
  readonly exec?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec;
  /**
  * Mandatory identifier that allows referencing this command in composite commands, from a parent, or in events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#id DataK8SOrgEclipseCheCheClusterV1Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apply: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyToTerraform(struct!.apply),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    command_type: cdktf.stringToTerraform(struct!.commandType),
    composite: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeToTerraform(struct!.composite),
    exec: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecToTerraform(struct!.exec),
    id: cdktf.stringToTerraform(struct!.id),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apply: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyToHclTerraform(struct!.apply),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    command_type: {
      value: cdktf.stringToHclTerraform(struct!.commandType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    composite: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeToHclTerraform(struct!.composite),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite",
    },
    exec: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecToHclTerraform(struct!.exec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apply?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apply = this._apply?.internalValue;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._commandType !== undefined) {
      hasAnyValues = true;
      internalValueResult.commandType = this._commandType;
    }
    if (this._composite?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.composite = this._composite?.internalValue;
    }
    if (this._exec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.exec = this._exec?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apply.internalValue = undefined;
      this._attributes = undefined;
      this._commandType = undefined;
      this._composite.internalValue = undefined;
      this._exec.internalValue = undefined;
      this._id = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apply.internalValue = value.apply;
      this._attributes = value.attributes;
      this._commandType = value.commandType;
      this._composite.internalValue = value.composite;
      this._exec.internalValue = value.exec;
      this._id = value.id;
    }
  }

  // apply - computed: false, optional: true, required: false
  private _apply = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApplyOutputReference(this, "apply");
  public get apply() {
    return this._apply;
  }
  public putApply(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsApply) {
    this._apply.internalValue = value;
  }
  public resetApply() {
    this._apply.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applyInput() {
    return this._apply.internalValue;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // command_type - computed: false, optional: true, required: false
  private _commandType?: string; 
  public get commandType() {
    return this.getStringAttribute('command_type');
  }
  public set commandType(value: string) {
    this._commandType = value;
  }
  public resetCommandType() {
    this._commandType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandTypeInput() {
    return this._commandType;
  }

  // composite - computed: false, optional: true, required: false
  private _composite = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsCompositeOutputReference(this, "composite");
  public get composite() {
    return this._composite;
  }
  public putComposite(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsComposite) {
    this._composite.internalValue = value;
  }
  public resetComposite() {
    this._composite.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compositeInput() {
    return this._composite.internalValue;
  }

  // exec - computed: false, optional: true, required: false
  private _exec = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExecOutputReference(this, "exec");
  public get exec() {
    return this._exec;
  }
  public putExec(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsExec) {
    this._exec.internalValue = value;
  }
  public resetExec() {
    this._exec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execInput() {
    return this._exec.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation {
  /**
  * Annotations to be added to deployment
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#deployment DataK8SOrgEclipseCheCheClusterV1Manifest#deployment}
  */
  readonly deployment?: { [key: string]: string };
  /**
  * Annotations to be added to service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#service DataK8SOrgEclipseCheCheClusterV1Manifest#service}
  */
  readonly service?: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotationToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deployment: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deployment),
    service: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.service),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotationToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deployment: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deployment),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    service: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.service),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployment !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployment = this._deployment;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployment = undefined;
      this._service = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployment = value.deployment;
      this._service = value.service;
    }
  }

  // deployment - computed: false, optional: true, required: false
  private _deployment?: { [key: string]: string }; 
  public get deployment() {
    return this.getStringMapAttribute('deployment');
  }
  public set deployment(value: { [key: string]: string }) {
    this._deployment = value;
  }
  public resetDeployment() {
    this._deployment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentInput() {
    return this._deployment;
  }

  // service - computed: false, optional: true, required: false
  private _service?: { [key: string]: string }; 
  public get service() {
    return this.getStringMapAttribute('service');
  }
  public set service(value: { [key: string]: string }) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#exposure DataK8SOrgEclipseCheCheClusterV1Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#protocol DataK8SOrgEclipseCheCheClusterV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secure DataK8SOrgEclipseCheCheClusterV1Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#target_port DataK8SOrgEclipseCheCheClusterV1Manifest#target_port}
  */
  readonly targetPort?: number;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts {
  /**
  * The volume mount name is the name of an existing 'Volume' component. If several containers mount the same volume name then they will reuse the same volume and will be able to access to the same files.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * The path in the component container where the volume should be mounted. If not path is mentioned, default path is the is '/<name>'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer {
  /**
  * Annotations that should be added to specific resources for this container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation;
  /**
  * The arguments to supply to the command running the dockerimage component. The arguments are supplied either to the default command provided in the image or to the overridden command. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#args DataK8SOrgEclipseCheCheClusterV1Manifest#args}
  */
  readonly args?: string[];
  /**
  * The command to run in the dockerimage component instead of the default one provided in the image. Defaults to an empty array, meaning use whatever is defined in the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#command DataK8SOrgEclipseCheCheClusterV1Manifest#command}
  */
  readonly command?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu_limit DataK8SOrgEclipseCheCheClusterV1Manifest#cpu_limit}
  */
  readonly cpuLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#cpu_request DataK8SOrgEclipseCheCheClusterV1Manifest#cpu_request}
  */
  readonly cpuRequest?: string;
  /**
  * Specify if a container should run in its own separated pod, instead of running as part of the main development environment pod. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dedicated_pod DataK8SOrgEclipseCheCheClusterV1Manifest#dedicated_pod}
  */
  readonly dedicatedPod?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoints DataK8SOrgEclipseCheCheClusterV1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints[] | cdktf.IResolvable;
  /**
  * Environment variables used in this container. The following variables are reserved and cannot be overridden via env: - '$PROJECTS_ROOT' - '$PROJECT_SOURCE'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#env DataK8SOrgEclipseCheCheClusterV1Manifest#env}
  */
  readonly env?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image DataK8SOrgEclipseCheCheClusterV1Manifest#image}
  */
  readonly image?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory_limit DataK8SOrgEclipseCheCheClusterV1Manifest#memory_limit}
  */
  readonly memoryLimit?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#memory_request DataK8SOrgEclipseCheCheClusterV1Manifest#memory_request}
  */
  readonly memoryRequest?: string;
  /**
  * Toggles whether or not the project source code should be mounted in the component. Defaults to true for all component types except plugins and components that set 'dedicatedPod' to true.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#mount_sources DataK8SOrgEclipseCheCheClusterV1Manifest#mount_sources}
  */
  readonly mountSources?: boolean | cdktf.IResolvable;
  /**
  * Optional specification of the path in the container where project sources should be transferred/mounted when 'mountSources' is 'true'. When omitted, the default value of /projects is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#source_mapping DataK8SOrgEclipseCheCheClusterV1Manifest#source_mapping}
  */
  readonly sourceMapping?: string;
  /**
  * List of volumes mounts that should be mounted is this container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#volume_mounts DataK8SOrgEclipseCheCheClusterV1Manifest#volume_mounts}
  */
  readonly volumeMounts?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotationToTerraform(struct!.annotation),
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.command),
    cpu_limit: cdktf.stringToTerraform(struct!.cpuLimit),
    cpu_request: cdktf.stringToTerraform(struct!.cpuRequest),
    dedicated_pod: cdktf.booleanToTerraform(struct!.dedicatedPod),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsToTerraform, false)(struct!.endpoints),
    env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvToTerraform, false)(struct!.env),
    image: cdktf.stringToTerraform(struct!.image),
    memory_limit: cdktf.stringToTerraform(struct!.memoryLimit),
    memory_request: cdktf.stringToTerraform(struct!.memoryRequest),
    mount_sources: cdktf.booleanToTerraform(struct!.mountSources),
    source_mapping: cdktf.stringToTerraform(struct!.sourceMapping),
    volume_mounts: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsToTerraform, false)(struct!.volumeMounts),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotationToHclTerraform(struct!.annotation),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation",
    },
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.command),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.cpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.cpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dedicated_pod: {
      value: cdktf.booleanToHclTerraform(struct!.dedicatedPod),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsList",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvList",
    },
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.memoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    memory_request: {
      value: cdktf.stringToHclTerraform(struct!.memoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mount_sources: {
      value: cdktf.booleanToHclTerraform(struct!.mountSources),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    source_mapping: {
      value: cdktf.stringToHclTerraform(struct!.sourceMapping),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_mounts: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsToHclTerraform, false)(struct!.volumeMounts),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation?.internalValue;
    }
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._cpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuLimit = this._cpuLimit;
    }
    if (this._cpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpuRequest = this._cpuRequest;
    }
    if (this._dedicatedPod !== undefined) {
      hasAnyValues = true;
      internalValueResult.dedicatedPod = this._dedicatedPod;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._memoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryLimit = this._memoryLimit;
    }
    if (this._memoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryRequest = this._memoryRequest;
    }
    if (this._mountSources !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountSources = this._mountSources;
    }
    if (this._sourceMapping !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceMapping = this._sourceMapping;
    }
    if (this._volumeMounts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeMounts = this._volumeMounts?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation.internalValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._cpuLimit = undefined;
      this._cpuRequest = undefined;
      this._dedicatedPod = undefined;
      this._endpoints.internalValue = undefined;
      this._env.internalValue = undefined;
      this._image = undefined;
      this._memoryLimit = undefined;
      this._memoryRequest = undefined;
      this._mountSources = undefined;
      this._sourceMapping = undefined;
      this._volumeMounts.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation.internalValue = value.annotation;
      this._args = value.args;
      this._command = value.command;
      this._cpuLimit = value.cpuLimit;
      this._cpuRequest = value.cpuRequest;
      this._dedicatedPod = value.dedicatedPod;
      this._endpoints.internalValue = value.endpoints;
      this._env.internalValue = value.env;
      this._image = value.image;
      this._memoryLimit = value.memoryLimit;
      this._memoryRequest = value.memoryRequest;
      this._mountSources = value.mountSources;
      this._sourceMapping = value.sourceMapping;
      this._volumeMounts.internalValue = value.volumeMounts;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotationOutputReference(this, "annotation");
  public get annotation() {
    return this._annotation;
  }
  public putAnnotation(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerAnnotation) {
    this._annotation.internalValue = value;
  }
  public resetAnnotation() {
    this._annotation.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation.internalValue;
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string[]; 
  public get command() {
    return this.getListAttribute('command');
  }
  public set command(value: string[]) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // cpu_limit - computed: false, optional: true, required: false
  private _cpuLimit?: string; 
  public get cpuLimit() {
    return this.getStringAttribute('cpu_limit');
  }
  public set cpuLimit(value: string) {
    this._cpuLimit = value;
  }
  public resetCpuLimit() {
    this._cpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuLimitInput() {
    return this._cpuLimit;
  }

  // cpu_request - computed: false, optional: true, required: false
  private _cpuRequest?: string; 
  public get cpuRequest() {
    return this.getStringAttribute('cpu_request');
  }
  public set cpuRequest(value: string) {
    this._cpuRequest = value;
  }
  public resetCpuRequest() {
    this._cpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuRequestInput() {
    return this._cpuRequest;
  }

  // dedicated_pod - computed: false, optional: true, required: false
  private _dedicatedPod?: boolean | cdktf.IResolvable; 
  public get dedicatedPod() {
    return this.getBooleanAttribute('dedicated_pod');
  }
  public set dedicatedPod(value: boolean | cdktf.IResolvable) {
    this._dedicatedPod = value;
  }
  public resetDedicatedPod() {
    this._dedicatedPod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dedicatedPodInput() {
    return this._dedicatedPod;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  public resetImage() {
    this._image = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // memory_limit - computed: false, optional: true, required: false
  private _memoryLimit?: string; 
  public get memoryLimit() {
    return this.getStringAttribute('memory_limit');
  }
  public set memoryLimit(value: string) {
    this._memoryLimit = value;
  }
  public resetMemoryLimit() {
    this._memoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryLimitInput() {
    return this._memoryLimit;
  }

  // memory_request - computed: false, optional: true, required: false
  private _memoryRequest?: string; 
  public get memoryRequest() {
    return this.getStringAttribute('memory_request');
  }
  public set memoryRequest(value: string) {
    this._memoryRequest = value;
  }
  public resetMemoryRequest() {
    this._memoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryRequestInput() {
    return this._memoryRequest;
  }

  // mount_sources - computed: false, optional: true, required: false
  private _mountSources?: boolean | cdktf.IResolvable; 
  public get mountSources() {
    return this.getBooleanAttribute('mount_sources');
  }
  public set mountSources(value: boolean | cdktf.IResolvable) {
    this._mountSources = value;
  }
  public resetMountSources() {
    this._mountSources = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountSourcesInput() {
    return this._mountSources;
  }

  // source_mapping - computed: false, optional: true, required: false
  private _sourceMapping?: string; 
  public get sourceMapping() {
    return this.getStringAttribute('source_mapping');
  }
  public set sourceMapping(value: string) {
    this._sourceMapping = value;
  }
  public resetSourceMapping() {
    this._sourceMapping = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceMappingInput() {
    return this._sourceMapping;
  }

  // volume_mounts - computed: false, optional: true, required: false
  private _volumeMounts = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMountsList(this, "volume_mounts", false);
  public get volumeMounts() {
    return this._volumeMounts;
  }
  public putVolumeMounts(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerVolumeMounts[] | cdktf.IResolvable) {
    this._volumeMounts.internalValue = value;
  }
  public resetVolumeMounts() {
    this._volumeMounts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeMountsInput() {
    return this._volumeMounts.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry {
  /**
  * Id in a devfile registry that contains a Dockerfile. The src in the OCI registry required for the Dockerfile build will be downloaded for building the image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#id DataK8SOrgEclipseCheCheClusterV1Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Devfile Registry URL to pull the Dockerfile from when using the Devfile Registry as Dockerfile src. To ensure the Dockerfile gets resolved consistently in different environments, it is recommended to always specify the 'devfileRegistryUrl' when 'Id' is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#registry_url DataK8SOrgEclipseCheCheClusterV1Manifest#registry_url}
  */
  readonly registryUrl?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    id: cdktf.stringToTerraform(struct!.id),
    registry_url: cdktf.stringToTerraform(struct!.registryUrl),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    registry_url: {
      value: cdktf.stringToHclTerraform(struct!.registryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._registryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryUrl = this._registryUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._id = undefined;
      this._registryUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._id = value.id;
      this._registryUrl = value.registryUrl;
    }
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // registry_url - computed: false, optional: true, required: false
  private _registryUrl?: string; 
  public get registryUrl() {
    return this.getStringAttribute('registry_url');
  }
  public set registryUrl(value: string) {
    this._registryUrl = value;
  }
  public resetRegistryUrl() {
    this._registryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryUrlInput() {
    return this._registryUrl;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom {
  /**
  * The remote name should be used as init. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#remote DataK8SOrgEclipseCheCheClusterV1Manifest#remote}
  */
  readonly remote?: string;
  /**
  * The revision to checkout from. Should be branch name, tag or commit id. Default branch is used if missing or specified revision is not found.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#revision DataK8SOrgEclipseCheCheClusterV1Manifest#revision}
  */
  readonly revision?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    remote: cdktf.stringToTerraform(struct!.remote),
    revision: cdktf.stringToTerraform(struct!.revision),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    remote: {
      value: cdktf.stringToHclTerraform(struct!.remote),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    revision: {
      value: cdktf.stringToHclTerraform(struct!.revision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._remote !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote;
    }
    if (this._revision !== undefined) {
      hasAnyValues = true;
      internalValueResult.revision = this._revision;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._remote = undefined;
      this._revision = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._remote = value.remote;
      this._revision = value.revision;
    }
  }

  // remote - computed: false, optional: true, required: false
  private _remote?: string; 
  public get remote() {
    return this.getStringAttribute('remote');
  }
  public set remote(value: string) {
    this._remote = value;
  }
  public resetRemote() {
    this._remote = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote;
  }

  // revision - computed: false, optional: true, required: false
  private _revision?: string; 
  public get revision() {
    return this.getStringAttribute('revision');
  }
  public set revision(value: string) {
    this._revision = value;
  }
  public resetRevision() {
    this._revision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get revisionInput() {
    return this._revision;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit {
  /**
  * Defines from what the project should be checked out. Required if there are more than one remote configured
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#checkout_from DataK8SOrgEclipseCheCheClusterV1Manifest#checkout_from}
  */
  readonly checkoutFrom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom;
  /**
  * Location of the Dockerfile in the Git repository when using git as Dockerfile src. Defaults to Dockerfile.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#file_location DataK8SOrgEclipseCheCheClusterV1Manifest#file_location}
  */
  readonly fileLocation?: string;
  /**
  * The remotes map which should be initialized in the git project. Projects must have at least one remote configured while StarterProjects & Image Component's Git source can only have at most one remote configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#remotes DataK8SOrgEclipseCheCheClusterV1Manifest#remotes}
  */
  readonly remotes?: { [key: string]: string };
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    checkout_from: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToTerraform(struct!.checkoutFrom),
    file_location: cdktf.stringToTerraform(struct!.fileLocation),
    remotes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remotes),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    checkout_from: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromToHclTerraform(struct!.checkoutFrom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom",
    },
    file_location: {
      value: cdktf.stringToHclTerraform(struct!.fileLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remotes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remotes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._checkoutFrom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.checkoutFrom = this._checkoutFrom?.internalValue;
    }
    if (this._fileLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileLocation = this._fileLocation;
    }
    if (this._remotes !== undefined) {
      hasAnyValues = true;
      internalValueResult.remotes = this._remotes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = undefined;
      this._fileLocation = undefined;
      this._remotes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._checkoutFrom.internalValue = value.checkoutFrom;
      this._fileLocation = value.fileLocation;
      this._remotes = value.remotes;
    }
  }

  // checkout_from - computed: false, optional: true, required: false
  private _checkoutFrom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFromOutputReference(this, "checkout_from");
  public get checkoutFrom() {
    return this._checkoutFrom;
  }
  public putCheckoutFrom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitCheckoutFrom) {
    this._checkoutFrom.internalValue = value;
  }
  public resetCheckoutFrom() {
    this._checkoutFrom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkoutFromInput() {
    return this._checkoutFrom.internalValue;
  }

  // file_location - computed: false, optional: true, required: false
  private _fileLocation?: string; 
  public get fileLocation() {
    return this.getStringAttribute('file_location');
  }
  public set fileLocation(value: string) {
    this._fileLocation = value;
  }
  public resetFileLocation() {
    this._fileLocation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileLocationInput() {
    return this._fileLocation;
  }

  // remotes - computed: false, optional: true, required: false
  private _remotes?: { [key: string]: string }; 
  public get remotes() {
    return this.getStringMapAttribute('remotes');
  }
  public set remotes(value: { [key: string]: string }) {
    this._remotes = value;
  }
  public resetRemotes() {
    this._remotes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remotesInput() {
    return this._remotes;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile {
  /**
  * The arguments to supply to the dockerfile build.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#args DataK8SOrgEclipseCheCheClusterV1Manifest#args}
  */
  readonly args?: string[];
  /**
  * Path of source directory to establish build context. Defaults to ${PROJECT_SOURCE} in the container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#build_context DataK8SOrgEclipseCheCheClusterV1Manifest#build_context}
  */
  readonly buildContext?: string;
  /**
  * Dockerfile's Devfile Registry source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry}
  */
  readonly devfileRegistry?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry;
  /**
  * Dockerfile's Git source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#git DataK8SOrgEclipseCheCheClusterV1Manifest#git}
  */
  readonly git?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit;
  /**
  * Specify if a privileged builder pod is required. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#root_required DataK8SOrgEclipseCheCheClusterV1Manifest#root_required}
  */
  readonly rootRequired?: boolean | cdktf.IResolvable;
  /**
  * Type of Dockerfile src
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#src_type DataK8SOrgEclipseCheCheClusterV1Manifest#src_type}
  */
  readonly srcType?: string;
  /**
  * URI Reference of a Dockerfile. It can be a full URL or a relative URI from the current devfile as the base URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#uri DataK8SOrgEclipseCheCheClusterV1Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    build_context: cdktf.stringToTerraform(struct!.buildContext),
    devfile_registry: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToTerraform(struct!.devfileRegistry),
    git: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitToTerraform(struct!.git),
    root_required: cdktf.booleanToTerraform(struct!.rootRequired),
    src_type: cdktf.stringToTerraform(struct!.srcType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    build_context: {
      value: cdktf.stringToHclTerraform(struct!.buildContext),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryToHclTerraform(struct!.devfileRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry",
    },
    git: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitToHclTerraform(struct!.git),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit",
    },
    root_required: {
      value: cdktf.booleanToHclTerraform(struct!.rootRequired),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    src_type: {
      value: cdktf.stringToHclTerraform(struct!.srcType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._buildContext !== undefined) {
      hasAnyValues = true;
      internalValueResult.buildContext = this._buildContext;
    }
    if (this._devfileRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistry = this._devfileRegistry?.internalValue;
    }
    if (this._git?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.git = this._git?.internalValue;
    }
    if (this._rootRequired !== undefined) {
      hasAnyValues = true;
      internalValueResult.rootRequired = this._rootRequired;
    }
    if (this._srcType !== undefined) {
      hasAnyValues = true;
      internalValueResult.srcType = this._srcType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._buildContext = undefined;
      this._devfileRegistry.internalValue = undefined;
      this._git.internalValue = undefined;
      this._rootRequired = undefined;
      this._srcType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._buildContext = value.buildContext;
      this._devfileRegistry.internalValue = value.devfileRegistry;
      this._git.internalValue = value.git;
      this._rootRequired = value.rootRequired;
      this._srcType = value.srcType;
      this._uri = value.uri;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // build_context - computed: false, optional: true, required: false
  private _buildContext?: string; 
  public get buildContext() {
    return this.getStringAttribute('build_context');
  }
  public set buildContext(value: string) {
    this._buildContext = value;
  }
  public resetBuildContext() {
    this._buildContext = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get buildContextInput() {
    return this._buildContext;
  }

  // devfile_registry - computed: false, optional: true, required: false
  private _devfileRegistry = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistryOutputReference(this, "devfile_registry");
  public get devfileRegistry() {
    return this._devfileRegistry;
  }
  public putDevfileRegistry(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileDevfileRegistry) {
    this._devfileRegistry.internalValue = value;
  }
  public resetDevfileRegistry() {
    this._devfileRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryInput() {
    return this._devfileRegistry.internalValue;
  }

  // git - computed: false, optional: true, required: false
  private _git = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGitOutputReference(this, "git");
  public get git() {
    return this._git;
  }
  public putGit(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileGit) {
    this._git.internalValue = value;
  }
  public resetGit() {
    this._git.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitInput() {
    return this._git.internalValue;
  }

  // root_required - computed: false, optional: true, required: false
  private _rootRequired?: boolean | cdktf.IResolvable; 
  public get rootRequired() {
    return this.getBooleanAttribute('root_required');
  }
  public set rootRequired(value: boolean | cdktf.IResolvable) {
    this._rootRequired = value;
  }
  public resetRootRequired() {
    this._rootRequired = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rootRequiredInput() {
    return this._rootRequired;
  }

  // src_type - computed: false, optional: true, required: false
  private _srcType?: string; 
  public get srcType() {
    return this.getStringAttribute('src_type');
  }
  public set srcType(value: string) {
    this._srcType = value;
  }
  public resetSrcType() {
    this._srcType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get srcTypeInput() {
    return this._srcType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage {
  /**
  * Defines if the image should be built during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#auto_build DataK8SOrgEclipseCheCheClusterV1Manifest#auto_build}
  */
  readonly autoBuild?: boolean | cdktf.IResolvable;
  /**
  * Allows specifying dockerfile type build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dockerfile DataK8SOrgEclipseCheCheClusterV1Manifest#dockerfile}
  */
  readonly dockerfile?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile;
  /**
  * Name of the image for the resulting outerloop build
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image_name DataK8SOrgEclipseCheCheClusterV1Manifest#image_name}
  */
  readonly imageName?: string;
  /**
  * Type of image
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image_type DataK8SOrgEclipseCheCheClusterV1Manifest#image_type}
  */
  readonly imageType?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auto_build: cdktf.booleanToTerraform(struct!.autoBuild),
    dockerfile: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileToTerraform(struct!.dockerfile),
    image_name: cdktf.stringToTerraform(struct!.imageName),
    image_type: cdktf.stringToTerraform(struct!.imageType),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auto_build: {
      value: cdktf.booleanToHclTerraform(struct!.autoBuild),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    dockerfile: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileToHclTerraform(struct!.dockerfile),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile",
    },
    image_name: {
      value: cdktf.stringToHclTerraform(struct!.imageName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_type: {
      value: cdktf.stringToHclTerraform(struct!.imageType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._autoBuild !== undefined) {
      hasAnyValues = true;
      internalValueResult.autoBuild = this._autoBuild;
    }
    if (this._dockerfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerfile = this._dockerfile?.internalValue;
    }
    if (this._imageName !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageName = this._imageName;
    }
    if (this._imageType !== undefined) {
      hasAnyValues = true;
      internalValueResult.imageType = this._imageType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._autoBuild = undefined;
      this._dockerfile.internalValue = undefined;
      this._imageName = undefined;
      this._imageType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._autoBuild = value.autoBuild;
      this._dockerfile.internalValue = value.dockerfile;
      this._imageName = value.imageName;
      this._imageType = value.imageType;
    }
  }

  // auto_build - computed: false, optional: true, required: false
  private _autoBuild?: boolean | cdktf.IResolvable; 
  public get autoBuild() {
    return this.getBooleanAttribute('auto_build');
  }
  public set autoBuild(value: boolean | cdktf.IResolvable) {
    this._autoBuild = value;
  }
  public resetAutoBuild() {
    this._autoBuild = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get autoBuildInput() {
    return this._autoBuild;
  }

  // dockerfile - computed: false, optional: true, required: false
  private _dockerfile = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfileOutputReference(this, "dockerfile");
  public get dockerfile() {
    return this._dockerfile;
  }
  public putDockerfile(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageDockerfile) {
    this._dockerfile.internalValue = value;
  }
  public resetDockerfile() {
    this._dockerfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerfileInput() {
    return this._dockerfile.internalValue;
  }

  // image_name - computed: false, optional: true, required: false
  private _imageName?: string; 
  public get imageName() {
    return this.getStringAttribute('image_name');
  }
  public set imageName(value: string) {
    this._imageName = value;
  }
  public resetImageName() {
    this._imageName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageNameInput() {
    return this._imageName;
  }

  // image_type - computed: false, optional: true, required: false
  private _imageType?: string; 
  public get imageType() {
    return this.getStringAttribute('image_type');
  }
  public set imageType(value: string) {
    this._imageType = value;
  }
  public resetImageType() {
    this._imageType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageTypeInput() {
    return this._imageType;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#exposure DataK8SOrgEclipseCheCheClusterV1Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#protocol DataK8SOrgEclipseCheCheClusterV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secure DataK8SOrgEclipseCheCheClusterV1Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#target_port DataK8SOrgEclipseCheCheClusterV1Manifest#target_port}
  */
  readonly targetPort?: number;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV1Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoints DataK8SOrgEclipseCheCheClusterV1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#inlined DataK8SOrgEclipseCheCheClusterV1Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#location_type DataK8SOrgEclipseCheCheClusterV1Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#uri DataK8SOrgEclipseCheCheClusterV1Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints {
  /**
  * Annotations to be added to Kubernetes Ingress or Openshift Route
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#annotation DataK8SOrgEclipseCheCheClusterV1Manifest#annotation}
  */
  readonly annotation?: { [key: string]: string };
  /**
  * Map of implementation-dependant string-based free-form attributes. Examples of Che-specific attributes: - cookiesAuthEnabled: 'true' / 'false', - type: 'terminal' / 'ide' / 'ide-dev',
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Describes how the endpoint should be exposed on the network. - 'public' means that the endpoint will be exposed on the public network, typically through a K8S ingress or an OpenShift route. - 'internal' means that the endpoint will be exposed internally outside of the main devworkspace POD, typically by K8S services, to be consumed by other elements running on the same cloud internal network. - 'none' means that the endpoint will not be exposed and will only be accessible inside the main devworkspace POD, on a local address. Default value is 'public'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#exposure DataK8SOrgEclipseCheCheClusterV1Manifest#exposure}
  */
  readonly exposure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Path of the endpoint URL
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#path DataK8SOrgEclipseCheCheClusterV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Describes the application and transport protocols of the traffic that will go through this endpoint. - 'http': Endpoint will have 'http' traffic, typically on a TCP connection. It will be automaticaly promoted to 'https' when the 'secure' field is set to 'true'. - 'https': Endpoint will have 'https' traffic, typically on a TCP connection. - 'ws': Endpoint will have 'ws' traffic, typically on a TCP connection. It will be automaticaly promoted to 'wss' when the 'secure' field is set to 'true'. - 'wss': Endpoint will have 'wss' traffic, typically on a TCP connection. - 'tcp': Endpoint will have traffic on a TCP connection, without specifying an application protocol. - 'udp': Endpoint will have traffic on an UDP connection, without specifying an application protocol. Default value is 'http'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#protocol DataK8SOrgEclipseCheCheClusterV1Manifest#protocol}
  */
  readonly protocol?: string;
  /**
  * Describes whether the endpoint should be secured and protected by some authentication process. This requires a protocol of 'https' or 'wss'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#secure DataK8SOrgEclipseCheCheClusterV1Manifest#secure}
  */
  readonly secure?: boolean | cdktf.IResolvable;
  /**
  * Port number to be used within the container component. The same port cannot be used by two different container components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#target_port DataK8SOrgEclipseCheCheClusterV1Manifest#target_port}
  */
  readonly targetPort?: number;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotation: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotation),
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    exposure: cdktf.stringToTerraform(struct!.exposure),
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    secure: cdktf.booleanToTerraform(struct!.secure),
    target_port: cdktf.numberToTerraform(struct!.targetPort),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotation: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotation),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exposure: {
      value: cdktf.stringToHclTerraform(struct!.exposure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secure: {
      value: cdktf.booleanToHclTerraform(struct!.secure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    target_port: {
      value: cdktf.numberToHclTerraform(struct!.targetPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotation !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotation = this._annotation;
    }
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._exposure !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposure = this._exposure;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._secure !== undefined) {
      hasAnyValues = true;
      internalValueResult.secure = this._secure;
    }
    if (this._targetPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.targetPort = this._targetPort;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotation = undefined;
      this._attributes = undefined;
      this._exposure = undefined;
      this._name = undefined;
      this._path = undefined;
      this._protocol = undefined;
      this._secure = undefined;
      this._targetPort = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotation = value.annotation;
      this._attributes = value.attributes;
      this._exposure = value.exposure;
      this._name = value.name;
      this._path = value.path;
      this._protocol = value.protocol;
      this._secure = value.secure;
      this._targetPort = value.targetPort;
    }
  }

  // annotation - computed: false, optional: true, required: false
  private _annotation?: { [key: string]: string }; 
  public get annotation() {
    return this.getStringMapAttribute('annotation');
  }
  public set annotation(value: { [key: string]: string }) {
    this._annotation = value;
  }
  public resetAnnotation() {
    this._annotation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationInput() {
    return this._annotation;
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // exposure - computed: false, optional: true, required: false
  private _exposure?: string; 
  public get exposure() {
    return this.getStringAttribute('exposure');
  }
  public set exposure(value: string) {
    this._exposure = value;
  }
  public resetExposure() {
    this._exposure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposureInput() {
    return this._exposure;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // protocol - computed: false, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // secure - computed: false, optional: true, required: false
  private _secure?: boolean | cdktf.IResolvable; 
  public get secure() {
    return this.getBooleanAttribute('secure');
  }
  public set secure(value: boolean | cdktf.IResolvable) {
    this._secure = value;
  }
  public resetSecure() {
    this._secure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secureInput() {
    return this._secure;
  }

  // target_port - computed: false, optional: true, required: false
  private _targetPort?: number; 
  public get targetPort() {
    return this.getNumberAttribute('target_port');
  }
  public set targetPort(value: number) {
    this._targetPort = value;
  }
  public resetTargetPort() {
    this._targetPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetPortInput() {
    return this._targetPort;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift {
  /**
  * Defines if the component should be deployed during startup. Default value is 'false'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#deploy_by_default DataK8SOrgEclipseCheCheClusterV1Manifest#deploy_by_default}
  */
  readonly deployByDefault?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#endpoints DataK8SOrgEclipseCheCheClusterV1Manifest#endpoints}
  */
  readonly endpoints?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints[] | cdktf.IResolvable;
  /**
  * Inlined manifest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#inlined DataK8SOrgEclipseCheCheClusterV1Manifest#inlined}
  */
  readonly inlined?: string;
  /**
  * Type of Kubernetes-like location
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#location_type DataK8SOrgEclipseCheCheClusterV1Manifest#location_type}
  */
  readonly locationType?: string;
  /**
  * Location in a file fetched from a uri.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#uri DataK8SOrgEclipseCheCheClusterV1Manifest#uri}
  */
  readonly uri?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    deploy_by_default: cdktf.booleanToTerraform(struct!.deployByDefault),
    endpoints: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsToTerraform, false)(struct!.endpoints),
    inlined: cdktf.stringToTerraform(struct!.inlined),
    location_type: cdktf.stringToTerraform(struct!.locationType),
    uri: cdktf.stringToTerraform(struct!.uri),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    deploy_by_default: {
      value: cdktf.booleanToHclTerraform(struct!.deployByDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoints: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsToHclTerraform, false)(struct!.endpoints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsList",
    },
    inlined: {
      value: cdktf.stringToHclTerraform(struct!.inlined),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    location_type: {
      value: cdktf.stringToHclTerraform(struct!.locationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._deployByDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.deployByDefault = this._deployByDefault;
    }
    if (this._endpoints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoints = this._endpoints?.internalValue;
    }
    if (this._inlined !== undefined) {
      hasAnyValues = true;
      internalValueResult.inlined = this._inlined;
    }
    if (this._locationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.locationType = this._locationType;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._deployByDefault = undefined;
      this._endpoints.internalValue = undefined;
      this._inlined = undefined;
      this._locationType = undefined;
      this._uri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._deployByDefault = value.deployByDefault;
      this._endpoints.internalValue = value.endpoints;
      this._inlined = value.inlined;
      this._locationType = value.locationType;
      this._uri = value.uri;
    }
  }

  // deploy_by_default - computed: false, optional: true, required: false
  private _deployByDefault?: boolean | cdktf.IResolvable; 
  public get deployByDefault() {
    return this.getBooleanAttribute('deploy_by_default');
  }
  public set deployByDefault(value: boolean | cdktf.IResolvable) {
    this._deployByDefault = value;
  }
  public resetDeployByDefault() {
    this._deployByDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deployByDefaultInput() {
    return this._deployByDefault;
  }

  // endpoints - computed: false, optional: true, required: false
  private _endpoints = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpointsList(this, "endpoints", false);
  public get endpoints() {
    return this._endpoints;
  }
  public putEndpoints(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftEndpoints[] | cdktf.IResolvable) {
    this._endpoints.internalValue = value;
  }
  public resetEndpoints() {
    this._endpoints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointsInput() {
    return this._endpoints.internalValue;
  }

  // inlined - computed: false, optional: true, required: false
  private _inlined?: string; 
  public get inlined() {
    return this.getStringAttribute('inlined');
  }
  public set inlined(value: string) {
    this._inlined = value;
  }
  public resetInlined() {
    this._inlined = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlinedInput() {
    return this._inlined;
  }

  // location_type - computed: false, optional: true, required: false
  private _locationType?: string; 
  public get locationType() {
    return this.getStringAttribute('location_type');
  }
  public set locationType(value: string) {
    this._locationType = value;
  }
  public resetLocationType() {
    this._locationType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationTypeInput() {
    return this._locationType;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume {
  /**
  * Ephemeral volumes are not stored persistently across restarts. Defaults to false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#ephemeral DataK8SOrgEclipseCheCheClusterV1Manifest#ephemeral}
  */
  readonly ephemeral?: boolean | cdktf.IResolvable;
  /**
  * Size of the volume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#size DataK8SOrgEclipseCheCheClusterV1Manifest#size}
  */
  readonly size?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolumeToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ephemeral: cdktf.booleanToTerraform(struct!.ephemeral),
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolumeToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ephemeral: {
      value: cdktf.booleanToHclTerraform(struct!.ephemeral),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ephemeral !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeral = this._ephemeral;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ephemeral = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ephemeral = value.ephemeral;
      this._size = value.size;
    }
  }

  // ephemeral - computed: false, optional: true, required: false
  private _ephemeral?: boolean | cdktf.IResolvable; 
  public get ephemeral() {
    return this.getBooleanAttribute('ephemeral');
  }
  public set ephemeral(value: boolean | cdktf.IResolvable) {
    this._ephemeral = value;
  }
  public resetEphemeral() {
    this._ephemeral = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralInput() {
    return this._ephemeral;
  }

  // size - computed: false, optional: true, required: false
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  public resetSize() {
    this._size = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents {
  /**
  * Map of implementation-dependant free-form YAML attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Type of component
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#component_type DataK8SOrgEclipseCheCheClusterV1Manifest#component_type}
  */
  readonly componentType?: string;
  /**
  * Allows adding and configuring devworkspace-related containers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container DataK8SOrgEclipseCheCheClusterV1Manifest#container}
  */
  readonly container?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer;
  /**
  * Allows specifying the definition of an image for outer loop builds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image DataK8SOrgEclipseCheCheClusterV1Manifest#image}
  */
  readonly image?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage;
  /**
  * Allows importing into the devworkspace the Kubernetes resources defined in a given manifest. For example this allows reusing the Kubernetes definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#kubernetes DataK8SOrgEclipseCheCheClusterV1Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes;
  /**
  * Mandatory name that allows referencing the component from other elements (such as commands) or from an external devfile that may reference this component through a parent or a plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Allows importing into the devworkspace the OpenShift resources defined in a given manifest. For example this allows reusing the OpenShift definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#openshift DataK8SOrgEclipseCheCheClusterV1Manifest#openshift}
  */
  readonly openshift?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift;
  /**
  * Allows specifying the definition of a volume shared by several other components
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#volume DataK8SOrgEclipseCheCheClusterV1Manifest#volume}
  */
  readonly volume?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    component_type: cdktf.stringToTerraform(struct!.componentType),
    container: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerToTerraform(struct!.container),
    image: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageToTerraform(struct!.image),
    kubernetes: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesToTerraform(struct!.kubernetes),
    name: cdktf.stringToTerraform(struct!.name),
    openshift: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftToTerraform(struct!.openshift),
    volume: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolumeToTerraform(struct!.volume),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    component_type: {
      value: cdktf.stringToHclTerraform(struct!.componentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerToHclTerraform(struct!.container),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer",
    },
    image: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage",
    },
    kubernetes: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    openshift: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftToHclTerraform(struct!.openshift),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift",
    },
    volume: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._componentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.componentType = this._componentType;
    }
    if (this._container?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container?.internalValue;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._openshift?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openshift = this._openshift?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributes = undefined;
      this._componentType = undefined;
      this._container.internalValue = undefined;
      this._image.internalValue = undefined;
      this._kubernetes.internalValue = undefined;
      this._name = undefined;
      this._openshift.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributes = value.attributes;
      this._componentType = value.componentType;
      this._container.internalValue = value.container;
      this._image.internalValue = value.image;
      this._kubernetes.internalValue = value.kubernetes;
      this._name = value.name;
      this._openshift.internalValue = value.openshift;
      this._volume.internalValue = value.volume;
    }
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // component_type - computed: false, optional: true, required: false
  private _componentType?: string; 
  public get componentType() {
    return this.getStringAttribute('component_type');
  }
  public set componentType(value: string) {
    this._componentType = value;
  }
  public resetComponentType() {
    this._componentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentTypeInput() {
    return this._componentType;
  }

  // container - computed: false, optional: true, required: false
  private _container = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainerOutputReference(this, "container");
  public get container() {
    return this._container;
  }
  public putContainer(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsContainer) {
    this._container.internalValue = value;
  }
  public resetContainer() {
    this._container.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsImage) {
    this._image.internalValue = value;
  }
  public resetImage() {
    this._image.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // openshift - computed: false, optional: true, required: false
  private _openshift = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshiftOutputReference(this, "openshift");
  public get openshift() {
    return this._openshift;
  }
  public putOpenshift(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOpenshift) {
    this._openshift.internalValue = value;
  }
  public resetOpenshift() {
    this._openshift.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openshiftInput() {
    return this._openshift.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#namespace DataK8SOrgEclipseCheCheClusterV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetesToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetesToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin {
  /**
  * Overrides of commands encapsulated in a parent devfile or a plugin. Overriding is done according to K8S strategic merge patch standard rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#commands DataK8SOrgEclipseCheCheClusterV1Manifest#commands}
  */
  readonly commands?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands[] | cdktf.IResolvable;
  /**
  * Overrides of components encapsulated in a parent devfile or a plugin. Overriding is done according to K8S strategic merge patch standard rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#components DataK8SOrgEclipseCheCheClusterV1Manifest#components}
  */
  readonly components?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents[] | cdktf.IResolvable;
  /**
  * Id in a registry that contains a Devfile yaml file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#id DataK8SOrgEclipseCheCheClusterV1Manifest#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * type of location from where the referenced template structure should be retrieved
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#import_reference_type DataK8SOrgEclipseCheCheClusterV1Manifest#import_reference_type}
  */
  readonly importReferenceType?: string;
  /**
  * Reference to a Kubernetes CRD of type DevWorkspaceTemplate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#kubernetes DataK8SOrgEclipseCheCheClusterV1Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes;
  /**
  * Registry URL to pull the parent devfile from when using id in the parent reference. To ensure the parent devfile gets resolved consistently in different environments, it is recommended to always specify the 'registryUrl' when 'id' is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#registry_url DataK8SOrgEclipseCheCheClusterV1Manifest#registry_url}
  */
  readonly registryUrl?: string;
  /**
  * URI Reference of a parent devfile YAML file. It can be a full URL or a relative URI with the current devfile as the base URI.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#uri DataK8SOrgEclipseCheCheClusterV1Manifest#uri}
  */
  readonly uri?: string;
  /**
  * Specific stack/sample version to pull the parent devfile from, when using id in the parent reference. To specify 'version', 'id' must be defined and used as the import reference source. 'version' can be either a specific stack version, or 'latest'. If no 'version' specified, default version will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#version DataK8SOrgEclipseCheCheClusterV1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commands: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsToTerraform, false)(struct!.commands),
    components: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsToTerraform, false)(struct!.components),
    id: cdktf.stringToTerraform(struct!.id),
    import_reference_type: cdktf.stringToTerraform(struct!.importReferenceType),
    kubernetes: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetesToTerraform(struct!.kubernetes),
    registry_url: cdktf.stringToTerraform(struct!.registryUrl),
    uri: cdktf.stringToTerraform(struct!.uri),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commands: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsToHclTerraform, false)(struct!.commands),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsList",
    },
    components: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsToHclTerraform, false)(struct!.components),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    import_reference_type: {
      value: cdktf.stringToHclTerraform(struct!.importReferenceType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubernetes: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes",
    },
    registry_url: {
      value: cdktf.stringToHclTerraform(struct!.registryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uri: {
      value: cdktf.stringToHclTerraform(struct!.uri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commands?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.commands = this._commands?.internalValue;
    }
    if (this._components?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.components = this._components?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._importReferenceType !== undefined) {
      hasAnyValues = true;
      internalValueResult.importReferenceType = this._importReferenceType;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._registryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.registryUrl = this._registryUrl;
    }
    if (this._uri !== undefined) {
      hasAnyValues = true;
      internalValueResult.uri = this._uri;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commands.internalValue = undefined;
      this._components.internalValue = undefined;
      this._id = undefined;
      this._importReferenceType = undefined;
      this._kubernetes.internalValue = undefined;
      this._registryUrl = undefined;
      this._uri = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commands.internalValue = value.commands;
      this._components.internalValue = value.components;
      this._id = value.id;
      this._importReferenceType = value.importReferenceType;
      this._kubernetes.internalValue = value.kubernetes;
      this._registryUrl = value.registryUrl;
      this._uri = value.uri;
      this._version = value.version;
    }
  }

  // commands - computed: false, optional: true, required: false
  private _commands = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommandsList(this, "commands", false);
  public get commands() {
    return this._commands;
  }
  public putCommands(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginCommands[] | cdktf.IResolvable) {
    this._commands.internalValue = value;
  }
  public resetCommands() {
    this._commands.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandsInput() {
    return this._commands.internalValue;
  }

  // components - computed: false, optional: true, required: false
  private _components = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponentsList(this, "components", false);
  public get components() {
    return this._components;
  }
  public putComponents(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginComponents[] | cdktf.IResolvable) {
    this._components.internalValue = value;
  }
  public resetComponents() {
    this._components.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentsInput() {
    return this._components.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // import_reference_type - computed: false, optional: true, required: false
  private _importReferenceType?: string; 
  public get importReferenceType() {
    return this.getStringAttribute('import_reference_type');
  }
  public set importReferenceType(value: string) {
    this._importReferenceType = value;
  }
  public resetImportReferenceType() {
    this._importReferenceType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get importReferenceTypeInput() {
    return this._importReferenceType;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // registry_url - computed: false, optional: true, required: false
  private _registryUrl?: string; 
  public get registryUrl() {
    return this.getStringAttribute('registry_url');
  }
  public set registryUrl(value: string) {
    this._registryUrl = value;
  }
  public resetRegistryUrl() {
    this._registryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get registryUrlInput() {
    return this._registryUrl;
  }

  // uri - computed: false, optional: true, required: false
  private _uri?: string; 
  public get uri() {
    return this.getStringAttribute('uri');
  }
  public set uri(value: string) {
    this._uri = value;
  }
  public resetUri() {
    this._uri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uriInput() {
    return this._uri;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume {
  /**
  * Ephemeral volumes are not stored persistently across restarts. Defaults to false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#ephemeral DataK8SOrgEclipseCheCheClusterV1Manifest#ephemeral}
  */
  readonly ephemeral?: boolean | cdktf.IResolvable;
  /**
  * Size of the volume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#size DataK8SOrgEclipseCheCheClusterV1Manifest#size}
  */
  readonly size?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolumeToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ephemeral: cdktf.booleanToTerraform(struct!.ephemeral),
    size: cdktf.stringToTerraform(struct!.size),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolumeToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ephemeral: {
      value: cdktf.booleanToHclTerraform(struct!.ephemeral),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    size: {
      value: cdktf.stringToHclTerraform(struct!.size),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ephemeral !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeral = this._ephemeral;
    }
    if (this._size !== undefined) {
      hasAnyValues = true;
      internalValueResult.size = this._size;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ephemeral = undefined;
      this._size = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ephemeral = value.ephemeral;
      this._size = value.size;
    }
  }

  // ephemeral - computed: false, optional: true, required: false
  private _ephemeral?: boolean | cdktf.IResolvable; 
  public get ephemeral() {
    return this.getBooleanAttribute('ephemeral');
  }
  public set ephemeral(value: boolean | cdktf.IResolvable) {
    this._ephemeral = value;
  }
  public resetEphemeral() {
    this._ephemeral = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralInput() {
    return this._ephemeral;
  }

  // size - computed: false, optional: true, required: false
  private _size?: string; 
  public get size() {
    return this.getStringAttribute('size');
  }
  public set size(value: string) {
    this._size = value;
  }
  public resetSize() {
    this._size = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sizeInput() {
    return this._size;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents {
  /**
  * Map of implementation-dependant free-form YAML attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#attributes DataK8SOrgEclipseCheCheClusterV1Manifest#attributes}
  */
  readonly attributes?: { [key: string]: string };
  /**
  * Type of component
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#component_type DataK8SOrgEclipseCheCheClusterV1Manifest#component_type}
  */
  readonly componentType?: string;
  /**
  * Allows adding and configuring devworkspace-related containers
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#container DataK8SOrgEclipseCheCheClusterV1Manifest#container}
  */
  readonly container?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer;
  /**
  * Custom component whose logic is implementation-dependant and should be provided by the user possibly through some dedicated controller
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#custom DataK8SOrgEclipseCheCheClusterV1Manifest#custom}
  */
  readonly custom?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom;
  /**
  * Allows specifying the definition of an image for outer loop builds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image DataK8SOrgEclipseCheCheClusterV1Manifest#image}
  */
  readonly image?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage;
  /**
  * Allows importing into the devworkspace the Kubernetes resources defined in a given manifest. For example this allows reusing the Kubernetes definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#kubernetes DataK8SOrgEclipseCheCheClusterV1Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes;
  /**
  * Mandatory name that allows referencing the component from other elements (such as commands) or from an external devfile that may reference this component through a parent or a plugin.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#name DataK8SOrgEclipseCheCheClusterV1Manifest#name}
  */
  readonly name: string;
  /**
  * Allows importing into the devworkspace the OpenShift resources defined in a given manifest. For example this allows reusing the OpenShift definitions used to deploy some runtime components in production.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#openshift DataK8SOrgEclipseCheCheClusterV1Manifest#openshift}
  */
  readonly openshift?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift;
  /**
  * Allows importing a plugin. Plugins are mainly imported devfiles that contribute components, commands and events as a consistent single unit. They are defined in either YAML files following the devfile syntax, or as 'DevWorkspaceTemplate' Kubernetes Custom Resources
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin DataK8SOrgEclipseCheCheClusterV1Manifest#plugin}
  */
  readonly plugin?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin;
  /**
  * Allows specifying the definition of a volume shared by several other components
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#volume DataK8SOrgEclipseCheCheClusterV1Manifest#volume}
  */
  readonly volume?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    attributes: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.attributes),
    component_type: cdktf.stringToTerraform(struct!.componentType),
    container: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerToTerraform(struct!.container),
    custom: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustomToTerraform(struct!.custom),
    image: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageToTerraform(struct!.image),
    kubernetes: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesToTerraform(struct!.kubernetes),
    name: cdktf.stringToTerraform(struct!.name),
    openshift: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftToTerraform(struct!.openshift),
    plugin: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginToTerraform(struct!.plugin),
    volume: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolumeToTerraform(struct!.volume),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    attributes: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.attributes),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    component_type: {
      value: cdktf.stringToHclTerraform(struct!.componentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerToHclTerraform(struct!.container),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer",
    },
    custom: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustomToHclTerraform(struct!.custom),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom",
    },
    image: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageToHclTerraform(struct!.image),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage",
    },
    kubernetes: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    openshift: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftToHclTerraform(struct!.openshift),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift",
    },
    plugin: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginToHclTerraform(struct!.plugin),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin",
    },
    volume: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolumeToHclTerraform(struct!.volume),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._attributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.attributes = this._attributes;
    }
    if (this._componentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.componentType = this._componentType;
    }
    if (this._container?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container?.internalValue;
    }
    if (this._custom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.custom = this._custom?.internalValue;
    }
    if (this._image?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image?.internalValue;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._openshift?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openshift = this._openshift?.internalValue;
    }
    if (this._plugin?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugin = this._plugin?.internalValue;
    }
    if (this._volume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volume = this._volume?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._attributes = undefined;
      this._componentType = undefined;
      this._container.internalValue = undefined;
      this._custom.internalValue = undefined;
      this._image.internalValue = undefined;
      this._kubernetes.internalValue = undefined;
      this._name = undefined;
      this._openshift.internalValue = undefined;
      this._plugin.internalValue = undefined;
      this._volume.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._attributes = value.attributes;
      this._componentType = value.componentType;
      this._container.internalValue = value.container;
      this._custom.internalValue = value.custom;
      this._image.internalValue = value.image;
      this._kubernetes.internalValue = value.kubernetes;
      this._name = value.name;
      this._openshift.internalValue = value.openshift;
      this._plugin.internalValue = value.plugin;
      this._volume.internalValue = value.volume;
    }
  }

  // attributes - computed: false, optional: true, required: false
  private _attributes?: { [key: string]: string }; 
  public get attributes() {
    return this.getStringMapAttribute('attributes');
  }
  public set attributes(value: { [key: string]: string }) {
    this._attributes = value;
  }
  public resetAttributes() {
    this._attributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get attributesInput() {
    return this._attributes;
  }

  // component_type - computed: false, optional: true, required: false
  private _componentType?: string; 
  public get componentType() {
    return this.getStringAttribute('component_type');
  }
  public set componentType(value: string) {
    this._componentType = value;
  }
  public resetComponentType() {
    this._componentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get componentTypeInput() {
    return this._componentType;
  }

  // container - computed: false, optional: true, required: false
  private _container = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainerOutputReference(this, "container");
  public get container() {
    return this._container;
  }
  public putContainer(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsContainer) {
    this._container.internalValue = value;
  }
  public resetContainer() {
    this._container.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container.internalValue;
  }

  // custom - computed: false, optional: true, required: false
  private _custom = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustomOutputReference(this, "custom");
  public get custom() {
    return this._custom;
  }
  public putCustom(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsCustom) {
    this._custom.internalValue = value;
  }
  public resetCustom() {
    this._custom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInput() {
    return this._custom.internalValue;
  }

  // image - computed: false, optional: true, required: false
  private _image = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImageOutputReference(this, "image");
  public get image() {
    return this._image;
  }
  public putImage(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsImage) {
    this._image.internalValue = value;
  }
  public resetImage() {
    this._image.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image.internalValue;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // openshift - computed: false, optional: true, required: false
  private _openshift = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshiftOutputReference(this, "openshift");
  public get openshift() {
    return this._openshift;
  }
  public putOpenshift(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOpenshift) {
    this._openshift.internalValue = value;
  }
  public resetOpenshift() {
    this._openshift.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openshiftInput() {
    return this._openshift.internalValue;
  }

  // plugin - computed: false, optional: true, required: false
  private _plugin = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPluginOutputReference(this, "plugin");
  public get plugin() {
    return this._plugin;
  }
  public putPlugin(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsPlugin) {
    this._plugin.internalValue = value;
  }
  public resetPlugin() {
    this._plugin.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginInput() {
    return this._plugin.internalValue;
  }

  // volume - computed: false, optional: true, required: false
  private _volume = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolumeOutputReference(this, "volume");
  public get volume() {
    return this._volume;
  }
  public putVolume(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsVolume) {
    this._volume.internalValue = value;
  }
  public resetVolume() {
    this._volume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeInput() {
    return this._volume.internalValue;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#effect DataK8SOrgEclipseCheCheClusterV1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#key DataK8SOrgEclipseCheCheClusterV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#operator DataK8SOrgEclipseCheCheClusterV1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#toleration_seconds DataK8SOrgEclipseCheCheClusterV1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#value DataK8SOrgEclipseCheCheClusterV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins {
  /**
  * The editor id to specify default plug-ins for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#editor DataK8SOrgEclipseCheCheClusterV1Manifest#editor}
  */
  readonly editor?: string;
  /**
  * Default plug-in uris for the specified editor.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugins DataK8SOrgEclipseCheCheClusterV1Manifest#plugins}
  */
  readonly plugins?: string[];
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    editor: cdktf.stringToTerraform(struct!.editor),
    plugins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.plugins),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    editor: {
      value: cdktf.stringToHclTerraform(struct!.editor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.plugins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._editor !== undefined) {
      hasAnyValues = true;
      internalValueResult.editor = this._editor;
    }
    if (this._plugins !== undefined) {
      hasAnyValues = true;
      internalValueResult.plugins = this._plugins;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._editor = undefined;
      this._plugins = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._editor = value.editor;
      this._plugins = value.plugins;
    }
  }

  // editor - computed: false, optional: true, required: false
  private _editor?: string; 
  public get editor() {
    return this.getStringAttribute('editor');
  }
  public set editor(value: string) {
    this._editor = value;
  }
  public resetEditor() {
    this._editor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get editorInput() {
    return this._editor;
  }

  // plugins - computed: false, optional: true, required: false
  private _plugins?: string[]; 
  public get plugins() {
    return this.getListAttribute('plugins');
  }
  public set plugins(value: string[]) {
    this._plugins = value;
  }
  public resetPlugins() {
    this._plugins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginsInput() {
    return this._plugins;
  }
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsOutputReference {
    return new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer {
  /**
  * Optional host name, or URL, to an alternate container registry to pull images from. This value overrides the container registry host name defined in all the default container images involved in a Che deployment. This is particularly useful to install Che in a restricted environment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#air_gap_container_registry_hostname DataK8SOrgEclipseCheCheClusterV1Manifest#air_gap_container_registry_hostname}
  */
  readonly airGapContainerRegistryHostname?: string;
  /**
  * Optional repository name of an alternate container registry to pull images from. This value overrides the container registry organization defined in all the default container images involved in a Che deployment. This is particularly useful to install Eclipse Che in a restricted environment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#air_gap_container_registry_organization DataK8SOrgEclipseCheCheClusterV1Manifest#air_gap_container_registry_organization}
  */
  readonly airGapContainerRegistryOrganization?: string;
  /**
  * Indicates if is allowed to automatically create a user namespace. If it set to false, then user namespace must be pre-created by a cluster administrator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#allow_auto_provision_user_namespace DataK8SOrgEclipseCheCheClusterV1Manifest#allow_auto_provision_user_namespace}
  */
  readonly allowAutoProvisionUserNamespace?: boolean | cdktf.IResolvable;
  /**
  * Deprecated. The value of this flag is ignored. Defines that a user is allowed to specify a Kubernetes namespace, or an OpenShift project, which differs from the default. It's NOT RECOMMENDED to set to 'true' without OpenShift OAuth configured. The OpenShift infrastructure also uses this property.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#allow_user_defined_workspace_namespaces DataK8SOrgEclipseCheCheClusterV1Manifest#allow_user_defined_workspace_namespaces}
  */
  readonly allowUserDefinedWorkspaceNamespaces?: boolean | cdktf.IResolvable;
  /**
  * A comma-separated list of ClusterRoles that will be assigned to Che ServiceAccount. Each role must have 'app.kubernetes.io/part-of=che.eclipse.org' label. Be aware that the Che Operator has to already have all permissions in these ClusterRoles to grant them.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_cluster_roles DataK8SOrgEclipseCheCheClusterV1Manifest#che_cluster_roles}
  */
  readonly cheClusterRoles?: string;
  /**
  * Enables the debug mode for Che server. Defaults to 'false'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_debug DataK8SOrgEclipseCheCheClusterV1Manifest#che_debug}
  */
  readonly cheDebug?: string;
  /**
  * Deprecated. The value of this flag is ignored. Specifies a variation of the installation. The options are 'che' for upstream Che installations or 'devspaces' for Red Hat OpenShift Dev Spaces (formerly Red Hat CodeReady Workspaces) installation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_flavor DataK8SOrgEclipseCheCheClusterV1Manifest#che_flavor}
  */
  readonly cheFlavor?: string;
  /**
  * Public host name of the installed Che server. When value is omitted, the value it will be automatically set by the Operator. See the 'cheHostTLSSecret' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_host DataK8SOrgEclipseCheCheClusterV1Manifest#che_host}
  */
  readonly cheHost?: string;
  /**
  * Name of a secret containing certificates to secure ingress or route for the custom host name of the installed Che server. The secret must have 'app.kubernetes.io/part-of=che.eclipse.org' label. See the 'cheHost' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_host_tls_secret DataK8SOrgEclipseCheCheClusterV1Manifest#che_host_tls_secret}
  */
  readonly cheHostTlsSecret?: string;
  /**
  * Overrides the container image used in Che deployment. This does NOT include the container image tag. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_image DataK8SOrgEclipseCheCheClusterV1Manifest#che_image}
  */
  readonly cheImage?: string;
  /**
  * Overrides the image pull policy used in Che deployment. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_image_pull_policy DataK8SOrgEclipseCheCheClusterV1Manifest#che_image_pull_policy}
  */
  readonly cheImagePullPolicy?: string;
  /**
  * Overrides the tag of the container image used in Che deployment. Omit it or leave it empty to use the default image tag provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_image_tag DataK8SOrgEclipseCheCheClusterV1Manifest#che_image_tag}
  */
  readonly cheImageTag?: string;
  /**
  * Log level for the Che server: 'INFO' or 'DEBUG'. Defaults to 'INFO'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_log_level DataK8SOrgEclipseCheCheClusterV1Manifest#che_log_level}
  */
  readonly cheLogLevel?: string;
  /**
  * List of environment variables to set in the Che server container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_server_env DataK8SOrgEclipseCheCheClusterV1Manifest#che_server_env}
  */
  readonly cheServerEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv[] | cdktf.IResolvable;
  /**
  * The Che server ingress custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_server_ingress DataK8SOrgEclipseCheCheClusterV1Manifest#che_server_ingress}
  */
  readonly cheServerIngress?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress;
  /**
  * The Che server route custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_server_route DataK8SOrgEclipseCheCheClusterV1Manifest#che_server_route}
  */
  readonly cheServerRoute?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute;
  /**
  * Custom cluster role bound to the user for the Che workspaces. The role must have 'app.kubernetes.io/part-of=che.eclipse.org' label. The default roles are used when omitted or left blank.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#che_workspace_cluster_role DataK8SOrgEclipseCheCheClusterV1Manifest#che_workspace_cluster_role}
  */
  readonly cheWorkspaceClusterRole?: string;
  /**
  * Map of additional environment variables that will be applied in the generated 'che' ConfigMap to be used by the Che server, in addition to the values already generated from other fields of the 'CheCluster' custom resource (CR). When 'customCheProperties' contains a property that would be normally generated in 'che' ConfigMap from other CR fields, the value defined in the 'customCheProperties' is used instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#custom_che_properties DataK8SOrgEclipseCheCheClusterV1Manifest#custom_che_properties}
  */
  readonly customCheProperties?: { [key: string]: string };
  /**
  * Overrides the CPU limit used in the dashboard deployment. In cores. (500m = .5 cores). Default to 500m.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_cpu_limit DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_cpu_limit}
  */
  readonly dashboardCpuLimit?: string;
  /**
  * Overrides the CPU request used in the dashboard deployment. In cores. (500m = .5 cores). Default to 100m.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_cpu_request DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_cpu_request}
  */
  readonly dashboardCpuRequest?: string;
  /**
  * List of environment variables to set in the dashboard container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_env DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_env}
  */
  readonly dashboardEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv[] | cdktf.IResolvable;
  /**
  * Overrides the container image used in the dashboard deployment. This includes the image tag. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_image DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_image}
  */
  readonly dashboardImage?: string;
  /**
  * Overrides the image pull policy used in the dashboard deployment. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_image_pull_policy DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_image_pull_policy}
  */
  readonly dashboardImagePullPolicy?: string;
  /**
  * Deprecated. The value of this flag is ignored. Dashboard ingress custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_ingress DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_ingress}
  */
  readonly dashboardIngress?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress;
  /**
  * Overrides the memory limit used in the dashboard deployment. Defaults to 256Mi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_memory_limit DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_memory_limit}
  */
  readonly dashboardMemoryLimit?: string;
  /**
  * Overrides the memory request used in the dashboard deployment. Defaults to 16Mi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_memory_request DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_memory_request}
  */
  readonly dashboardMemoryRequest?: string;
  /**
  * Deprecated. The value of this flag is ignored. Dashboard route custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard_route DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard_route}
  */
  readonly dashboardRoute?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute;
  /**
  * Overrides the CPU limit used in the devfile registry deployment. In cores. (500m = .5 cores). Default to 500m.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_cpu_limit DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_cpu_limit}
  */
  readonly devfileRegistryCpuLimit?: string;
  /**
  * Overrides the CPU request used in the devfile registry deployment. In cores. (500m = .5 cores). Default to 100m.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_cpu_request DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_cpu_request}
  */
  readonly devfileRegistryCpuRequest?: string;
  /**
  * List of environment variables to set in the plugin registry container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_env DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_env}
  */
  readonly devfileRegistryEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv[] | cdktf.IResolvable;
  /**
  * Overrides the container image used in the devfile registry deployment. This includes the image tag. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_image DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_image}
  */
  readonly devfileRegistryImage?: string;
  /**
  * Deprecated. The value of this flag is ignored. The devfile registry ingress custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_ingress DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_ingress}
  */
  readonly devfileRegistryIngress?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress;
  /**
  * Overrides the memory limit used in the devfile registry deployment. Defaults to 256Mi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_memory_limit DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_memory_limit}
  */
  readonly devfileRegistryMemoryLimit?: string;
  /**
  * Overrides the memory request used in the devfile registry deployment. Defaults to 16Mi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_memory_request DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_memory_request}
  */
  readonly devfileRegistryMemoryRequest?: string;
  /**
  * Overrides the image pull policy used in the devfile registry deployment. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_pull_policy DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_pull_policy}
  */
  readonly devfileRegistryPullPolicy?: string;
  /**
  * Deprecated. The value of this flag is ignored. The devfile registry route custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_route DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_route}
  */
  readonly devfileRegistryRoute?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute;
  /**
  * Deprecated in favor of 'externalDevfileRegistries' fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#devfile_registry_url DataK8SOrgEclipseCheCheClusterV1Manifest#devfile_registry_url}
  */
  readonly devfileRegistryUrl?: string;
  /**
  * Deprecated. The value of this flag is ignored. Disable internal cluster SVC names usage to communicate between components to speed up the traffic and avoid proxy issues.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#disable_internal_cluster_svc_names DataK8SOrgEclipseCheCheClusterV1Manifest#disable_internal_cluster_svc_names}
  */
  readonly disableInternalClusterSvcNames?: boolean | cdktf.IResolvable;
  /**
  * External devfile registries, that serves sample, ready-to-use devfiles. Configure this in addition to a dedicated devfile registry (when 'externalDevfileRegistry' is 'false') or instead of it (when 'externalDevfileRegistry' is 'true')
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#external_devfile_registries DataK8SOrgEclipseCheCheClusterV1Manifest#external_devfile_registries}
  */
  readonly externalDevfileRegistries?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries[] | cdktf.IResolvable;
  /**
  * Instructs the Operator on whether to deploy a dedicated devfile registry server. By default, a dedicated devfile registry server is started. When 'externalDevfileRegistry' is 'true', no such dedicated server will be started by the Operator and configure at least one devfile registry with 'externalDevfileRegistries' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#external_devfile_registry DataK8SOrgEclipseCheCheClusterV1Manifest#external_devfile_registry}
  */
  readonly externalDevfileRegistry?: boolean | cdktf.IResolvable;
  /**
  * Instructs the Operator on whether to deploy a dedicated plugin registry server. By default, a dedicated plugin registry server is started. When 'externalPluginRegistry' is 'true', no such dedicated server will be started by the Operator and you will have to manually set the 'pluginRegistryUrl' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#external_plugin_registry DataK8SOrgEclipseCheCheClusterV1Manifest#external_plugin_registry}
  */
  readonly externalPluginRegistry?: boolean | cdktf.IResolvable;
  /**
  * When enabled, the certificate from 'che-git-self-signed-cert' ConfigMap will be propagated to the Che components and provide particular configuration for Git. Note, the 'che-git-self-signed-cert' ConfigMap must have 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#git_self_signed_cert DataK8SOrgEclipseCheCheClusterV1Manifest#git_self_signed_cert}
  */
  readonly gitSelfSignedCert?: boolean | cdktf.IResolvable;
  /**
  * List of hosts that will be reached directly, bypassing the proxy. Specify wild card domain use the following form '.<DOMAIN>' and '|' as delimiter, for example: 'localhost|.my.host.com|123.42.12.32' Only use when configuring a proxy is required. Operator respects OpenShift cluster wide proxy configuration and no additional configuration is required, but defining 'nonProxyHosts' in a custom resource leads to merging non proxy hosts lists from the cluster proxy configuration and ones defined in the custom resources. See the doc https://docs.openshift.com/container-platform/4.4/networking/enable-cluster-wide-proxy.html. See also the 'proxyURL' fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#non_proxy_hosts DataK8SOrgEclipseCheCheClusterV1Manifest#non_proxy_hosts}
  */
  readonly nonProxyHosts?: string;
  /**
  * Open VSX registry URL. If omitted an embedded instance will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#open_vsx_registry_url DataK8SOrgEclipseCheCheClusterV1Manifest#open_vsx_registry_url}
  */
  readonly openVsxRegistryUrl?: string;
  /**
  * Overrides the CPU limit used in the plugin registry deployment. In cores. (500m = .5 cores). Default to 500m.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_cpu_limit DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_cpu_limit}
  */
  readonly pluginRegistryCpuLimit?: string;
  /**
  * Overrides the CPU request used in the plugin registry deployment. In cores. (500m = .5 cores). Default to 100m.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_cpu_request DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_cpu_request}
  */
  readonly pluginRegistryCpuRequest?: string;
  /**
  * List of environment variables to set in the devfile registry container.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_env DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_env}
  */
  readonly pluginRegistryEnv?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv[] | cdktf.IResolvable;
  /**
  * Overrides the container image used in the plugin registry deployment. This includes the image tag. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_image DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_image}
  */
  readonly pluginRegistryImage?: string;
  /**
  * Deprecated. The value of this flag is ignored. Plugin registry ingress custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_ingress DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_ingress}
  */
  readonly pluginRegistryIngress?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress;
  /**
  * Overrides the memory limit used in the plugin registry deployment. Defaults to 1536Mi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_memory_limit DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_memory_limit}
  */
  readonly pluginRegistryMemoryLimit?: string;
  /**
  * Overrides the memory request used in the plugin registry deployment. Defaults to 16Mi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_memory_request DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_memory_request}
  */
  readonly pluginRegistryMemoryRequest?: string;
  /**
  * Overrides the image pull policy used in the plugin registry deployment. Default value is 'Always' for 'nightly', 'next' or 'latest' images, and 'IfNotPresent' in other cases.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_pull_policy DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_pull_policy}
  */
  readonly pluginRegistryPullPolicy?: string;
  /**
  * Deprecated. The value of this flag is ignored. Plugin registry route custom settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_route DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_route}
  */
  readonly pluginRegistryRoute?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute;
  /**
  * Public URL of the plugin registry that serves sample ready-to-use devfiles. Set this ONLY when a use of an external devfile registry is needed. See the 'externalPluginRegistry' field. By default, this will be automatically calculated by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#plugin_registry_url DataK8SOrgEclipseCheCheClusterV1Manifest#plugin_registry_url}
  */
  readonly pluginRegistryUrl?: string;
  /**
  * Password of the proxy server. Only use when proxy configuration is required. See the 'proxyURL', 'proxyUser' and 'proxySecret' fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#proxy_password DataK8SOrgEclipseCheCheClusterV1Manifest#proxy_password}
  */
  readonly proxyPassword?: string;
  /**
  * Port of the proxy server. Only use when configuring a proxy is required. See also the 'proxyURL' and 'nonProxyHosts' fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#proxy_port DataK8SOrgEclipseCheCheClusterV1Manifest#proxy_port}
  */
  readonly proxyPort?: string;
  /**
  * The secret that contains 'user' and 'password' for a proxy server. When the secret is defined, the 'proxyUser' and 'proxyPassword' are ignored. The secret must have 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#proxy_secret DataK8SOrgEclipseCheCheClusterV1Manifest#proxy_secret}
  */
  readonly proxySecret?: string;
  /**
  * URL (protocol+host name) of the proxy server. This drives the appropriate changes in the 'JAVA_OPTS' and 'https(s)_proxy' variables in the Che server and workspaces containers. Only use when configuring a proxy is required. Operator respects OpenShift cluster wide proxy configuration and no additional configuration is required, but defining 'proxyUrl' in a custom resource leads to overrides the cluster proxy configuration with fields 'proxyUrl', 'proxyPort', 'proxyUser' and 'proxyPassword' from the custom resource. See the doc https://docs.openshift.com/container-platform/4.4/networking/enable-cluster-wide-proxy.html. See also the 'proxyPort' and 'nonProxyHosts' fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#proxy_url DataK8SOrgEclipseCheCheClusterV1Manifest#proxy_url}
  */
  readonly proxyUrl?: string;
  /**
  * User name of the proxy server. Only use when configuring a proxy is required. See also the 'proxyURL', 'proxyPassword' and 'proxySecret' fields.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#proxy_user DataK8SOrgEclipseCheCheClusterV1Manifest#proxy_user}
  */
  readonly proxyUser?: string;
  /**
  * Deprecated. The value of this flag is ignored. The Che Operator will automatically detect whether the router certificate is self-signed and propagate it to other components, such as the Che server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#self_signed_cert DataK8SOrgEclipseCheCheClusterV1Manifest#self_signed_cert}
  */
  readonly selfSignedCert?: boolean | cdktf.IResolvable;
  /**
  * Overrides the CPU limit used in the Che server deployment In cores. (500m = .5 cores). Default to 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#server_cpu_limit DataK8SOrgEclipseCheCheClusterV1Manifest#server_cpu_limit}
  */
  readonly serverCpuLimit?: string;
  /**
  * Overrides the CPU request used in the Che server deployment In cores. (500m = .5 cores). Default to 100m.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#server_cpu_request DataK8SOrgEclipseCheCheClusterV1Manifest#server_cpu_request}
  */
  readonly serverCpuRequest?: string;
  /**
  * Deprecated. The value of this flag is ignored. Sets the server and workspaces exposure type. Possible values are 'multi-host', 'single-host', 'default-host'. Defaults to 'multi-host', which creates a separate ingress, or OpenShift routes, for every required endpoint. 'single-host' makes Che exposed on a single host name with workspaces exposed on subpaths. Read the docs to learn about the limitations of this approach. Also consult the 'singleHostExposureType' property to further configure how the Operator and the Che server make that happen on Kubernetes. 'default-host' exposes the Che server on the host of the cluster. Read the docs to learn about the limitations of this approach.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#server_exposure_strategy DataK8SOrgEclipseCheCheClusterV1Manifest#server_exposure_strategy}
  */
  readonly serverExposureStrategy?: string;
  /**
  * Overrides the memory limit used in the Che server deployment. Defaults to 1Gi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#server_memory_limit DataK8SOrgEclipseCheCheClusterV1Manifest#server_memory_limit}
  */
  readonly serverMemoryLimit?: string;
  /**
  * Overrides the memory request used in the Che server deployment. Defaults to 512Mi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#server_memory_request DataK8SOrgEclipseCheCheClusterV1Manifest#server_memory_request}
  */
  readonly serverMemoryRequest?: string;
  /**
  * Name of the ConfigMap with public certificates to add to Java trust store of the Che server. This is often required when adding the OpenShift OAuth provider, which has HTTPS endpoint signed with self-signed cert. The Che server must be aware of its CA cert to be able to request it. This is disabled by default. The Config Map must have 'app.kubernetes.io/part-of=che.eclipse.org' label.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#server_trust_store_config_map_name DataK8SOrgEclipseCheCheClusterV1Manifest#server_trust_store_config_map_name}
  */
  readonly serverTrustStoreConfigMapName?: string;
  /**
  * The labels that need to be present in the ConfigMaps representing the gateway configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#single_host_gateway_config_map_labels DataK8SOrgEclipseCheCheClusterV1Manifest#single_host_gateway_config_map_labels}
  */
  readonly singleHostGatewayConfigMapLabels?: { [key: string]: string };
  /**
  * The image used for the gateway sidecar that provides configuration to the gateway. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#single_host_gateway_config_sidecar_image DataK8SOrgEclipseCheCheClusterV1Manifest#single_host_gateway_config_sidecar_image}
  */
  readonly singleHostGatewayConfigSidecarImage?: string;
  /**
  * The image used for the gateway in the single host mode. Omit it or leave it empty to use the default container image provided by the Operator.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#single_host_gateway_image DataK8SOrgEclipseCheCheClusterV1Manifest#single_host_gateway_image}
  */
  readonly singleHostGatewayImage?: string;
  /**
  * Deprecated. Instructs the Operator to deploy Che in TLS mode. This is enabled by default. Disabling TLS sometimes cause malfunction of some Che components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#tls_support DataK8SOrgEclipseCheCheClusterV1Manifest#tls_support}
  */
  readonly tlsSupport?: boolean | cdktf.IResolvable;
  /**
  * Deprecated in favor of 'disableInternalClusterSVCNames'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#use_internal_cluster_svc_names DataK8SOrgEclipseCheCheClusterV1Manifest#use_internal_cluster_svc_names}
  */
  readonly useInternalClusterSvcNames?: boolean | cdktf.IResolvable;
  /**
  * Default components applied to DevWorkspaces. These default components are meant to be used when a Devfile does not contain any components.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#workspace_default_components DataK8SOrgEclipseCheCheClusterV1Manifest#workspace_default_components}
  */
  readonly workspaceDefaultComponents?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents[] | cdktf.IResolvable;
  /**
  * The default editor to workspace create with. It could be a plugin ID or a URI. The plugin ID must have 'publisher/plugin/version'. The URI must start from 'http'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#workspace_default_editor DataK8SOrgEclipseCheCheClusterV1Manifest#workspace_default_editor}
  */
  readonly workspaceDefaultEditor?: string;
  /**
  * Defines Kubernetes default namespace in which user's workspaces are created for a case when a user does not override it. It's possible to use '<username>', '<userid>' and '<workspaceid>' placeholders, such as che-workspace-<username>. In that case, a new namespace will be created for each user or workspace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#workspace_namespace_default DataK8SOrgEclipseCheCheClusterV1Manifest#workspace_namespace_default}
  */
  readonly workspaceNamespaceDefault?: string;
  /**
  * The node selector that limits the nodes that can run the workspace pods.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#workspace_pod_node_selector DataK8SOrgEclipseCheCheClusterV1Manifest#workspace_pod_node_selector}
  */
  readonly workspacePodNodeSelector?: { [key: string]: string };
  /**
  * The pod tolerations put on the workspace pods to limit where the workspace pods can run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#workspace_pod_tolerations DataK8SOrgEclipseCheCheClusterV1Manifest#workspace_pod_tolerations}
  */
  readonly workspacePodTolerations?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations[] | cdktf.IResolvable;
  /**
  * Default plug-ins applied to Devworkspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#workspaces_default_plugins DataK8SOrgEclipseCheCheClusterV1Manifest#workspaces_default_plugins}
  */
  readonly workspacesDefaultPlugins?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins[] | cdktf.IResolvable;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    air_gap_container_registry_hostname: cdktf.stringToTerraform(struct!.airGapContainerRegistryHostname),
    air_gap_container_registry_organization: cdktf.stringToTerraform(struct!.airGapContainerRegistryOrganization),
    allow_auto_provision_user_namespace: cdktf.booleanToTerraform(struct!.allowAutoProvisionUserNamespace),
    allow_user_defined_workspace_namespaces: cdktf.booleanToTerraform(struct!.allowUserDefinedWorkspaceNamespaces),
    che_cluster_roles: cdktf.stringToTerraform(struct!.cheClusterRoles),
    che_debug: cdktf.stringToTerraform(struct!.cheDebug),
    che_flavor: cdktf.stringToTerraform(struct!.cheFlavor),
    che_host: cdktf.stringToTerraform(struct!.cheHost),
    che_host_tls_secret: cdktf.stringToTerraform(struct!.cheHostTlsSecret),
    che_image: cdktf.stringToTerraform(struct!.cheImage),
    che_image_pull_policy: cdktf.stringToTerraform(struct!.cheImagePullPolicy),
    che_image_tag: cdktf.stringToTerraform(struct!.cheImageTag),
    che_log_level: cdktf.stringToTerraform(struct!.cheLogLevel),
    che_server_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvToTerraform, false)(struct!.cheServerEnv),
    che_server_ingress: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngressToTerraform(struct!.cheServerIngress),
    che_server_route: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRouteToTerraform(struct!.cheServerRoute),
    che_workspace_cluster_role: cdktf.stringToTerraform(struct!.cheWorkspaceClusterRole),
    custom_che_properties: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.customCheProperties),
    dashboard_cpu_limit: cdktf.stringToTerraform(struct!.dashboardCpuLimit),
    dashboard_cpu_request: cdktf.stringToTerraform(struct!.dashboardCpuRequest),
    dashboard_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvToTerraform, false)(struct!.dashboardEnv),
    dashboard_image: cdktf.stringToTerraform(struct!.dashboardImage),
    dashboard_image_pull_policy: cdktf.stringToTerraform(struct!.dashboardImagePullPolicy),
    dashboard_ingress: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngressToTerraform(struct!.dashboardIngress),
    dashboard_memory_limit: cdktf.stringToTerraform(struct!.dashboardMemoryLimit),
    dashboard_memory_request: cdktf.stringToTerraform(struct!.dashboardMemoryRequest),
    dashboard_route: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRouteToTerraform(struct!.dashboardRoute),
    devfile_registry_cpu_limit: cdktf.stringToTerraform(struct!.devfileRegistryCpuLimit),
    devfile_registry_cpu_request: cdktf.stringToTerraform(struct!.devfileRegistryCpuRequest),
    devfile_registry_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvToTerraform, false)(struct!.devfileRegistryEnv),
    devfile_registry_image: cdktf.stringToTerraform(struct!.devfileRegistryImage),
    devfile_registry_ingress: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngressToTerraform(struct!.devfileRegistryIngress),
    devfile_registry_memory_limit: cdktf.stringToTerraform(struct!.devfileRegistryMemoryLimit),
    devfile_registry_memory_request: cdktf.stringToTerraform(struct!.devfileRegistryMemoryRequest),
    devfile_registry_pull_policy: cdktf.stringToTerraform(struct!.devfileRegistryPullPolicy),
    devfile_registry_route: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRouteToTerraform(struct!.devfileRegistryRoute),
    devfile_registry_url: cdktf.stringToTerraform(struct!.devfileRegistryUrl),
    disable_internal_cluster_svc_names: cdktf.booleanToTerraform(struct!.disableInternalClusterSvcNames),
    external_devfile_registries: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesToTerraform, false)(struct!.externalDevfileRegistries),
    external_devfile_registry: cdktf.booleanToTerraform(struct!.externalDevfileRegistry),
    external_plugin_registry: cdktf.booleanToTerraform(struct!.externalPluginRegistry),
    git_self_signed_cert: cdktf.booleanToTerraform(struct!.gitSelfSignedCert),
    non_proxy_hosts: cdktf.stringToTerraform(struct!.nonProxyHosts),
    open_vsx_registry_url: cdktf.stringToTerraform(struct!.openVsxRegistryUrl),
    plugin_registry_cpu_limit: cdktf.stringToTerraform(struct!.pluginRegistryCpuLimit),
    plugin_registry_cpu_request: cdktf.stringToTerraform(struct!.pluginRegistryCpuRequest),
    plugin_registry_env: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvToTerraform, false)(struct!.pluginRegistryEnv),
    plugin_registry_image: cdktf.stringToTerraform(struct!.pluginRegistryImage),
    plugin_registry_ingress: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngressToTerraform(struct!.pluginRegistryIngress),
    plugin_registry_memory_limit: cdktf.stringToTerraform(struct!.pluginRegistryMemoryLimit),
    plugin_registry_memory_request: cdktf.stringToTerraform(struct!.pluginRegistryMemoryRequest),
    plugin_registry_pull_policy: cdktf.stringToTerraform(struct!.pluginRegistryPullPolicy),
    plugin_registry_route: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRouteToTerraform(struct!.pluginRegistryRoute),
    plugin_registry_url: cdktf.stringToTerraform(struct!.pluginRegistryUrl),
    proxy_password: cdktf.stringToTerraform(struct!.proxyPassword),
    proxy_port: cdktf.stringToTerraform(struct!.proxyPort),
    proxy_secret: cdktf.stringToTerraform(struct!.proxySecret),
    proxy_url: cdktf.stringToTerraform(struct!.proxyUrl),
    proxy_user: cdktf.stringToTerraform(struct!.proxyUser),
    self_signed_cert: cdktf.booleanToTerraform(struct!.selfSignedCert),
    server_cpu_limit: cdktf.stringToTerraform(struct!.serverCpuLimit),
    server_cpu_request: cdktf.stringToTerraform(struct!.serverCpuRequest),
    server_exposure_strategy: cdktf.stringToTerraform(struct!.serverExposureStrategy),
    server_memory_limit: cdktf.stringToTerraform(struct!.serverMemoryLimit),
    server_memory_request: cdktf.stringToTerraform(struct!.serverMemoryRequest),
    server_trust_store_config_map_name: cdktf.stringToTerraform(struct!.serverTrustStoreConfigMapName),
    single_host_gateway_config_map_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.singleHostGatewayConfigMapLabels),
    single_host_gateway_config_sidecar_image: cdktf.stringToTerraform(struct!.singleHostGatewayConfigSidecarImage),
    single_host_gateway_image: cdktf.stringToTerraform(struct!.singleHostGatewayImage),
    tls_support: cdktf.booleanToTerraform(struct!.tlsSupport),
    use_internal_cluster_svc_names: cdktf.booleanToTerraform(struct!.useInternalClusterSvcNames),
    workspace_default_components: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsToTerraform, false)(struct!.workspaceDefaultComponents),
    workspace_default_editor: cdktf.stringToTerraform(struct!.workspaceDefaultEditor),
    workspace_namespace_default: cdktf.stringToTerraform(struct!.workspaceNamespaceDefault),
    workspace_pod_node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.workspacePodNodeSelector),
    workspace_pod_tolerations: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsToTerraform, false)(struct!.workspacePodTolerations),
    workspaces_default_plugins: cdktf.listMapper(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsToTerraform, false)(struct!.workspacesDefaultPlugins),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    air_gap_container_registry_hostname: {
      value: cdktf.stringToHclTerraform(struct!.airGapContainerRegistryHostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    air_gap_container_registry_organization: {
      value: cdktf.stringToHclTerraform(struct!.airGapContainerRegistryOrganization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    allow_auto_provision_user_namespace: {
      value: cdktf.booleanToHclTerraform(struct!.allowAutoProvisionUserNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_user_defined_workspace_namespaces: {
      value: cdktf.booleanToHclTerraform(struct!.allowUserDefinedWorkspaceNamespaces),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    che_cluster_roles: {
      value: cdktf.stringToHclTerraform(struct!.cheClusterRoles),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_debug: {
      value: cdktf.stringToHclTerraform(struct!.cheDebug),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_flavor: {
      value: cdktf.stringToHclTerraform(struct!.cheFlavor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_host: {
      value: cdktf.stringToHclTerraform(struct!.cheHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_host_tls_secret: {
      value: cdktf.stringToHclTerraform(struct!.cheHostTlsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_image: {
      value: cdktf.stringToHclTerraform(struct!.cheImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.cheImagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_image_tag: {
      value: cdktf.stringToHclTerraform(struct!.cheImageTag),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_log_level: {
      value: cdktf.stringToHclTerraform(struct!.cheLogLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    che_server_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvToHclTerraform, false)(struct!.cheServerEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvList",
    },
    che_server_ingress: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngressToHclTerraform(struct!.cheServerIngress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress",
    },
    che_server_route: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRouteToHclTerraform(struct!.cheServerRoute),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute",
    },
    che_workspace_cluster_role: {
      value: cdktf.stringToHclTerraform(struct!.cheWorkspaceClusterRole),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_che_properties: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.customCheProperties),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    dashboard_cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.dashboardCpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dashboard_cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.dashboardCpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dashboard_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvToHclTerraform, false)(struct!.dashboardEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvList",
    },
    dashboard_image: {
      value: cdktf.stringToHclTerraform(struct!.dashboardImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dashboard_image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.dashboardImagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dashboard_ingress: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngressToHclTerraform(struct!.dashboardIngress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress",
    },
    dashboard_memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.dashboardMemoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dashboard_memory_request: {
      value: cdktf.stringToHclTerraform(struct!.dashboardMemoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dashboard_route: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRouteToHclTerraform(struct!.dashboardRoute),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute",
    },
    devfile_registry_cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.devfileRegistryCpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry_cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.devfileRegistryCpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvToHclTerraform, false)(struct!.devfileRegistryEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvList",
    },
    devfile_registry_image: {
      value: cdktf.stringToHclTerraform(struct!.devfileRegistryImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry_ingress: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngressToHclTerraform(struct!.devfileRegistryIngress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress",
    },
    devfile_registry_memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.devfileRegistryMemoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry_memory_request: {
      value: cdktf.stringToHclTerraform(struct!.devfileRegistryMemoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.devfileRegistryPullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    devfile_registry_route: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRouteToHclTerraform(struct!.devfileRegistryRoute),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute",
    },
    devfile_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.devfileRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_internal_cluster_svc_names: {
      value: cdktf.booleanToHclTerraform(struct!.disableInternalClusterSvcNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    external_devfile_registries: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesToHclTerraform, false)(struct!.externalDevfileRegistries),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesList",
    },
    external_devfile_registry: {
      value: cdktf.booleanToHclTerraform(struct!.externalDevfileRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    external_plugin_registry: {
      value: cdktf.booleanToHclTerraform(struct!.externalPluginRegistry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    git_self_signed_cert: {
      value: cdktf.booleanToHclTerraform(struct!.gitSelfSignedCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    non_proxy_hosts: {
      value: cdktf.stringToHclTerraform(struct!.nonProxyHosts),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    open_vsx_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.openVsxRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugin_registry_cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.pluginRegistryCpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugin_registry_cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.pluginRegistryCpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugin_registry_env: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvToHclTerraform, false)(struct!.pluginRegistryEnv),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvList",
    },
    plugin_registry_image: {
      value: cdktf.stringToHclTerraform(struct!.pluginRegistryImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugin_registry_ingress: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngressToHclTerraform(struct!.pluginRegistryIngress),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress",
    },
    plugin_registry_memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.pluginRegistryMemoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugin_registry_memory_request: {
      value: cdktf.stringToHclTerraform(struct!.pluginRegistryMemoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugin_registry_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.pluginRegistryPullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    plugin_registry_route: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRouteToHclTerraform(struct!.pluginRegistryRoute),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute",
    },
    plugin_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.pluginRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_password: {
      value: cdktf.stringToHclTerraform(struct!.proxyPassword),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_port: {
      value: cdktf.stringToHclTerraform(struct!.proxyPort),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_secret: {
      value: cdktf.stringToHclTerraform(struct!.proxySecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_url: {
      value: cdktf.stringToHclTerraform(struct!.proxyUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    proxy_user: {
      value: cdktf.stringToHclTerraform(struct!.proxyUser),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    self_signed_cert: {
      value: cdktf.booleanToHclTerraform(struct!.selfSignedCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_cpu_limit: {
      value: cdktf.stringToHclTerraform(struct!.serverCpuLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_cpu_request: {
      value: cdktf.stringToHclTerraform(struct!.serverCpuRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_exposure_strategy: {
      value: cdktf.stringToHclTerraform(struct!.serverExposureStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_memory_limit: {
      value: cdktf.stringToHclTerraform(struct!.serverMemoryLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_memory_request: {
      value: cdktf.stringToHclTerraform(struct!.serverMemoryRequest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_trust_store_config_map_name: {
      value: cdktf.stringToHclTerraform(struct!.serverTrustStoreConfigMapName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    single_host_gateway_config_map_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.singleHostGatewayConfigMapLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    single_host_gateway_config_sidecar_image: {
      value: cdktf.stringToHclTerraform(struct!.singleHostGatewayConfigSidecarImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    single_host_gateway_image: {
      value: cdktf.stringToHclTerraform(struct!.singleHostGatewayImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls_support: {
      value: cdktf.booleanToHclTerraform(struct!.tlsSupport),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_internal_cluster_svc_names: {
      value: cdktf.booleanToHclTerraform(struct!.useInternalClusterSvcNames),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    workspace_default_components: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsToHclTerraform, false)(struct!.workspaceDefaultComponents),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsList",
    },
    workspace_default_editor: {
      value: cdktf.stringToHclTerraform(struct!.workspaceDefaultEditor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workspace_namespace_default: {
      value: cdktf.stringToHclTerraform(struct!.workspaceNamespaceDefault),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workspace_pod_node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.workspacePodNodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    workspace_pod_tolerations: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsToHclTerraform, false)(struct!.workspacePodTolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsList",
    },
    workspaces_default_plugins: {
      value: cdktf.listMapperHcl(dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsToHclTerraform, false)(struct!.workspacesDefaultPlugins),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._airGapContainerRegistryHostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.airGapContainerRegistryHostname = this._airGapContainerRegistryHostname;
    }
    if (this._airGapContainerRegistryOrganization !== undefined) {
      hasAnyValues = true;
      internalValueResult.airGapContainerRegistryOrganization = this._airGapContainerRegistryOrganization;
    }
    if (this._allowAutoProvisionUserNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowAutoProvisionUserNamespace = this._allowAutoProvisionUserNamespace;
    }
    if (this._allowUserDefinedWorkspaceNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowUserDefinedWorkspaceNamespaces = this._allowUserDefinedWorkspaceNamespaces;
    }
    if (this._cheClusterRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheClusterRoles = this._cheClusterRoles;
    }
    if (this._cheDebug !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheDebug = this._cheDebug;
    }
    if (this._cheFlavor !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheFlavor = this._cheFlavor;
    }
    if (this._cheHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheHost = this._cheHost;
    }
    if (this._cheHostTlsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheHostTlsSecret = this._cheHostTlsSecret;
    }
    if (this._cheImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheImage = this._cheImage;
    }
    if (this._cheImagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheImagePullPolicy = this._cheImagePullPolicy;
    }
    if (this._cheImageTag !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheImageTag = this._cheImageTag;
    }
    if (this._cheLogLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheLogLevel = this._cheLogLevel;
    }
    if (this._cheServerEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheServerEnv = this._cheServerEnv?.internalValue;
    }
    if (this._cheServerIngress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheServerIngress = this._cheServerIngress?.internalValue;
    }
    if (this._cheServerRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheServerRoute = this._cheServerRoute?.internalValue;
    }
    if (this._cheWorkspaceClusterRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.cheWorkspaceClusterRole = this._cheWorkspaceClusterRole;
    }
    if (this._customCheProperties !== undefined) {
      hasAnyValues = true;
      internalValueResult.customCheProperties = this._customCheProperties;
    }
    if (this._dashboardCpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardCpuLimit = this._dashboardCpuLimit;
    }
    if (this._dashboardCpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardCpuRequest = this._dashboardCpuRequest;
    }
    if (this._dashboardEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardEnv = this._dashboardEnv?.internalValue;
    }
    if (this._dashboardImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardImage = this._dashboardImage;
    }
    if (this._dashboardImagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardImagePullPolicy = this._dashboardImagePullPolicy;
    }
    if (this._dashboardIngress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardIngress = this._dashboardIngress?.internalValue;
    }
    if (this._dashboardMemoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardMemoryLimit = this._dashboardMemoryLimit;
    }
    if (this._dashboardMemoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardMemoryRequest = this._dashboardMemoryRequest;
    }
    if (this._dashboardRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboardRoute = this._dashboardRoute?.internalValue;
    }
    if (this._devfileRegistryCpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryCpuLimit = this._devfileRegistryCpuLimit;
    }
    if (this._devfileRegistryCpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryCpuRequest = this._devfileRegistryCpuRequest;
    }
    if (this._devfileRegistryEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryEnv = this._devfileRegistryEnv?.internalValue;
    }
    if (this._devfileRegistryImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryImage = this._devfileRegistryImage;
    }
    if (this._devfileRegistryIngress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryIngress = this._devfileRegistryIngress?.internalValue;
    }
    if (this._devfileRegistryMemoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryMemoryLimit = this._devfileRegistryMemoryLimit;
    }
    if (this._devfileRegistryMemoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryMemoryRequest = this._devfileRegistryMemoryRequest;
    }
    if (this._devfileRegistryPullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryPullPolicy = this._devfileRegistryPullPolicy;
    }
    if (this._devfileRegistryRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryRoute = this._devfileRegistryRoute?.internalValue;
    }
    if (this._devfileRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.devfileRegistryUrl = this._devfileRegistryUrl;
    }
    if (this._disableInternalClusterSvcNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableInternalClusterSvcNames = this._disableInternalClusterSvcNames;
    }
    if (this._externalDevfileRegistries?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalDevfileRegistries = this._externalDevfileRegistries?.internalValue;
    }
    if (this._externalDevfileRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalDevfileRegistry = this._externalDevfileRegistry;
    }
    if (this._externalPluginRegistry !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalPluginRegistry = this._externalPluginRegistry;
    }
    if (this._gitSelfSignedCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitSelfSignedCert = this._gitSelfSignedCert;
    }
    if (this._nonProxyHosts !== undefined) {
      hasAnyValues = true;
      internalValueResult.nonProxyHosts = this._nonProxyHosts;
    }
    if (this._openVsxRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.openVsxRegistryUrl = this._openVsxRegistryUrl;
    }
    if (this._pluginRegistryCpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryCpuLimit = this._pluginRegistryCpuLimit;
    }
    if (this._pluginRegistryCpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryCpuRequest = this._pluginRegistryCpuRequest;
    }
    if (this._pluginRegistryEnv?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryEnv = this._pluginRegistryEnv?.internalValue;
    }
    if (this._pluginRegistryImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryImage = this._pluginRegistryImage;
    }
    if (this._pluginRegistryIngress?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryIngress = this._pluginRegistryIngress?.internalValue;
    }
    if (this._pluginRegistryMemoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryMemoryLimit = this._pluginRegistryMemoryLimit;
    }
    if (this._pluginRegistryMemoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryMemoryRequest = this._pluginRegistryMemoryRequest;
    }
    if (this._pluginRegistryPullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryPullPolicy = this._pluginRegistryPullPolicy;
    }
    if (this._pluginRegistryRoute?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryRoute = this._pluginRegistryRoute?.internalValue;
    }
    if (this._pluginRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.pluginRegistryUrl = this._pluginRegistryUrl;
    }
    if (this._proxyPassword !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyPassword = this._proxyPassword;
    }
    if (this._proxyPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyPort = this._proxyPort;
    }
    if (this._proxySecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxySecret = this._proxySecret;
    }
    if (this._proxyUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUrl = this._proxyUrl;
    }
    if (this._proxyUser !== undefined) {
      hasAnyValues = true;
      internalValueResult.proxyUser = this._proxyUser;
    }
    if (this._selfSignedCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.selfSignedCert = this._selfSignedCert;
    }
    if (this._serverCpuLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverCpuLimit = this._serverCpuLimit;
    }
    if (this._serverCpuRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverCpuRequest = this._serverCpuRequest;
    }
    if (this._serverExposureStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverExposureStrategy = this._serverExposureStrategy;
    }
    if (this._serverMemoryLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverMemoryLimit = this._serverMemoryLimit;
    }
    if (this._serverMemoryRequest !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverMemoryRequest = this._serverMemoryRequest;
    }
    if (this._serverTrustStoreConfigMapName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverTrustStoreConfigMapName = this._serverTrustStoreConfigMapName;
    }
    if (this._singleHostGatewayConfigMapLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleHostGatewayConfigMapLabels = this._singleHostGatewayConfigMapLabels;
    }
    if (this._singleHostGatewayConfigSidecarImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleHostGatewayConfigSidecarImage = this._singleHostGatewayConfigSidecarImage;
    }
    if (this._singleHostGatewayImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleHostGatewayImage = this._singleHostGatewayImage;
    }
    if (this._tlsSupport !== undefined) {
      hasAnyValues = true;
      internalValueResult.tlsSupport = this._tlsSupport;
    }
    if (this._useInternalClusterSvcNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.useInternalClusterSvcNames = this._useInternalClusterSvcNames;
    }
    if (this._workspaceDefaultComponents?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspaceDefaultComponents = this._workspaceDefaultComponents?.internalValue;
    }
    if (this._workspaceDefaultEditor !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspaceDefaultEditor = this._workspaceDefaultEditor;
    }
    if (this._workspaceNamespaceDefault !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspaceNamespaceDefault = this._workspaceNamespaceDefault;
    }
    if (this._workspacePodNodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspacePodNodeSelector = this._workspacePodNodeSelector;
    }
    if (this._workspacePodTolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspacePodTolerations = this._workspacePodTolerations?.internalValue;
    }
    if (this._workspacesDefaultPlugins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspacesDefaultPlugins = this._workspacesDefaultPlugins?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._airGapContainerRegistryHostname = undefined;
      this._airGapContainerRegistryOrganization = undefined;
      this._allowAutoProvisionUserNamespace = undefined;
      this._allowUserDefinedWorkspaceNamespaces = undefined;
      this._cheClusterRoles = undefined;
      this._cheDebug = undefined;
      this._cheFlavor = undefined;
      this._cheHost = undefined;
      this._cheHostTlsSecret = undefined;
      this._cheImage = undefined;
      this._cheImagePullPolicy = undefined;
      this._cheImageTag = undefined;
      this._cheLogLevel = undefined;
      this._cheServerEnv.internalValue = undefined;
      this._cheServerIngress.internalValue = undefined;
      this._cheServerRoute.internalValue = undefined;
      this._cheWorkspaceClusterRole = undefined;
      this._customCheProperties = undefined;
      this._dashboardCpuLimit = undefined;
      this._dashboardCpuRequest = undefined;
      this._dashboardEnv.internalValue = undefined;
      this._dashboardImage = undefined;
      this._dashboardImagePullPolicy = undefined;
      this._dashboardIngress.internalValue = undefined;
      this._dashboardMemoryLimit = undefined;
      this._dashboardMemoryRequest = undefined;
      this._dashboardRoute.internalValue = undefined;
      this._devfileRegistryCpuLimit = undefined;
      this._devfileRegistryCpuRequest = undefined;
      this._devfileRegistryEnv.internalValue = undefined;
      this._devfileRegistryImage = undefined;
      this._devfileRegistryIngress.internalValue = undefined;
      this._devfileRegistryMemoryLimit = undefined;
      this._devfileRegistryMemoryRequest = undefined;
      this._devfileRegistryPullPolicy = undefined;
      this._devfileRegistryRoute.internalValue = undefined;
      this._devfileRegistryUrl = undefined;
      this._disableInternalClusterSvcNames = undefined;
      this._externalDevfileRegistries.internalValue = undefined;
      this._externalDevfileRegistry = undefined;
      this._externalPluginRegistry = undefined;
      this._gitSelfSignedCert = undefined;
      this._nonProxyHosts = undefined;
      this._openVsxRegistryUrl = undefined;
      this._pluginRegistryCpuLimit = undefined;
      this._pluginRegistryCpuRequest = undefined;
      this._pluginRegistryEnv.internalValue = undefined;
      this._pluginRegistryImage = undefined;
      this._pluginRegistryIngress.internalValue = undefined;
      this._pluginRegistryMemoryLimit = undefined;
      this._pluginRegistryMemoryRequest = undefined;
      this._pluginRegistryPullPolicy = undefined;
      this._pluginRegistryRoute.internalValue = undefined;
      this._pluginRegistryUrl = undefined;
      this._proxyPassword = undefined;
      this._proxyPort = undefined;
      this._proxySecret = undefined;
      this._proxyUrl = undefined;
      this._proxyUser = undefined;
      this._selfSignedCert = undefined;
      this._serverCpuLimit = undefined;
      this._serverCpuRequest = undefined;
      this._serverExposureStrategy = undefined;
      this._serverMemoryLimit = undefined;
      this._serverMemoryRequest = undefined;
      this._serverTrustStoreConfigMapName = undefined;
      this._singleHostGatewayConfigMapLabels = undefined;
      this._singleHostGatewayConfigSidecarImage = undefined;
      this._singleHostGatewayImage = undefined;
      this._tlsSupport = undefined;
      this._useInternalClusterSvcNames = undefined;
      this._workspaceDefaultComponents.internalValue = undefined;
      this._workspaceDefaultEditor = undefined;
      this._workspaceNamespaceDefault = undefined;
      this._workspacePodNodeSelector = undefined;
      this._workspacePodTolerations.internalValue = undefined;
      this._workspacesDefaultPlugins.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._airGapContainerRegistryHostname = value.airGapContainerRegistryHostname;
      this._airGapContainerRegistryOrganization = value.airGapContainerRegistryOrganization;
      this._allowAutoProvisionUserNamespace = value.allowAutoProvisionUserNamespace;
      this._allowUserDefinedWorkspaceNamespaces = value.allowUserDefinedWorkspaceNamespaces;
      this._cheClusterRoles = value.cheClusterRoles;
      this._cheDebug = value.cheDebug;
      this._cheFlavor = value.cheFlavor;
      this._cheHost = value.cheHost;
      this._cheHostTlsSecret = value.cheHostTlsSecret;
      this._cheImage = value.cheImage;
      this._cheImagePullPolicy = value.cheImagePullPolicy;
      this._cheImageTag = value.cheImageTag;
      this._cheLogLevel = value.cheLogLevel;
      this._cheServerEnv.internalValue = value.cheServerEnv;
      this._cheServerIngress.internalValue = value.cheServerIngress;
      this._cheServerRoute.internalValue = value.cheServerRoute;
      this._cheWorkspaceClusterRole = value.cheWorkspaceClusterRole;
      this._customCheProperties = value.customCheProperties;
      this._dashboardCpuLimit = value.dashboardCpuLimit;
      this._dashboardCpuRequest = value.dashboardCpuRequest;
      this._dashboardEnv.internalValue = value.dashboardEnv;
      this._dashboardImage = value.dashboardImage;
      this._dashboardImagePullPolicy = value.dashboardImagePullPolicy;
      this._dashboardIngress.internalValue = value.dashboardIngress;
      this._dashboardMemoryLimit = value.dashboardMemoryLimit;
      this._dashboardMemoryRequest = value.dashboardMemoryRequest;
      this._dashboardRoute.internalValue = value.dashboardRoute;
      this._devfileRegistryCpuLimit = value.devfileRegistryCpuLimit;
      this._devfileRegistryCpuRequest = value.devfileRegistryCpuRequest;
      this._devfileRegistryEnv.internalValue = value.devfileRegistryEnv;
      this._devfileRegistryImage = value.devfileRegistryImage;
      this._devfileRegistryIngress.internalValue = value.devfileRegistryIngress;
      this._devfileRegistryMemoryLimit = value.devfileRegistryMemoryLimit;
      this._devfileRegistryMemoryRequest = value.devfileRegistryMemoryRequest;
      this._devfileRegistryPullPolicy = value.devfileRegistryPullPolicy;
      this._devfileRegistryRoute.internalValue = value.devfileRegistryRoute;
      this._devfileRegistryUrl = value.devfileRegistryUrl;
      this._disableInternalClusterSvcNames = value.disableInternalClusterSvcNames;
      this._externalDevfileRegistries.internalValue = value.externalDevfileRegistries;
      this._externalDevfileRegistry = value.externalDevfileRegistry;
      this._externalPluginRegistry = value.externalPluginRegistry;
      this._gitSelfSignedCert = value.gitSelfSignedCert;
      this._nonProxyHosts = value.nonProxyHosts;
      this._openVsxRegistryUrl = value.openVsxRegistryUrl;
      this._pluginRegistryCpuLimit = value.pluginRegistryCpuLimit;
      this._pluginRegistryCpuRequest = value.pluginRegistryCpuRequest;
      this._pluginRegistryEnv.internalValue = value.pluginRegistryEnv;
      this._pluginRegistryImage = value.pluginRegistryImage;
      this._pluginRegistryIngress.internalValue = value.pluginRegistryIngress;
      this._pluginRegistryMemoryLimit = value.pluginRegistryMemoryLimit;
      this._pluginRegistryMemoryRequest = value.pluginRegistryMemoryRequest;
      this._pluginRegistryPullPolicy = value.pluginRegistryPullPolicy;
      this._pluginRegistryRoute.internalValue = value.pluginRegistryRoute;
      this._pluginRegistryUrl = value.pluginRegistryUrl;
      this._proxyPassword = value.proxyPassword;
      this._proxyPort = value.proxyPort;
      this._proxySecret = value.proxySecret;
      this._proxyUrl = value.proxyUrl;
      this._proxyUser = value.proxyUser;
      this._selfSignedCert = value.selfSignedCert;
      this._serverCpuLimit = value.serverCpuLimit;
      this._serverCpuRequest = value.serverCpuRequest;
      this._serverExposureStrategy = value.serverExposureStrategy;
      this._serverMemoryLimit = value.serverMemoryLimit;
      this._serverMemoryRequest = value.serverMemoryRequest;
      this._serverTrustStoreConfigMapName = value.serverTrustStoreConfigMapName;
      this._singleHostGatewayConfigMapLabels = value.singleHostGatewayConfigMapLabels;
      this._singleHostGatewayConfigSidecarImage = value.singleHostGatewayConfigSidecarImage;
      this._singleHostGatewayImage = value.singleHostGatewayImage;
      this._tlsSupport = value.tlsSupport;
      this._useInternalClusterSvcNames = value.useInternalClusterSvcNames;
      this._workspaceDefaultComponents.internalValue = value.workspaceDefaultComponents;
      this._workspaceDefaultEditor = value.workspaceDefaultEditor;
      this._workspaceNamespaceDefault = value.workspaceNamespaceDefault;
      this._workspacePodNodeSelector = value.workspacePodNodeSelector;
      this._workspacePodTolerations.internalValue = value.workspacePodTolerations;
      this._workspacesDefaultPlugins.internalValue = value.workspacesDefaultPlugins;
    }
  }

  // air_gap_container_registry_hostname - computed: false, optional: true, required: false
  private _airGapContainerRegistryHostname?: string; 
  public get airGapContainerRegistryHostname() {
    return this.getStringAttribute('air_gap_container_registry_hostname');
  }
  public set airGapContainerRegistryHostname(value: string) {
    this._airGapContainerRegistryHostname = value;
  }
  public resetAirGapContainerRegistryHostname() {
    this._airGapContainerRegistryHostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get airGapContainerRegistryHostnameInput() {
    return this._airGapContainerRegistryHostname;
  }

  // air_gap_container_registry_organization - computed: false, optional: true, required: false
  private _airGapContainerRegistryOrganization?: string; 
  public get airGapContainerRegistryOrganization() {
    return this.getStringAttribute('air_gap_container_registry_organization');
  }
  public set airGapContainerRegistryOrganization(value: string) {
    this._airGapContainerRegistryOrganization = value;
  }
  public resetAirGapContainerRegistryOrganization() {
    this._airGapContainerRegistryOrganization = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get airGapContainerRegistryOrganizationInput() {
    return this._airGapContainerRegistryOrganization;
  }

  // allow_auto_provision_user_namespace - computed: false, optional: true, required: false
  private _allowAutoProvisionUserNamespace?: boolean | cdktf.IResolvable; 
  public get allowAutoProvisionUserNamespace() {
    return this.getBooleanAttribute('allow_auto_provision_user_namespace');
  }
  public set allowAutoProvisionUserNamespace(value: boolean | cdktf.IResolvable) {
    this._allowAutoProvisionUserNamespace = value;
  }
  public resetAllowAutoProvisionUserNamespace() {
    this._allowAutoProvisionUserNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowAutoProvisionUserNamespaceInput() {
    return this._allowAutoProvisionUserNamespace;
  }

  // allow_user_defined_workspace_namespaces - computed: false, optional: true, required: false
  private _allowUserDefinedWorkspaceNamespaces?: boolean | cdktf.IResolvable; 
  public get allowUserDefinedWorkspaceNamespaces() {
    return this.getBooleanAttribute('allow_user_defined_workspace_namespaces');
  }
  public set allowUserDefinedWorkspaceNamespaces(value: boolean | cdktf.IResolvable) {
    this._allowUserDefinedWorkspaceNamespaces = value;
  }
  public resetAllowUserDefinedWorkspaceNamespaces() {
    this._allowUserDefinedWorkspaceNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowUserDefinedWorkspaceNamespacesInput() {
    return this._allowUserDefinedWorkspaceNamespaces;
  }

  // che_cluster_roles - computed: false, optional: true, required: false
  private _cheClusterRoles?: string; 
  public get cheClusterRoles() {
    return this.getStringAttribute('che_cluster_roles');
  }
  public set cheClusterRoles(value: string) {
    this._cheClusterRoles = value;
  }
  public resetCheClusterRoles() {
    this._cheClusterRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheClusterRolesInput() {
    return this._cheClusterRoles;
  }

  // che_debug - computed: false, optional: true, required: false
  private _cheDebug?: string; 
  public get cheDebug() {
    return this.getStringAttribute('che_debug');
  }
  public set cheDebug(value: string) {
    this._cheDebug = value;
  }
  public resetCheDebug() {
    this._cheDebug = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheDebugInput() {
    return this._cheDebug;
  }

  // che_flavor - computed: false, optional: true, required: false
  private _cheFlavor?: string; 
  public get cheFlavor() {
    return this.getStringAttribute('che_flavor');
  }
  public set cheFlavor(value: string) {
    this._cheFlavor = value;
  }
  public resetCheFlavor() {
    this._cheFlavor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheFlavorInput() {
    return this._cheFlavor;
  }

  // che_host - computed: false, optional: true, required: false
  private _cheHost?: string; 
  public get cheHost() {
    return this.getStringAttribute('che_host');
  }
  public set cheHost(value: string) {
    this._cheHost = value;
  }
  public resetCheHost() {
    this._cheHost = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheHostInput() {
    return this._cheHost;
  }

  // che_host_tls_secret - computed: false, optional: true, required: false
  private _cheHostTlsSecret?: string; 
  public get cheHostTlsSecret() {
    return this.getStringAttribute('che_host_tls_secret');
  }
  public set cheHostTlsSecret(value: string) {
    this._cheHostTlsSecret = value;
  }
  public resetCheHostTlsSecret() {
    this._cheHostTlsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheHostTlsSecretInput() {
    return this._cheHostTlsSecret;
  }

  // che_image - computed: false, optional: true, required: false
  private _cheImage?: string; 
  public get cheImage() {
    return this.getStringAttribute('che_image');
  }
  public set cheImage(value: string) {
    this._cheImage = value;
  }
  public resetCheImage() {
    this._cheImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheImageInput() {
    return this._cheImage;
  }

  // che_image_pull_policy - computed: false, optional: true, required: false
  private _cheImagePullPolicy?: string; 
  public get cheImagePullPolicy() {
    return this.getStringAttribute('che_image_pull_policy');
  }
  public set cheImagePullPolicy(value: string) {
    this._cheImagePullPolicy = value;
  }
  public resetCheImagePullPolicy() {
    this._cheImagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheImagePullPolicyInput() {
    return this._cheImagePullPolicy;
  }

  // che_image_tag - computed: false, optional: true, required: false
  private _cheImageTag?: string; 
  public get cheImageTag() {
    return this.getStringAttribute('che_image_tag');
  }
  public set cheImageTag(value: string) {
    this._cheImageTag = value;
  }
  public resetCheImageTag() {
    this._cheImageTag = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheImageTagInput() {
    return this._cheImageTag;
  }

  // che_log_level - computed: false, optional: true, required: false
  private _cheLogLevel?: string; 
  public get cheLogLevel() {
    return this.getStringAttribute('che_log_level');
  }
  public set cheLogLevel(value: string) {
    this._cheLogLevel = value;
  }
  public resetCheLogLevel() {
    this._cheLogLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheLogLevelInput() {
    return this._cheLogLevel;
  }

  // che_server_env - computed: false, optional: true, required: false
  private _cheServerEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnvList(this, "che_server_env", false);
  public get cheServerEnv() {
    return this._cheServerEnv;
  }
  public putCheServerEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerEnv[] | cdktf.IResolvable) {
    this._cheServerEnv.internalValue = value;
  }
  public resetCheServerEnv() {
    this._cheServerEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheServerEnvInput() {
    return this._cheServerEnv.internalValue;
  }

  // che_server_ingress - computed: false, optional: true, required: false
  private _cheServerIngress = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngressOutputReference(this, "che_server_ingress");
  public get cheServerIngress() {
    return this._cheServerIngress;
  }
  public putCheServerIngress(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerIngress) {
    this._cheServerIngress.internalValue = value;
  }
  public resetCheServerIngress() {
    this._cheServerIngress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheServerIngressInput() {
    return this._cheServerIngress.internalValue;
  }

  // che_server_route - computed: false, optional: true, required: false
  private _cheServerRoute = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRouteOutputReference(this, "che_server_route");
  public get cheServerRoute() {
    return this._cheServerRoute;
  }
  public putCheServerRoute(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerCheServerRoute) {
    this._cheServerRoute.internalValue = value;
  }
  public resetCheServerRoute() {
    this._cheServerRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheServerRouteInput() {
    return this._cheServerRoute.internalValue;
  }

  // che_workspace_cluster_role - computed: false, optional: true, required: false
  private _cheWorkspaceClusterRole?: string; 
  public get cheWorkspaceClusterRole() {
    return this.getStringAttribute('che_workspace_cluster_role');
  }
  public set cheWorkspaceClusterRole(value: string) {
    this._cheWorkspaceClusterRole = value;
  }
  public resetCheWorkspaceClusterRole() {
    this._cheWorkspaceClusterRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cheWorkspaceClusterRoleInput() {
    return this._cheWorkspaceClusterRole;
  }

  // custom_che_properties - computed: false, optional: true, required: false
  private _customCheProperties?: { [key: string]: string }; 
  public get customCheProperties() {
    return this.getStringMapAttribute('custom_che_properties');
  }
  public set customCheProperties(value: { [key: string]: string }) {
    this._customCheProperties = value;
  }
  public resetCustomCheProperties() {
    this._customCheProperties = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customChePropertiesInput() {
    return this._customCheProperties;
  }

  // dashboard_cpu_limit - computed: false, optional: true, required: false
  private _dashboardCpuLimit?: string; 
  public get dashboardCpuLimit() {
    return this.getStringAttribute('dashboard_cpu_limit');
  }
  public set dashboardCpuLimit(value: string) {
    this._dashboardCpuLimit = value;
  }
  public resetDashboardCpuLimit() {
    this._dashboardCpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardCpuLimitInput() {
    return this._dashboardCpuLimit;
  }

  // dashboard_cpu_request - computed: false, optional: true, required: false
  private _dashboardCpuRequest?: string; 
  public get dashboardCpuRequest() {
    return this.getStringAttribute('dashboard_cpu_request');
  }
  public set dashboardCpuRequest(value: string) {
    this._dashboardCpuRequest = value;
  }
  public resetDashboardCpuRequest() {
    this._dashboardCpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardCpuRequestInput() {
    return this._dashboardCpuRequest;
  }

  // dashboard_env - computed: false, optional: true, required: false
  private _dashboardEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnvList(this, "dashboard_env", false);
  public get dashboardEnv() {
    return this._dashboardEnv;
  }
  public putDashboardEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardEnv[] | cdktf.IResolvable) {
    this._dashboardEnv.internalValue = value;
  }
  public resetDashboardEnv() {
    this._dashboardEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardEnvInput() {
    return this._dashboardEnv.internalValue;
  }

  // dashboard_image - computed: false, optional: true, required: false
  private _dashboardImage?: string; 
  public get dashboardImage() {
    return this.getStringAttribute('dashboard_image');
  }
  public set dashboardImage(value: string) {
    this._dashboardImage = value;
  }
  public resetDashboardImage() {
    this._dashboardImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardImageInput() {
    return this._dashboardImage;
  }

  // dashboard_image_pull_policy - computed: false, optional: true, required: false
  private _dashboardImagePullPolicy?: string; 
  public get dashboardImagePullPolicy() {
    return this.getStringAttribute('dashboard_image_pull_policy');
  }
  public set dashboardImagePullPolicy(value: string) {
    this._dashboardImagePullPolicy = value;
  }
  public resetDashboardImagePullPolicy() {
    this._dashboardImagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardImagePullPolicyInput() {
    return this._dashboardImagePullPolicy;
  }

  // dashboard_ingress - computed: false, optional: true, required: false
  private _dashboardIngress = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngressOutputReference(this, "dashboard_ingress");
  public get dashboardIngress() {
    return this._dashboardIngress;
  }
  public putDashboardIngress(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardIngress) {
    this._dashboardIngress.internalValue = value;
  }
  public resetDashboardIngress() {
    this._dashboardIngress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardIngressInput() {
    return this._dashboardIngress.internalValue;
  }

  // dashboard_memory_limit - computed: false, optional: true, required: false
  private _dashboardMemoryLimit?: string; 
  public get dashboardMemoryLimit() {
    return this.getStringAttribute('dashboard_memory_limit');
  }
  public set dashboardMemoryLimit(value: string) {
    this._dashboardMemoryLimit = value;
  }
  public resetDashboardMemoryLimit() {
    this._dashboardMemoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardMemoryLimitInput() {
    return this._dashboardMemoryLimit;
  }

  // dashboard_memory_request - computed: false, optional: true, required: false
  private _dashboardMemoryRequest?: string; 
  public get dashboardMemoryRequest() {
    return this.getStringAttribute('dashboard_memory_request');
  }
  public set dashboardMemoryRequest(value: string) {
    this._dashboardMemoryRequest = value;
  }
  public resetDashboardMemoryRequest() {
    this._dashboardMemoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardMemoryRequestInput() {
    return this._dashboardMemoryRequest;
  }

  // dashboard_route - computed: false, optional: true, required: false
  private _dashboardRoute = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRouteOutputReference(this, "dashboard_route");
  public get dashboardRoute() {
    return this._dashboardRoute;
  }
  public putDashboardRoute(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDashboardRoute) {
    this._dashboardRoute.internalValue = value;
  }
  public resetDashboardRoute() {
    this._dashboardRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardRouteInput() {
    return this._dashboardRoute.internalValue;
  }

  // devfile_registry_cpu_limit - computed: false, optional: true, required: false
  private _devfileRegistryCpuLimit?: string; 
  public get devfileRegistryCpuLimit() {
    return this.getStringAttribute('devfile_registry_cpu_limit');
  }
  public set devfileRegistryCpuLimit(value: string) {
    this._devfileRegistryCpuLimit = value;
  }
  public resetDevfileRegistryCpuLimit() {
    this._devfileRegistryCpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryCpuLimitInput() {
    return this._devfileRegistryCpuLimit;
  }

  // devfile_registry_cpu_request - computed: false, optional: true, required: false
  private _devfileRegistryCpuRequest?: string; 
  public get devfileRegistryCpuRequest() {
    return this.getStringAttribute('devfile_registry_cpu_request');
  }
  public set devfileRegistryCpuRequest(value: string) {
    this._devfileRegistryCpuRequest = value;
  }
  public resetDevfileRegistryCpuRequest() {
    this._devfileRegistryCpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryCpuRequestInput() {
    return this._devfileRegistryCpuRequest;
  }

  // devfile_registry_env - computed: false, optional: true, required: false
  private _devfileRegistryEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnvList(this, "devfile_registry_env", false);
  public get devfileRegistryEnv() {
    return this._devfileRegistryEnv;
  }
  public putDevfileRegistryEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryEnv[] | cdktf.IResolvable) {
    this._devfileRegistryEnv.internalValue = value;
  }
  public resetDevfileRegistryEnv() {
    this._devfileRegistryEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryEnvInput() {
    return this._devfileRegistryEnv.internalValue;
  }

  // devfile_registry_image - computed: false, optional: true, required: false
  private _devfileRegistryImage?: string; 
  public get devfileRegistryImage() {
    return this.getStringAttribute('devfile_registry_image');
  }
  public set devfileRegistryImage(value: string) {
    this._devfileRegistryImage = value;
  }
  public resetDevfileRegistryImage() {
    this._devfileRegistryImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryImageInput() {
    return this._devfileRegistryImage;
  }

  // devfile_registry_ingress - computed: false, optional: true, required: false
  private _devfileRegistryIngress = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngressOutputReference(this, "devfile_registry_ingress");
  public get devfileRegistryIngress() {
    return this._devfileRegistryIngress;
  }
  public putDevfileRegistryIngress(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryIngress) {
    this._devfileRegistryIngress.internalValue = value;
  }
  public resetDevfileRegistryIngress() {
    this._devfileRegistryIngress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryIngressInput() {
    return this._devfileRegistryIngress.internalValue;
  }

  // devfile_registry_memory_limit - computed: false, optional: true, required: false
  private _devfileRegistryMemoryLimit?: string; 
  public get devfileRegistryMemoryLimit() {
    return this.getStringAttribute('devfile_registry_memory_limit');
  }
  public set devfileRegistryMemoryLimit(value: string) {
    this._devfileRegistryMemoryLimit = value;
  }
  public resetDevfileRegistryMemoryLimit() {
    this._devfileRegistryMemoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryMemoryLimitInput() {
    return this._devfileRegistryMemoryLimit;
  }

  // devfile_registry_memory_request - computed: false, optional: true, required: false
  private _devfileRegistryMemoryRequest?: string; 
  public get devfileRegistryMemoryRequest() {
    return this.getStringAttribute('devfile_registry_memory_request');
  }
  public set devfileRegistryMemoryRequest(value: string) {
    this._devfileRegistryMemoryRequest = value;
  }
  public resetDevfileRegistryMemoryRequest() {
    this._devfileRegistryMemoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryMemoryRequestInput() {
    return this._devfileRegistryMemoryRequest;
  }

  // devfile_registry_pull_policy - computed: false, optional: true, required: false
  private _devfileRegistryPullPolicy?: string; 
  public get devfileRegistryPullPolicy() {
    return this.getStringAttribute('devfile_registry_pull_policy');
  }
  public set devfileRegistryPullPolicy(value: string) {
    this._devfileRegistryPullPolicy = value;
  }
  public resetDevfileRegistryPullPolicy() {
    this._devfileRegistryPullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryPullPolicyInput() {
    return this._devfileRegistryPullPolicy;
  }

  // devfile_registry_route - computed: false, optional: true, required: false
  private _devfileRegistryRoute = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRouteOutputReference(this, "devfile_registry_route");
  public get devfileRegistryRoute() {
    return this._devfileRegistryRoute;
  }
  public putDevfileRegistryRoute(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerDevfileRegistryRoute) {
    this._devfileRegistryRoute.internalValue = value;
  }
  public resetDevfileRegistryRoute() {
    this._devfileRegistryRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryRouteInput() {
    return this._devfileRegistryRoute.internalValue;
  }

  // devfile_registry_url - computed: false, optional: true, required: false
  private _devfileRegistryUrl?: string; 
  public get devfileRegistryUrl() {
    return this.getStringAttribute('devfile_registry_url');
  }
  public set devfileRegistryUrl(value: string) {
    this._devfileRegistryUrl = value;
  }
  public resetDevfileRegistryUrl() {
    this._devfileRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devfileRegistryUrlInput() {
    return this._devfileRegistryUrl;
  }

  // disable_internal_cluster_svc_names - computed: false, optional: true, required: false
  private _disableInternalClusterSvcNames?: boolean | cdktf.IResolvable; 
  public get disableInternalClusterSvcNames() {
    return this.getBooleanAttribute('disable_internal_cluster_svc_names');
  }
  public set disableInternalClusterSvcNames(value: boolean | cdktf.IResolvable) {
    this._disableInternalClusterSvcNames = value;
  }
  public resetDisableInternalClusterSvcNames() {
    this._disableInternalClusterSvcNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInternalClusterSvcNamesInput() {
    return this._disableInternalClusterSvcNames;
  }

  // external_devfile_registries - computed: false, optional: true, required: false
  private _externalDevfileRegistries = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistriesList(this, "external_devfile_registries", false);
  public get externalDevfileRegistries() {
    return this._externalDevfileRegistries;
  }
  public putExternalDevfileRegistries(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerExternalDevfileRegistries[] | cdktf.IResolvable) {
    this._externalDevfileRegistries.internalValue = value;
  }
  public resetExternalDevfileRegistries() {
    this._externalDevfileRegistries.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalDevfileRegistriesInput() {
    return this._externalDevfileRegistries.internalValue;
  }

  // external_devfile_registry - computed: false, optional: true, required: false
  private _externalDevfileRegistry?: boolean | cdktf.IResolvable; 
  public get externalDevfileRegistry() {
    return this.getBooleanAttribute('external_devfile_registry');
  }
  public set externalDevfileRegistry(value: boolean | cdktf.IResolvable) {
    this._externalDevfileRegistry = value;
  }
  public resetExternalDevfileRegistry() {
    this._externalDevfileRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalDevfileRegistryInput() {
    return this._externalDevfileRegistry;
  }

  // external_plugin_registry - computed: false, optional: true, required: false
  private _externalPluginRegistry?: boolean | cdktf.IResolvable; 
  public get externalPluginRegistry() {
    return this.getBooleanAttribute('external_plugin_registry');
  }
  public set externalPluginRegistry(value: boolean | cdktf.IResolvable) {
    this._externalPluginRegistry = value;
  }
  public resetExternalPluginRegistry() {
    this._externalPluginRegistry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalPluginRegistryInput() {
    return this._externalPluginRegistry;
  }

  // git_self_signed_cert - computed: false, optional: true, required: false
  private _gitSelfSignedCert?: boolean | cdktf.IResolvable; 
  public get gitSelfSignedCert() {
    return this.getBooleanAttribute('git_self_signed_cert');
  }
  public set gitSelfSignedCert(value: boolean | cdktf.IResolvable) {
    this._gitSelfSignedCert = value;
  }
  public resetGitSelfSignedCert() {
    this._gitSelfSignedCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitSelfSignedCertInput() {
    return this._gitSelfSignedCert;
  }

  // non_proxy_hosts - computed: false, optional: true, required: false
  private _nonProxyHosts?: string; 
  public get nonProxyHosts() {
    return this.getStringAttribute('non_proxy_hosts');
  }
  public set nonProxyHosts(value: string) {
    this._nonProxyHosts = value;
  }
  public resetNonProxyHosts() {
    this._nonProxyHosts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nonProxyHostsInput() {
    return this._nonProxyHosts;
  }

  // open_vsx_registry_url - computed: false, optional: true, required: false
  private _openVsxRegistryUrl?: string; 
  public get openVsxRegistryUrl() {
    return this.getStringAttribute('open_vsx_registry_url');
  }
  public set openVsxRegistryUrl(value: string) {
    this._openVsxRegistryUrl = value;
  }
  public resetOpenVsxRegistryUrl() {
    this._openVsxRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openVsxRegistryUrlInput() {
    return this._openVsxRegistryUrl;
  }

  // plugin_registry_cpu_limit - computed: false, optional: true, required: false
  private _pluginRegistryCpuLimit?: string; 
  public get pluginRegistryCpuLimit() {
    return this.getStringAttribute('plugin_registry_cpu_limit');
  }
  public set pluginRegistryCpuLimit(value: string) {
    this._pluginRegistryCpuLimit = value;
  }
  public resetPluginRegistryCpuLimit() {
    this._pluginRegistryCpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryCpuLimitInput() {
    return this._pluginRegistryCpuLimit;
  }

  // plugin_registry_cpu_request - computed: false, optional: true, required: false
  private _pluginRegistryCpuRequest?: string; 
  public get pluginRegistryCpuRequest() {
    return this.getStringAttribute('plugin_registry_cpu_request');
  }
  public set pluginRegistryCpuRequest(value: string) {
    this._pluginRegistryCpuRequest = value;
  }
  public resetPluginRegistryCpuRequest() {
    this._pluginRegistryCpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryCpuRequestInput() {
    return this._pluginRegistryCpuRequest;
  }

  // plugin_registry_env - computed: false, optional: true, required: false
  private _pluginRegistryEnv = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnvList(this, "plugin_registry_env", false);
  public get pluginRegistryEnv() {
    return this._pluginRegistryEnv;
  }
  public putPluginRegistryEnv(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryEnv[] | cdktf.IResolvable) {
    this._pluginRegistryEnv.internalValue = value;
  }
  public resetPluginRegistryEnv() {
    this._pluginRegistryEnv.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryEnvInput() {
    return this._pluginRegistryEnv.internalValue;
  }

  // plugin_registry_image - computed: false, optional: true, required: false
  private _pluginRegistryImage?: string; 
  public get pluginRegistryImage() {
    return this.getStringAttribute('plugin_registry_image');
  }
  public set pluginRegistryImage(value: string) {
    this._pluginRegistryImage = value;
  }
  public resetPluginRegistryImage() {
    this._pluginRegistryImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryImageInput() {
    return this._pluginRegistryImage;
  }

  // plugin_registry_ingress - computed: false, optional: true, required: false
  private _pluginRegistryIngress = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngressOutputReference(this, "plugin_registry_ingress");
  public get pluginRegistryIngress() {
    return this._pluginRegistryIngress;
  }
  public putPluginRegistryIngress(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryIngress) {
    this._pluginRegistryIngress.internalValue = value;
  }
  public resetPluginRegistryIngress() {
    this._pluginRegistryIngress.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryIngressInput() {
    return this._pluginRegistryIngress.internalValue;
  }

  // plugin_registry_memory_limit - computed: false, optional: true, required: false
  private _pluginRegistryMemoryLimit?: string; 
  public get pluginRegistryMemoryLimit() {
    return this.getStringAttribute('plugin_registry_memory_limit');
  }
  public set pluginRegistryMemoryLimit(value: string) {
    this._pluginRegistryMemoryLimit = value;
  }
  public resetPluginRegistryMemoryLimit() {
    this._pluginRegistryMemoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryMemoryLimitInput() {
    return this._pluginRegistryMemoryLimit;
  }

  // plugin_registry_memory_request - computed: false, optional: true, required: false
  private _pluginRegistryMemoryRequest?: string; 
  public get pluginRegistryMemoryRequest() {
    return this.getStringAttribute('plugin_registry_memory_request');
  }
  public set pluginRegistryMemoryRequest(value: string) {
    this._pluginRegistryMemoryRequest = value;
  }
  public resetPluginRegistryMemoryRequest() {
    this._pluginRegistryMemoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryMemoryRequestInput() {
    return this._pluginRegistryMemoryRequest;
  }

  // plugin_registry_pull_policy - computed: false, optional: true, required: false
  private _pluginRegistryPullPolicy?: string; 
  public get pluginRegistryPullPolicy() {
    return this.getStringAttribute('plugin_registry_pull_policy');
  }
  public set pluginRegistryPullPolicy(value: string) {
    this._pluginRegistryPullPolicy = value;
  }
  public resetPluginRegistryPullPolicy() {
    this._pluginRegistryPullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryPullPolicyInput() {
    return this._pluginRegistryPullPolicy;
  }

  // plugin_registry_route - computed: false, optional: true, required: false
  private _pluginRegistryRoute = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRouteOutputReference(this, "plugin_registry_route");
  public get pluginRegistryRoute() {
    return this._pluginRegistryRoute;
  }
  public putPluginRegistryRoute(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerPluginRegistryRoute) {
    this._pluginRegistryRoute.internalValue = value;
  }
  public resetPluginRegistryRoute() {
    this._pluginRegistryRoute.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryRouteInput() {
    return this._pluginRegistryRoute.internalValue;
  }

  // plugin_registry_url - computed: false, optional: true, required: false
  private _pluginRegistryUrl?: string; 
  public get pluginRegistryUrl() {
    return this.getStringAttribute('plugin_registry_url');
  }
  public set pluginRegistryUrl(value: string) {
    this._pluginRegistryUrl = value;
  }
  public resetPluginRegistryUrl() {
    this._pluginRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pluginRegistryUrlInput() {
    return this._pluginRegistryUrl;
  }

  // proxy_password - computed: false, optional: true, required: false
  private _proxyPassword?: string; 
  public get proxyPassword() {
    return this.getStringAttribute('proxy_password');
  }
  public set proxyPassword(value: string) {
    this._proxyPassword = value;
  }
  public resetProxyPassword() {
    this._proxyPassword = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyPasswordInput() {
    return this._proxyPassword;
  }

  // proxy_port - computed: false, optional: true, required: false
  private _proxyPort?: string; 
  public get proxyPort() {
    return this.getStringAttribute('proxy_port');
  }
  public set proxyPort(value: string) {
    this._proxyPort = value;
  }
  public resetProxyPort() {
    this._proxyPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyPortInput() {
    return this._proxyPort;
  }

  // proxy_secret - computed: false, optional: true, required: false
  private _proxySecret?: string; 
  public get proxySecret() {
    return this.getStringAttribute('proxy_secret');
  }
  public set proxySecret(value: string) {
    this._proxySecret = value;
  }
  public resetProxySecret() {
    this._proxySecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxySecretInput() {
    return this._proxySecret;
  }

  // proxy_url - computed: false, optional: true, required: false
  private _proxyUrl?: string; 
  public get proxyUrl() {
    return this.getStringAttribute('proxy_url');
  }
  public set proxyUrl(value: string) {
    this._proxyUrl = value;
  }
  public resetProxyUrl() {
    this._proxyUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUrlInput() {
    return this._proxyUrl;
  }

  // proxy_user - computed: false, optional: true, required: false
  private _proxyUser?: string; 
  public get proxyUser() {
    return this.getStringAttribute('proxy_user');
  }
  public set proxyUser(value: string) {
    this._proxyUser = value;
  }
  public resetProxyUser() {
    this._proxyUser = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get proxyUserInput() {
    return this._proxyUser;
  }

  // self_signed_cert - computed: false, optional: true, required: false
  private _selfSignedCert?: boolean | cdktf.IResolvable; 
  public get selfSignedCert() {
    return this.getBooleanAttribute('self_signed_cert');
  }
  public set selfSignedCert(value: boolean | cdktf.IResolvable) {
    this._selfSignedCert = value;
  }
  public resetSelfSignedCert() {
    this._selfSignedCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selfSignedCertInput() {
    return this._selfSignedCert;
  }

  // server_cpu_limit - computed: false, optional: true, required: false
  private _serverCpuLimit?: string; 
  public get serverCpuLimit() {
    return this.getStringAttribute('server_cpu_limit');
  }
  public set serverCpuLimit(value: string) {
    this._serverCpuLimit = value;
  }
  public resetServerCpuLimit() {
    this._serverCpuLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverCpuLimitInput() {
    return this._serverCpuLimit;
  }

  // server_cpu_request - computed: false, optional: true, required: false
  private _serverCpuRequest?: string; 
  public get serverCpuRequest() {
    return this.getStringAttribute('server_cpu_request');
  }
  public set serverCpuRequest(value: string) {
    this._serverCpuRequest = value;
  }
  public resetServerCpuRequest() {
    this._serverCpuRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverCpuRequestInput() {
    return this._serverCpuRequest;
  }

  // server_exposure_strategy - computed: false, optional: true, required: false
  private _serverExposureStrategy?: string; 
  public get serverExposureStrategy() {
    return this.getStringAttribute('server_exposure_strategy');
  }
  public set serverExposureStrategy(value: string) {
    this._serverExposureStrategy = value;
  }
  public resetServerExposureStrategy() {
    this._serverExposureStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverExposureStrategyInput() {
    return this._serverExposureStrategy;
  }

  // server_memory_limit - computed: false, optional: true, required: false
  private _serverMemoryLimit?: string; 
  public get serverMemoryLimit() {
    return this.getStringAttribute('server_memory_limit');
  }
  public set serverMemoryLimit(value: string) {
    this._serverMemoryLimit = value;
  }
  public resetServerMemoryLimit() {
    this._serverMemoryLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverMemoryLimitInput() {
    return this._serverMemoryLimit;
  }

  // server_memory_request - computed: false, optional: true, required: false
  private _serverMemoryRequest?: string; 
  public get serverMemoryRequest() {
    return this.getStringAttribute('server_memory_request');
  }
  public set serverMemoryRequest(value: string) {
    this._serverMemoryRequest = value;
  }
  public resetServerMemoryRequest() {
    this._serverMemoryRequest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverMemoryRequestInput() {
    return this._serverMemoryRequest;
  }

  // server_trust_store_config_map_name - computed: false, optional: true, required: false
  private _serverTrustStoreConfigMapName?: string; 
  public get serverTrustStoreConfigMapName() {
    return this.getStringAttribute('server_trust_store_config_map_name');
  }
  public set serverTrustStoreConfigMapName(value: string) {
    this._serverTrustStoreConfigMapName = value;
  }
  public resetServerTrustStoreConfigMapName() {
    this._serverTrustStoreConfigMapName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverTrustStoreConfigMapNameInput() {
    return this._serverTrustStoreConfigMapName;
  }

  // single_host_gateway_config_map_labels - computed: false, optional: true, required: false
  private _singleHostGatewayConfigMapLabels?: { [key: string]: string }; 
  public get singleHostGatewayConfigMapLabels() {
    return this.getStringMapAttribute('single_host_gateway_config_map_labels');
  }
  public set singleHostGatewayConfigMapLabels(value: { [key: string]: string }) {
    this._singleHostGatewayConfigMapLabels = value;
  }
  public resetSingleHostGatewayConfigMapLabels() {
    this._singleHostGatewayConfigMapLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleHostGatewayConfigMapLabelsInput() {
    return this._singleHostGatewayConfigMapLabels;
  }

  // single_host_gateway_config_sidecar_image - computed: false, optional: true, required: false
  private _singleHostGatewayConfigSidecarImage?: string; 
  public get singleHostGatewayConfigSidecarImage() {
    return this.getStringAttribute('single_host_gateway_config_sidecar_image');
  }
  public set singleHostGatewayConfigSidecarImage(value: string) {
    this._singleHostGatewayConfigSidecarImage = value;
  }
  public resetSingleHostGatewayConfigSidecarImage() {
    this._singleHostGatewayConfigSidecarImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleHostGatewayConfigSidecarImageInput() {
    return this._singleHostGatewayConfigSidecarImage;
  }

  // single_host_gateway_image - computed: false, optional: true, required: false
  private _singleHostGatewayImage?: string; 
  public get singleHostGatewayImage() {
    return this.getStringAttribute('single_host_gateway_image');
  }
  public set singleHostGatewayImage(value: string) {
    this._singleHostGatewayImage = value;
  }
  public resetSingleHostGatewayImage() {
    this._singleHostGatewayImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleHostGatewayImageInput() {
    return this._singleHostGatewayImage;
  }

  // tls_support - computed: false, optional: true, required: false
  private _tlsSupport?: boolean | cdktf.IResolvable; 
  public get tlsSupport() {
    return this.getBooleanAttribute('tls_support');
  }
  public set tlsSupport(value: boolean | cdktf.IResolvable) {
    this._tlsSupport = value;
  }
  public resetTlsSupport() {
    this._tlsSupport = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsSupportInput() {
    return this._tlsSupport;
  }

  // use_internal_cluster_svc_names - computed: false, optional: true, required: false
  private _useInternalClusterSvcNames?: boolean | cdktf.IResolvable; 
  public get useInternalClusterSvcNames() {
    return this.getBooleanAttribute('use_internal_cluster_svc_names');
  }
  public set useInternalClusterSvcNames(value: boolean | cdktf.IResolvable) {
    this._useInternalClusterSvcNames = value;
  }
  public resetUseInternalClusterSvcNames() {
    this._useInternalClusterSvcNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useInternalClusterSvcNamesInput() {
    return this._useInternalClusterSvcNames;
  }

  // workspace_default_components - computed: false, optional: true, required: false
  private _workspaceDefaultComponents = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponentsList(this, "workspace_default_components", false);
  public get workspaceDefaultComponents() {
    return this._workspaceDefaultComponents;
  }
  public putWorkspaceDefaultComponents(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspaceDefaultComponents[] | cdktf.IResolvable) {
    this._workspaceDefaultComponents.internalValue = value;
  }
  public resetWorkspaceDefaultComponents() {
    this._workspaceDefaultComponents.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceDefaultComponentsInput() {
    return this._workspaceDefaultComponents.internalValue;
  }

  // workspace_default_editor - computed: false, optional: true, required: false
  private _workspaceDefaultEditor?: string; 
  public get workspaceDefaultEditor() {
    return this.getStringAttribute('workspace_default_editor');
  }
  public set workspaceDefaultEditor(value: string) {
    this._workspaceDefaultEditor = value;
  }
  public resetWorkspaceDefaultEditor() {
    this._workspaceDefaultEditor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceDefaultEditorInput() {
    return this._workspaceDefaultEditor;
  }

  // workspace_namespace_default - computed: false, optional: true, required: false
  private _workspaceNamespaceDefault?: string; 
  public get workspaceNamespaceDefault() {
    return this.getStringAttribute('workspace_namespace_default');
  }
  public set workspaceNamespaceDefault(value: string) {
    this._workspaceNamespaceDefault = value;
  }
  public resetWorkspaceNamespaceDefault() {
    this._workspaceNamespaceDefault = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceNamespaceDefaultInput() {
    return this._workspaceNamespaceDefault;
  }

  // workspace_pod_node_selector - computed: false, optional: true, required: false
  private _workspacePodNodeSelector?: { [key: string]: string }; 
  public get workspacePodNodeSelector() {
    return this.getStringMapAttribute('workspace_pod_node_selector');
  }
  public set workspacePodNodeSelector(value: { [key: string]: string }) {
    this._workspacePodNodeSelector = value;
  }
  public resetWorkspacePodNodeSelector() {
    this._workspacePodNodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspacePodNodeSelectorInput() {
    return this._workspacePodNodeSelector;
  }

  // workspace_pod_tolerations - computed: false, optional: true, required: false
  private _workspacePodTolerations = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerationsList(this, "workspace_pod_tolerations", false);
  public get workspacePodTolerations() {
    return this._workspacePodTolerations;
  }
  public putWorkspacePodTolerations(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacePodTolerations[] | cdktf.IResolvable) {
    this._workspacePodTolerations.internalValue = value;
  }
  public resetWorkspacePodTolerations() {
    this._workspacePodTolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspacePodTolerationsInput() {
    return this._workspacePodTolerations.internalValue;
  }

  // workspaces_default_plugins - computed: false, optional: true, required: false
  private _workspacesDefaultPlugins = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPluginsList(this, "workspaces_default_plugins", false);
  public get workspacesDefaultPlugins() {
    return this._workspacesDefaultPlugins;
  }
  public putWorkspacesDefaultPlugins(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerWorkspacesDefaultPlugins[] | cdktf.IResolvable) {
    this._workspacesDefaultPlugins.internalValue = value;
  }
  public resetWorkspacesDefaultPlugins() {
    this._workspacesDefaultPlugins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspacesDefaultPluginsInput() {
    return this._workspacesDefaultPlugins.internalValue;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage {
  /**
  * Size of the persistent volume claim for workspaces.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#per_workspace_strategy_pvc_claim_size DataK8SOrgEclipseCheCheClusterV1Manifest#per_workspace_strategy_pvc_claim_size}
  */
  readonly perWorkspaceStrategyPvcClaimSize?: string;
  /**
  * Storage class for the Persistent Volume Claims dedicated to the Che workspaces. When omitted or left blank, a default storage class is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#per_workspace_strategy_pvc_storage_class_name DataK8SOrgEclipseCheCheClusterV1Manifest#per_workspace_strategy_pvc_storage_class_name}
  */
  readonly perWorkspaceStrategyPvcStorageClassName?: string;
  /**
  * Storage class for the Persistent Volume Claim dedicated to the PostgreSQL database. When omitted or left blank, a default storage class is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#postgres_pvc_storage_class_name DataK8SOrgEclipseCheCheClusterV1Manifest#postgres_pvc_storage_class_name}
  */
  readonly postgresPvcStorageClassName?: string;
  /**
  * Instructs the Che server to start a special Pod to pre-create a sub-path in the Persistent Volumes. Defaults to 'false', however it will need to enable it according to the configuration of your Kubernetes cluster.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#pre_create_sub_paths DataK8SOrgEclipseCheCheClusterV1Manifest#pre_create_sub_paths}
  */
  readonly preCreateSubPaths?: boolean | cdktf.IResolvable;
  /**
  * Size of the persistent volume claim for workspaces. Defaults to '10Gi'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#pvc_claim_size DataK8SOrgEclipseCheCheClusterV1Manifest#pvc_claim_size}
  */
  readonly pvcClaimSize?: string;
  /**
  * Overrides the container image used to create sub-paths in the Persistent Volumes. This includes the image tag. Omit it or leave it empty to use the default container image provided by the Operator. See also the 'preCreateSubPaths' field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#pvc_jobs_image DataK8SOrgEclipseCheCheClusterV1Manifest#pvc_jobs_image}
  */
  readonly pvcJobsImage?: string;
  /**
  * Persistent volume claim strategy for the Che server. This Can be:'common' (all workspaces PVCs in one volume), 'per-workspace' (one PVC per workspace for all declared volumes) and 'unique' (one PVC per declared volume). Defaults to 'common'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#pvc_strategy DataK8SOrgEclipseCheCheClusterV1Manifest#pvc_strategy}
  */
  readonly pvcStrategy?: string;
  /**
  * Storage class for the Persistent Volume Claims dedicated to the Che workspaces. When omitted or left blank, a default storage class is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#workspace_pvc_storage_class_name DataK8SOrgEclipseCheCheClusterV1Manifest#workspace_pvc_storage_class_name}
  */
  readonly workspacePvcStorageClassName?: string;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecStorageToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    per_workspace_strategy_pvc_claim_size: cdktf.stringToTerraform(struct!.perWorkspaceStrategyPvcClaimSize),
    per_workspace_strategy_pvc_storage_class_name: cdktf.stringToTerraform(struct!.perWorkspaceStrategyPvcStorageClassName),
    postgres_pvc_storage_class_name: cdktf.stringToTerraform(struct!.postgresPvcStorageClassName),
    pre_create_sub_paths: cdktf.booleanToTerraform(struct!.preCreateSubPaths),
    pvc_claim_size: cdktf.stringToTerraform(struct!.pvcClaimSize),
    pvc_jobs_image: cdktf.stringToTerraform(struct!.pvcJobsImage),
    pvc_strategy: cdktf.stringToTerraform(struct!.pvcStrategy),
    workspace_pvc_storage_class_name: cdktf.stringToTerraform(struct!.workspacePvcStorageClassName),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecStorageToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    per_workspace_strategy_pvc_claim_size: {
      value: cdktf.stringToHclTerraform(struct!.perWorkspaceStrategyPvcClaimSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_workspace_strategy_pvc_storage_class_name: {
      value: cdktf.stringToHclTerraform(struct!.perWorkspaceStrategyPvcStorageClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    postgres_pvc_storage_class_name: {
      value: cdktf.stringToHclTerraform(struct!.postgresPvcStorageClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pre_create_sub_paths: {
      value: cdktf.booleanToHclTerraform(struct!.preCreateSubPaths),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pvc_claim_size: {
      value: cdktf.stringToHclTerraform(struct!.pvcClaimSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pvc_jobs_image: {
      value: cdktf.stringToHclTerraform(struct!.pvcJobsImage),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pvc_strategy: {
      value: cdktf.stringToHclTerraform(struct!.pvcStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workspace_pvc_storage_class_name: {
      value: cdktf.stringToHclTerraform(struct!.workspacePvcStorageClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._perWorkspaceStrategyPvcClaimSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.perWorkspaceStrategyPvcClaimSize = this._perWorkspaceStrategyPvcClaimSize;
    }
    if (this._perWorkspaceStrategyPvcStorageClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.perWorkspaceStrategyPvcStorageClassName = this._perWorkspaceStrategyPvcStorageClassName;
    }
    if (this._postgresPvcStorageClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgresPvcStorageClassName = this._postgresPvcStorageClassName;
    }
    if (this._preCreateSubPaths !== undefined) {
      hasAnyValues = true;
      internalValueResult.preCreateSubPaths = this._preCreateSubPaths;
    }
    if (this._pvcClaimSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pvcClaimSize = this._pvcClaimSize;
    }
    if (this._pvcJobsImage !== undefined) {
      hasAnyValues = true;
      internalValueResult.pvcJobsImage = this._pvcJobsImage;
    }
    if (this._pvcStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.pvcStrategy = this._pvcStrategy;
    }
    if (this._workspacePvcStorageClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspacePvcStorageClassName = this._workspacePvcStorageClassName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._perWorkspaceStrategyPvcClaimSize = undefined;
      this._perWorkspaceStrategyPvcStorageClassName = undefined;
      this._postgresPvcStorageClassName = undefined;
      this._preCreateSubPaths = undefined;
      this._pvcClaimSize = undefined;
      this._pvcJobsImage = undefined;
      this._pvcStrategy = undefined;
      this._workspacePvcStorageClassName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._perWorkspaceStrategyPvcClaimSize = value.perWorkspaceStrategyPvcClaimSize;
      this._perWorkspaceStrategyPvcStorageClassName = value.perWorkspaceStrategyPvcStorageClassName;
      this._postgresPvcStorageClassName = value.postgresPvcStorageClassName;
      this._preCreateSubPaths = value.preCreateSubPaths;
      this._pvcClaimSize = value.pvcClaimSize;
      this._pvcJobsImage = value.pvcJobsImage;
      this._pvcStrategy = value.pvcStrategy;
      this._workspacePvcStorageClassName = value.workspacePvcStorageClassName;
    }
  }

  // per_workspace_strategy_pvc_claim_size - computed: false, optional: true, required: false
  private _perWorkspaceStrategyPvcClaimSize?: string; 
  public get perWorkspaceStrategyPvcClaimSize() {
    return this.getStringAttribute('per_workspace_strategy_pvc_claim_size');
  }
  public set perWorkspaceStrategyPvcClaimSize(value: string) {
    this._perWorkspaceStrategyPvcClaimSize = value;
  }
  public resetPerWorkspaceStrategyPvcClaimSize() {
    this._perWorkspaceStrategyPvcClaimSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perWorkspaceStrategyPvcClaimSizeInput() {
    return this._perWorkspaceStrategyPvcClaimSize;
  }

  // per_workspace_strategy_pvc_storage_class_name - computed: false, optional: true, required: false
  private _perWorkspaceStrategyPvcStorageClassName?: string; 
  public get perWorkspaceStrategyPvcStorageClassName() {
    return this.getStringAttribute('per_workspace_strategy_pvc_storage_class_name');
  }
  public set perWorkspaceStrategyPvcStorageClassName(value: string) {
    this._perWorkspaceStrategyPvcStorageClassName = value;
  }
  public resetPerWorkspaceStrategyPvcStorageClassName() {
    this._perWorkspaceStrategyPvcStorageClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perWorkspaceStrategyPvcStorageClassNameInput() {
    return this._perWorkspaceStrategyPvcStorageClassName;
  }

  // postgres_pvc_storage_class_name - computed: false, optional: true, required: false
  private _postgresPvcStorageClassName?: string; 
  public get postgresPvcStorageClassName() {
    return this.getStringAttribute('postgres_pvc_storage_class_name');
  }
  public set postgresPvcStorageClassName(value: string) {
    this._postgresPvcStorageClassName = value;
  }
  public resetPostgresPvcStorageClassName() {
    this._postgresPvcStorageClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresPvcStorageClassNameInput() {
    return this._postgresPvcStorageClassName;
  }

  // pre_create_sub_paths - computed: false, optional: true, required: false
  private _preCreateSubPaths?: boolean | cdktf.IResolvable; 
  public get preCreateSubPaths() {
    return this.getBooleanAttribute('pre_create_sub_paths');
  }
  public set preCreateSubPaths(value: boolean | cdktf.IResolvable) {
    this._preCreateSubPaths = value;
  }
  public resetPreCreateSubPaths() {
    this._preCreateSubPaths = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preCreateSubPathsInput() {
    return this._preCreateSubPaths;
  }

  // pvc_claim_size - computed: false, optional: true, required: false
  private _pvcClaimSize?: string; 
  public get pvcClaimSize() {
    return this.getStringAttribute('pvc_claim_size');
  }
  public set pvcClaimSize(value: string) {
    this._pvcClaimSize = value;
  }
  public resetPvcClaimSize() {
    this._pvcClaimSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pvcClaimSizeInput() {
    return this._pvcClaimSize;
  }

  // pvc_jobs_image - computed: false, optional: true, required: false
  private _pvcJobsImage?: string; 
  public get pvcJobsImage() {
    return this.getStringAttribute('pvc_jobs_image');
  }
  public set pvcJobsImage(value: string) {
    this._pvcJobsImage = value;
  }
  public resetPvcJobsImage() {
    this._pvcJobsImage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pvcJobsImageInput() {
    return this._pvcJobsImage;
  }

  // pvc_strategy - computed: false, optional: true, required: false
  private _pvcStrategy?: string; 
  public get pvcStrategy() {
    return this.getStringAttribute('pvc_strategy');
  }
  public set pvcStrategy(value: string) {
    this._pvcStrategy = value;
  }
  public resetPvcStrategy() {
    this._pvcStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pvcStrategyInput() {
    return this._pvcStrategy;
  }

  // workspace_pvc_storage_class_name - computed: false, optional: true, required: false
  private _workspacePvcStorageClassName?: string; 
  public get workspacePvcStorageClassName() {
    return this.getStringAttribute('workspace_pvc_storage_class_name');
  }
  public set workspacePvcStorageClassName(value: string) {
    this._workspacePvcStorageClassName = value;
  }
  public resetWorkspacePvcStorageClassName() {
    this._workspacePvcStorageClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspacePvcStorageClassNameInput() {
    return this._workspacePvcStorageClassName;
  }
}
export interface DataK8SOrgEclipseCheCheClusterV1ManifestSpec {
  /**
  * Configuration settings related to the Authentication used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#auth DataK8SOrgEclipseCheCheClusterV1Manifest#auth}
  */
  readonly auth?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth;
  /**
  * Configuration settings related to the User Dashboard used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dashboard DataK8SOrgEclipseCheCheClusterV1Manifest#dashboard}
  */
  readonly dashboard?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard;
  /**
  * Configuration settings related to the database used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#database DataK8SOrgEclipseCheCheClusterV1Manifest#database}
  */
  readonly database?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase;
  /**
  * DevWorkspace operator configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#dev_workspace DataK8SOrgEclipseCheCheClusterV1Manifest#dev_workspace}
  */
  readonly devWorkspace?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace;
  /**
  * A configuration that allows users to work with remote Git repositories.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#git_services DataK8SOrgEclipseCheCheClusterV1Manifest#git_services}
  */
  readonly gitServices?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices;
  /**
  * Kubernetes Image Puller configuration
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#image_puller DataK8SOrgEclipseCheCheClusterV1Manifest#image_puller}
  */
  readonly imagePuller?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller;
  /**
  * Configuration settings specific to Che installations made on upstream Kubernetes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#k8s DataK8SOrgEclipseCheCheClusterV1Manifest#k8s}
  */
  readonly k8S?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S;
  /**
  * Configuration settings related to the metrics collection used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#metrics DataK8SOrgEclipseCheCheClusterV1Manifest#metrics}
  */
  readonly metrics?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics;
  /**
  * General configuration settings related to the Che server, the plugin and devfile registries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#server DataK8SOrgEclipseCheCheClusterV1Manifest#server}
  */
  readonly server?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer;
  /**
  * Configuration settings related to the persistent storage used by the Che installation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#storage DataK8SOrgEclipseCheCheClusterV1Manifest#storage}
  */
  readonly storage?: DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage;
}

export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecToTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthToTerraform(struct!.auth),
    dashboard: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboardToTerraform(struct!.dashboard),
    database: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseToTerraform(struct!.database),
    dev_workspace: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceToTerraform(struct!.devWorkspace),
    git_services: dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesToTerraform(struct!.gitServices),
    image_puller: dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerToTerraform(struct!.imagePuller),
    k8s: dataK8SOrgEclipseCheCheClusterV1ManifestSpecK8SToTerraform(struct!.k8S),
    metrics: dataK8SOrgEclipseCheCheClusterV1ManifestSpecMetricsToTerraform(struct!.metrics),
    server: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerToTerraform(struct!.server),
    storage: dataK8SOrgEclipseCheCheClusterV1ManifestSpecStorageToTerraform(struct!.storage),
  }
}


export function dataK8SOrgEclipseCheCheClusterV1ManifestSpecToHclTerraform(struct?: DataK8SOrgEclipseCheCheClusterV1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth",
    },
    dashboard: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboardToHclTerraform(struct!.dashboard),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard",
    },
    database: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseToHclTerraform(struct!.database),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase",
    },
    dev_workspace: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceToHclTerraform(struct!.devWorkspace),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace",
    },
    git_services: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesToHclTerraform(struct!.gitServices),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices",
    },
    image_puller: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerToHclTerraform(struct!.imagePuller),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller",
    },
    k8s: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecK8SToHclTerraform(struct!.k8S),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S",
    },
    metrics: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecMetricsToHclTerraform(struct!.metrics),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics",
    },
    server: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecServerToHclTerraform(struct!.server),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer",
    },
    storage: {
      value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecStorageToHclTerraform(struct!.storage),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SOrgEclipseCheCheClusterV1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SOrgEclipseCheCheClusterV1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._dashboard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dashboard = this._dashboard?.internalValue;
    }
    if (this._database?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database?.internalValue;
    }
    if (this._devWorkspace?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.devWorkspace = this._devWorkspace?.internalValue;
    }
    if (this._gitServices?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.gitServices = this._gitServices?.internalValue;
    }
    if (this._imagePuller?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePuller = this._imagePuller?.internalValue;
    }
    if (this._k8S?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.k8S = this._k8S?.internalValue;
    }
    if (this._metrics?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metrics = this._metrics?.internalValue;
    }
    if (this._server?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server?.internalValue;
    }
    if (this._storage?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.storage = this._storage?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._dashboard.internalValue = undefined;
      this._database.internalValue = undefined;
      this._devWorkspace.internalValue = undefined;
      this._gitServices.internalValue = undefined;
      this._imagePuller.internalValue = undefined;
      this._k8S.internalValue = undefined;
      this._metrics.internalValue = undefined;
      this._server.internalValue = undefined;
      this._storage.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._dashboard.internalValue = value.dashboard;
      this._database.internalValue = value.database;
      this._devWorkspace.internalValue = value.devWorkspace;
      this._gitServices.internalValue = value.gitServices;
      this._imagePuller.internalValue = value.imagePuller;
      this._k8S.internalValue = value.k8S;
      this._metrics.internalValue = value.metrics;
      this._server.internalValue = value.server;
      this._storage.internalValue = value.storage;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // dashboard - computed: false, optional: true, required: false
  private _dashboard = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboardOutputReference(this, "dashboard");
  public get dashboard() {
    return this._dashboard;
  }
  public putDashboard(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDashboard) {
    this._dashboard.internalValue = value;
  }
  public resetDashboard() {
    this._dashboard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dashboardInput() {
    return this._dashboard.internalValue;
  }

  // database - computed: false, optional: true, required: false
  private _database = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabaseOutputReference(this, "database");
  public get database() {
    return this._database;
  }
  public putDatabase(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDatabase) {
    this._database.internalValue = value;
  }
  public resetDatabase() {
    this._database.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database.internalValue;
  }

  // dev_workspace - computed: false, optional: true, required: false
  private _devWorkspace = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspaceOutputReference(this, "dev_workspace");
  public get devWorkspace() {
    return this._devWorkspace;
  }
  public putDevWorkspace(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecDevWorkspace) {
    this._devWorkspace.internalValue = value;
  }
  public resetDevWorkspace() {
    this._devWorkspace.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devWorkspaceInput() {
    return this._devWorkspace.internalValue;
  }

  // git_services - computed: false, optional: true, required: false
  private _gitServices = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServicesOutputReference(this, "git_services");
  public get gitServices() {
    return this._gitServices;
  }
  public putGitServices(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecGitServices) {
    this._gitServices.internalValue = value;
  }
  public resetGitServices() {
    this._gitServices.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get gitServicesInput() {
    return this._gitServices.internalValue;
  }

  // image_puller - computed: false, optional: true, required: false
  private _imagePuller = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePullerOutputReference(this, "image_puller");
  public get imagePuller() {
    return this._imagePuller;
  }
  public putImagePuller(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecImagePuller) {
    this._imagePuller.internalValue = value;
  }
  public resetImagePuller() {
    this._imagePuller.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullerInput() {
    return this._imagePuller.internalValue;
  }

  // k8s - computed: false, optional: true, required: false
  private _k8S = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8SOutputReference(this, "k8s");
  public get k8S() {
    return this._k8S;
  }
  public putK8S(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecK8S) {
    this._k8S.internalValue = value;
  }
  public resetK8S() {
    this._k8S.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get k8SInput() {
    return this._k8S.internalValue;
  }

  // metrics - computed: false, optional: true, required: false
  private _metrics = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetricsOutputReference(this, "metrics");
  public get metrics() {
    return this._metrics;
  }
  public putMetrics(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecMetrics) {
    this._metrics.internalValue = value;
  }
  public resetMetrics() {
    this._metrics.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsInput() {
    return this._metrics.internalValue;
  }

  // server - computed: false, optional: true, required: false
  private _server = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecServerOutputReference(this, "server");
  public get server() {
    return this._server;
  }
  public putServer(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecServer) {
    this._server.internalValue = value;
  }
  public resetServer() {
    this._server.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server.internalValue;
  }

  // storage - computed: false, optional: true, required: false
  private _storage = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorageOutputReference(this, "storage");
  public get storage() {
    return this._storage;
  }
  public putStorage(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpecStorage) {
    this._storage.internalValue = value;
  }
  public resetStorage() {
    this._storage.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageInput() {
    return this._storage.internalValue;
  }
}

/**
* Represents a {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest k8s_org_eclipse_che_che_cluster_v1_manifest}
*/
export class DataK8SOrgEclipseCheCheClusterV1Manifest extends cdktf.TerraformDataSource {

  // =================
  // STATIC PROPERTIES
  // =================
  public static readonly tfResourceType = "k8s_org_eclipse_che_che_cluster_v1_manifest";

  // ==============
  // STATIC Methods
  // ==============
  /**
  * Generates CDKTF code for importing a DataK8SOrgEclipseCheCheClusterV1Manifest resource upon running "cdktf plan <stack-name>"
  * @param scope The scope in which to define this construct
  * @param importToId The construct id used in the generated config for the DataK8SOrgEclipseCheCheClusterV1Manifest to import
  * @param importFromId The id of the existing DataK8SOrgEclipseCheCheClusterV1Manifest that should be imported. Refer to the {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest#import import section} in the documentation of this resource for the id to use
  * @param provider? Optional instance of the provider where the DataK8SOrgEclipseCheCheClusterV1Manifest to import is found
  */
  public static generateConfigForImport(scope: Construct, importToId: string, importFromId: string, provider?: cdktf.TerraformProvider) {
        return new cdktf.ImportableResource(scope, importToId, { terraformResourceType: "k8s_org_eclipse_che_che_cluster_v1_manifest", importId: importFromId, provider });
      }

  // ===========
  // INITIALIZER
  // ===========

  /**
  * Create a new {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/org_eclipse_che_che_cluster_v1_manifest k8s_org_eclipse_che_che_cluster_v1_manifest} Data Source
  *
  * @param scope The scope in which to define this construct
  * @param id The scoped construct ID. Must be unique amongst siblings in the same scope
  * @param options DataK8SOrgEclipseCheCheClusterV1ManifestConfig
  */
  public constructor(scope: Construct, id: string, config: DataK8SOrgEclipseCheCheClusterV1ManifestConfig) {
    super(scope, id, {
      terraformResourceType: 'k8s_org_eclipse_che_che_cluster_v1_manifest',
      terraformGeneratorMetadata: {
        providerName: 'k8s',
        providerVersion: '2025.12.1',
        providerVersionConstraint: '2025.12.1'
      },
      provider: config.provider,
      dependsOn: config.dependsOn,
      count: config.count,
      lifecycle: config.lifecycle,
      provisioners: config.provisioners,
      connection: config.connection,
      forEach: config.forEach
    });
    this._metadata.internalValue = config.metadata;
    this._spec.internalValue = config.spec;
  }

  // ==========
  // ATTRIBUTES
  // ==========

  // metadata - computed: false, optional: false, required: true
  private _metadata = new DataK8SOrgEclipseCheCheClusterV1ManifestMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SOrgEclipseCheCheClusterV1ManifestMetadata) {
    this._metadata.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SOrgEclipseCheCheClusterV1ManifestSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SOrgEclipseCheCheClusterV1ManifestSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }

  // yaml - computed: true, optional: false, required: false
  public get yaml() {
    return this.getStringAttribute('yaml');
  }

  // =========
  // SYNTHESIS
  // =========

  protected synthesizeAttributes(): { [name: string]: any } {
    return {
      metadata: dataK8SOrgEclipseCheCheClusterV1ManifestMetadataToTerraform(this._metadata.internalValue),
      spec: dataK8SOrgEclipseCheCheClusterV1ManifestSpecToTerraform(this._spec.internalValue),
    };
  }

  protected synthesizeHclAttributes(): { [name: string]: any } {
    const attrs = {
      metadata: {
        value: dataK8SOrgEclipseCheCheClusterV1ManifestMetadataToHclTerraform(this._metadata.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestMetadata",
      },
      spec: {
        value: dataK8SOrgEclipseCheCheClusterV1ManifestSpecToHclTerraform(this._spec.internalValue),
        isBlock: true,
        type: "struct",
        storageClassType: "DataK8SOrgEclipseCheCheClusterV1ManifestSpec",
      },
    };

    // remove undefined attributes
    return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined ))
  }
}
