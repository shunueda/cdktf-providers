import * as cdktf from 'cdktf';
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#annotations DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#labels DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadataToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadataToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand {
  /**
  * Args is the command arguments.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#args DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#args}
  */
  readonly args?: string[];
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters;
  /**
  * Entrypoint is the command entry point to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#entrypoint DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#entrypoint}
  */
  readonly entrypoint: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for command.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClustersToTerraform(struct!.clusters),
    entrypoint: cdktf.stringToTerraform(struct!.entrypoint),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters",
    },
    entrypoint: {
      value: cdktf.stringToHclTerraform(struct!.entrypoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._entrypoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.entrypoint = this._entrypoint;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._entrypoint = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._entrypoint = value.entrypoint;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // entrypoint - computed: false, optional: false, required: true
  private _entrypoint?: string; 
  public get entrypoint() {
    return this.getStringAttribute('entrypoint');
  }
  public set entrypoint(value: string) {
    this._entrypoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get entrypointInput() {
    return this._entrypoint;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect {
  /**
  * Check defines the verification statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check: { [key: string]: string };
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._check = undefined;
      this._match = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._check = value.check;
      this._match = value.match;
    }
  }

  // check - computed: false, optional: false, required: true
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Label selector to match objects to delete
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#labels DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRefToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    kind: cdktf.stringToTerraform(struct!.kind),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRefToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._kind = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._kind = value.kind;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings[] | cdktf.IResolvable;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters;
  /**
  * DeletionPropagationPolicy decides if a deletion will propagate to the dependents of the object, and how the garbage collector will handle the propagation. Overrides the deletion propagation policy set in the Configuration, the Test and the TestStep.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion_propagation_policy DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion_propagation_policy}
  */
  readonly deletionPropagationPolicy?: string;
  /**
  * Expect defines a list of matched checks to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#expect DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#expect}
  */
  readonly expect?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect[] | cdktf.IResolvable;
  /**
  * File is the path to the referenced file. This can be a direct path to a file or an expression that matches multiple files, such as 'manifest/*.yaml' for all YAML files within the 'manifest' directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#file DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#file}
  */
  readonly file?: string;
  /**
  * Ref determines objects to be deleted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#ref DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#ref}
  */
  readonly ref?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef;
  /**
  * Template determines whether resources should be considered for templating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#template DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#template}
  */
  readonly template?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsToTerraform, false)(struct!.bindings),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClustersToTerraform(struct!.clusters),
    deletion_propagation_policy: cdktf.stringToTerraform(struct!.deletionPropagationPolicy),
    expect: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectToTerraform, false)(struct!.expect),
    file: cdktf.stringToTerraform(struct!.file),
    ref: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRefToTerraform(struct!.ref),
    template: cdktf.booleanToTerraform(struct!.template),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsList",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters",
    },
    deletion_propagation_policy: {
      value: cdktf.stringToHclTerraform(struct!.deletionPropagationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectToHclTerraform, false)(struct!.expect),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectList",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef",
    },
    template: {
      value: cdktf.booleanToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._deletionPropagationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletionPropagationPolicy = this._deletionPropagationPolicy;
    }
    if (this._expect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expect = this._expect?.internalValue;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._deletionPropagationPolicy = undefined;
      this._expect.internalValue = undefined;
      this._file = undefined;
      this._ref.internalValue = undefined;
      this._template = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._deletionPropagationPolicy = value.deletionPropagationPolicy;
      this._expect.internalValue = value.expect;
      this._file = value.file;
      this._ref.internalValue = value.ref;
      this._template = value.template;
      this._timeout = value.timeout;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // deletion_propagation_policy - computed: false, optional: true, required: false
  private _deletionPropagationPolicy?: string; 
  public get deletionPropagationPolicy() {
    return this.getStringAttribute('deletion_propagation_policy');
  }
  public set deletionPropagationPolicy(value: string) {
    this._deletionPropagationPolicy = value;
  }
  public resetDeletionPropagationPolicy() {
    this._deletionPropagationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionPropagationPolicyInput() {
    return this._deletionPropagationPolicy;
  }

  // expect - computed: false, optional: true, required: false
  private _expect = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpectList(this, "expect", false);
  public get expect() {
    return this._expect;
  }
  public putExpect(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteExpect[] | cdktf.IResolvable) {
    this._expect.internalValue = value;
  }
  public resetExpect() {
    this._expect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectInput() {
    return this._expect.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template?: boolean | cdktf.IResolvable; 
  public get template() {
    return this.getBooleanAttribute('template');
  }
  public set template(value: boolean | cdktf.IResolvable) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Show Events indicates whether to include related events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#show_events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#show_events}
  */
  readonly showEvents?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClustersToTerraform(struct!.clusters),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    show_events: cdktf.booleanToTerraform(struct!.showEvents),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    show_events: {
      value: cdktf.booleanToHclTerraform(struct!.showEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._showEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.showEvents = this._showEvents;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._showEvents = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._showEvents = value.showEvents;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // show_events - computed: false, optional: true, required: false
  private _showEvents?: boolean | cdktf.IResolvable; 
  public get showEvents() {
    return this.getBooleanAttribute('show_events');
  }
  public set showEvents(value: boolean | cdktf.IResolvable) {
    this._showEvents = value;
  }
  public resetShowEvents() {
    this._showEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get showEventsInput() {
    return this._showEvents;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters;
  /**
  * Container in pod to get logs from else --all-containers is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#container DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#container}
  */
  readonly container?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Tail is the number of last lines to collect from pods. If omitted or zero, then the default is 10 if you use a selector, or -1 (all) if you use a pod name. This matches default behavior of 'kubectl logs'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#tail DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#tail}
  */
  readonly tail?: number;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClustersToTerraform(struct!.clusters),
    container: cdktf.stringToTerraform(struct!.container),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    tail: cdktf.numberToTerraform(struct!.tail),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters",
    },
    container: {
      value: cdktf.stringToHclTerraform(struct!.container),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tail: {
      value: cdktf.numberToHclTerraform(struct!.tail),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._container !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._tail !== undefined) {
      hasAnyValues = true;
      internalValueResult.tail = this._tail;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._container = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._tail = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._container = value.container;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._tail = value.tail;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // container - computed: false, optional: true, required: false
  private _container?: string; 
  public get container() {
    return this.getStringAttribute('container');
  }
  public set container(value: string) {
    this._container = value;
  }
  public resetContainer() {
    this._container = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // tail - computed: false, optional: true, required: false
  private _tail?: number; 
  public get tail() {
    return this.getNumberAttribute('tail');
  }
  public set tail(value: number) {
    this._tail = value;
  }
  public resetTail() {
    this._tail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tailInput() {
    return this._tail;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters;
  /**
  * Content defines a shell script (run with 'sh -c ...').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#content DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#content}
  */
  readonly content?: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for script.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClustersToTerraform(struct!.clusters),
    content: cdktf.stringToTerraform(struct!.content),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters",
    },
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._content = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._content = value.content;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep {
  /**
  * Duration is the delay used for sleeping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#duration DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#duration}
  */
  readonly duration: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleepToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleepToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition {
  /**
  * Name defines the specific condition to wait for, e.g., 'Available', 'Ready'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value defines the specific condition status to wait for, e.g., 'True', 'False'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForConditionToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForConditionToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath {
  /**
  * Path defines the json path to wait for, e.g. '{.status.phase}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#path}
  */
  readonly path: string;
  /**
  * Value defines the expected value to wait for, e.g., 'Running'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPathToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPathToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._value = value.value;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor {
  /**
  * Condition specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#condition DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#condition}
  */
  readonly condition?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition;
  /**
  * Deletion specifies parameters for waiting on a resource's deletion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion}
  */
  readonly deletion?: { [key: string]: string };
  /**
  * JsonPath specifies the json path condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#json_path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#json_path}
  */
  readonly jsonPath?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    condition: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForConditionToTerraform(struct!.condition),
    deletion: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deletion),
    json_path: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPathToTerraform(struct!.jsonPath),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    condition: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForConditionToHclTerraform(struct!.condition),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition",
    },
    deletion: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deletion),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    json_path: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPathToHclTerraform(struct!.jsonPath),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._condition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.condition = this._condition?.internalValue;
    }
    if (this._deletion !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletion = this._deletion;
    }
    if (this._jsonPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPath = this._jsonPath?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._condition.internalValue = undefined;
      this._deletion = undefined;
      this._jsonPath.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._condition.internalValue = value.condition;
      this._deletion = value.deletion;
      this._jsonPath.internalValue = value.jsonPath;
    }
  }

  // condition - computed: false, optional: true, required: false
  private _condition = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForConditionOutputReference(this, "condition");
  public get condition() {
    return this._condition;
  }
  public putCondition(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForCondition) {
    this._condition.internalValue = value;
  }
  public resetCondition() {
    this._condition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionInput() {
    return this._condition.internalValue;
  }

  // deletion - computed: false, optional: true, required: false
  private _deletion?: { [key: string]: string }; 
  public get deletion() {
    return this.getStringMapAttribute('deletion');
  }
  public set deletion(value: { [key: string]: string }) {
    this._deletion = value;
  }
  public resetDeletion() {
    this._deletion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionInput() {
    return this._deletion;
  }

  // json_path - computed: false, optional: true, required: false
  private _jsonPath = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPathOutputReference(this, "json_path");
  public get jsonPath() {
    return this._jsonPath;
  }
  public putJsonPath(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForJsonPath) {
    this._jsonPath.internalValue = value;
  }
  public resetJsonPath() {
    this._jsonPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPathInput() {
    return this._jsonPath.internalValue;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters;
  /**
  * WaitFor specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#for DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#for}
  */
  readonly for: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClustersToTerraform(struct!.clusters),
    for: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForToTerraform(struct!.for),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters",
    },
    for: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForToHclTerraform(struct!.for),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._for?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.for = this._for?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._for.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._for.internalValue = value.for;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // for - computed: false, optional: false, required: true
  private _for = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitForOutputReference(this, "for");
  public get for() {
    return this._for;
  }
  public putFor(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitFor) {
    this._for.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get forInput() {
    return this._for.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatch {
  /**
  * Command defines a command to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#command DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#command}
  */
  readonly command?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand;
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Delete represents a deletion operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#delete DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#delete}
  */
  readonly delete?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete;
  /**
  * Describe determines the resource describe collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#describe DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#describe}
  */
  readonly describe?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe;
  /**
  * Description contains a description of the operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#description DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#description}
  */
  readonly description?: string;
  /**
  * Events determines the events collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#events}
  */
  readonly events?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents;
  /**
  * Get determines the resource get collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#get DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#get}
  */
  readonly get?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet;
  /**
  * PodLogs determines the pod logs collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#pod_logs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#pod_logs}
  */
  readonly podLogs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs;
  /**
  * Script defines a script to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#script DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#script}
  */
  readonly script?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript;
  /**
  * Sleep defines zzzz.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#sleep DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#sleep}
  */
  readonly sleep?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep;
  /**
  * Wait determines the resource wait collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#wait DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#wait}
  */
  readonly wait?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandToTerraform(struct!.command),
    compiler: cdktf.stringToTerraform(struct!.compiler),
    delete: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteToTerraform(struct!.delete),
    describe: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeToTerraform(struct!.describe),
    description: cdktf.stringToTerraform(struct!.description),
    events: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsToTerraform(struct!.events),
    get: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetToTerraform(struct!.get),
    pod_logs: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsToTerraform(struct!.podLogs),
    script: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptToTerraform(struct!.script),
    sleep: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleepToTerraform(struct!.sleep),
    wait: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitToTerraform(struct!.wait),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandToHclTerraform(struct!.command),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand",
    },
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteToHclTerraform(struct!.delete),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete",
    },
    describe: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeToHclTerraform(struct!.describe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    events: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsToHclTerraform(struct!.events),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents",
    },
    get: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetToHclTerraform(struct!.get),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet",
    },
    pod_logs: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsToHclTerraform(struct!.podLogs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs",
    },
    script: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptToHclTerraform(struct!.script),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript",
    },
    sleep: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleepToHclTerraform(struct!.sleep),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep",
    },
    wait: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitToHclTerraform(struct!.wait),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command?.internalValue;
    }
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._delete?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete?.internalValue;
    }
    if (this._describe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.describe = this._describe?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._events?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.events = this._events?.internalValue;
    }
    if (this._get?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.get = this._get?.internalValue;
    }
    if (this._podLogs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podLogs = this._podLogs?.internalValue;
    }
    if (this._script?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.script = this._script?.internalValue;
    }
    if (this._sleep?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sleep = this._sleep?.internalValue;
    }
    if (this._wait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wait = this._wait?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command.internalValue = undefined;
      this._compiler = undefined;
      this._delete.internalValue = undefined;
      this._describe.internalValue = undefined;
      this._description = undefined;
      this._events.internalValue = undefined;
      this._get.internalValue = undefined;
      this._podLogs.internalValue = undefined;
      this._script.internalValue = undefined;
      this._sleep.internalValue = undefined;
      this._wait.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command.internalValue = value.command;
      this._compiler = value.compiler;
      this._delete.internalValue = value.delete;
      this._describe.internalValue = value.describe;
      this._description = value.description;
      this._events.internalValue = value.events;
      this._get.internalValue = value.get;
      this._podLogs.internalValue = value.podLogs;
      this._script.internalValue = value.script;
      this._sleep.internalValue = value.sleep;
      this._wait.internalValue = value.wait;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommandOutputReference(this, "command");
  public get command() {
    return this._command;
  }
  public putCommand(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchCommand) {
    this._command.internalValue = value;
  }
  public resetCommand() {
    this._command.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command.internalValue;
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // delete - computed: false, optional: true, required: false
  private _delete = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDeleteOutputReference(this, "delete");
  public get delete() {
    return this._delete;
  }
  public putDelete(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDelete) {
    this._delete.internalValue = value;
  }
  public resetDelete() {
    this._delete.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete.internalValue;
  }

  // describe - computed: false, optional: true, required: false
  private _describe = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribeOutputReference(this, "describe");
  public get describe() {
    return this._describe;
  }
  public putDescribe(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchDescribe) {
    this._describe.internalValue = value;
  }
  public resetDescribe() {
    this._describe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get describeInput() {
    return this._describe.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // events - computed: false, optional: true, required: false
  private _events = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEventsOutputReference(this, "events");
  public get events() {
    return this._events;
  }
  public putEvents(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchEvents) {
    this._events.internalValue = value;
  }
  public resetEvents() {
    this._events.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventsInput() {
    return this._events.internalValue;
  }

  // get - computed: false, optional: true, required: false
  private _get = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGetOutputReference(this, "get");
  public get get() {
    return this._get;
  }
  public putGet(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchGet) {
    this._get.internalValue = value;
  }
  public resetGet() {
    this._get.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get getInput() {
    return this._get.internalValue;
  }

  // pod_logs - computed: false, optional: true, required: false
  private _podLogs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogsOutputReference(this, "pod_logs");
  public get podLogs() {
    return this._podLogs;
  }
  public putPodLogs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchPodLogs) {
    this._podLogs.internalValue = value;
  }
  public resetPodLogs() {
    this._podLogs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podLogsInput() {
    return this._podLogs.internalValue;
  }

  // script - computed: false, optional: true, required: false
  private _script = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScriptOutputReference(this, "script");
  public get script() {
    return this._script;
  }
  public putScript(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchScript) {
    this._script.internalValue = value;
  }
  public resetScript() {
    this._script.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scriptInput() {
    return this._script.internalValue;
  }

  // sleep - computed: false, optional: true, required: false
  private _sleep = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleepOutputReference(this, "sleep");
  public get sleep() {
    return this._sleep;
  }
  public putSleep(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchSleep) {
    this._sleep.internalValue = value;
  }
  public resetSleep() {
    this._sleep.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sleepInput() {
    return this._sleep.internalValue;
  }

  // wait - computed: false, optional: true, required: false
  private _wait = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWaitOutputReference(this, "wait");
  public get wait() {
    return this._wait;
  }
  public putWait(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchWait) {
    this._wait.internalValue = value;
  }
  public resetWait() {
    this._wait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get waitInput() {
    return this._wait.internalValue;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatch[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecCatchOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenarios {
  /**
  * Bindings defines binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings[] | cdktf.IResolvable;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenarios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsToTerraform, false)(struct!.bindings),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenarios | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenarios | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenarios | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenarios[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecScenariosOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand {
  /**
  * Args is the command arguments.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#args DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#args}
  */
  readonly args?: string[];
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters;
  /**
  * Entrypoint is the command entry point to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#entrypoint DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#entrypoint}
  */
  readonly entrypoint: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for command.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClustersToTerraform(struct!.clusters),
    entrypoint: cdktf.stringToTerraform(struct!.entrypoint),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters",
    },
    entrypoint: {
      value: cdktf.stringToHclTerraform(struct!.entrypoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._entrypoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.entrypoint = this._entrypoint;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._entrypoint = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._entrypoint = value.entrypoint;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // entrypoint - computed: false, optional: false, required: true
  private _entrypoint?: string; 
  public get entrypoint() {
    return this.getStringAttribute('entrypoint');
  }
  public set entrypoint(value: string) {
    this._entrypoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get entrypointInput() {
    return this._entrypoint;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect {
  /**
  * Check defines the verification statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check: { [key: string]: string };
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._check = undefined;
      this._match = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._check = value.check;
      this._match = value.match;
    }
  }

  // check - computed: false, optional: false, required: true
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Label selector to match objects to delete
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#labels DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRefToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    kind: cdktf.stringToTerraform(struct!.kind),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRefToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._kind = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._kind = value.kind;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings[] | cdktf.IResolvable;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters;
  /**
  * DeletionPropagationPolicy decides if a deletion will propagate to the dependents of the object, and how the garbage collector will handle the propagation. Overrides the deletion propagation policy set in the Configuration, the Test and the TestStep.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion_propagation_policy DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion_propagation_policy}
  */
  readonly deletionPropagationPolicy?: string;
  /**
  * Expect defines a list of matched checks to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#expect DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#expect}
  */
  readonly expect?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect[] | cdktf.IResolvable;
  /**
  * File is the path to the referenced file. This can be a direct path to a file or an expression that matches multiple files, such as 'manifest/*.yaml' for all YAML files within the 'manifest' directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#file DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#file}
  */
  readonly file?: string;
  /**
  * Ref determines objects to be deleted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#ref DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#ref}
  */
  readonly ref?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef;
  /**
  * Template determines whether resources should be considered for templating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#template DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#template}
  */
  readonly template?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsToTerraform, false)(struct!.bindings),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClustersToTerraform(struct!.clusters),
    deletion_propagation_policy: cdktf.stringToTerraform(struct!.deletionPropagationPolicy),
    expect: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectToTerraform, false)(struct!.expect),
    file: cdktf.stringToTerraform(struct!.file),
    ref: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRefToTerraform(struct!.ref),
    template: cdktf.booleanToTerraform(struct!.template),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsList",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters",
    },
    deletion_propagation_policy: {
      value: cdktf.stringToHclTerraform(struct!.deletionPropagationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectToHclTerraform, false)(struct!.expect),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectList",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef",
    },
    template: {
      value: cdktf.booleanToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._deletionPropagationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletionPropagationPolicy = this._deletionPropagationPolicy;
    }
    if (this._expect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expect = this._expect?.internalValue;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._deletionPropagationPolicy = undefined;
      this._expect.internalValue = undefined;
      this._file = undefined;
      this._ref.internalValue = undefined;
      this._template = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._deletionPropagationPolicy = value.deletionPropagationPolicy;
      this._expect.internalValue = value.expect;
      this._file = value.file;
      this._ref.internalValue = value.ref;
      this._template = value.template;
      this._timeout = value.timeout;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // deletion_propagation_policy - computed: false, optional: true, required: false
  private _deletionPropagationPolicy?: string; 
  public get deletionPropagationPolicy() {
    return this.getStringAttribute('deletion_propagation_policy');
  }
  public set deletionPropagationPolicy(value: string) {
    this._deletionPropagationPolicy = value;
  }
  public resetDeletionPropagationPolicy() {
    this._deletionPropagationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionPropagationPolicyInput() {
    return this._deletionPropagationPolicy;
  }

  // expect - computed: false, optional: true, required: false
  private _expect = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpectList(this, "expect", false);
  public get expect() {
    return this._expect;
  }
  public putExpect(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteExpect[] | cdktf.IResolvable) {
    this._expect.internalValue = value;
  }
  public resetExpect() {
    this._expect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectInput() {
    return this._expect.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template?: boolean | cdktf.IResolvable; 
  public get template() {
    return this.getBooleanAttribute('template');
  }
  public set template(value: boolean | cdktf.IResolvable) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Show Events indicates whether to include related events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#show_events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#show_events}
  */
  readonly showEvents?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClustersToTerraform(struct!.clusters),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    show_events: cdktf.booleanToTerraform(struct!.showEvents),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    show_events: {
      value: cdktf.booleanToHclTerraform(struct!.showEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._showEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.showEvents = this._showEvents;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._showEvents = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._showEvents = value.showEvents;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // show_events - computed: false, optional: true, required: false
  private _showEvents?: boolean | cdktf.IResolvable; 
  public get showEvents() {
    return this.getBooleanAttribute('show_events');
  }
  public set showEvents(value: boolean | cdktf.IResolvable) {
    this._showEvents = value;
  }
  public resetShowEvents() {
    this._showEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get showEventsInput() {
    return this._showEvents;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters;
  /**
  * Container in pod to get logs from else --all-containers is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#container DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#container}
  */
  readonly container?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Tail is the number of last lines to collect from pods. If omitted or zero, then the default is 10 if you use a selector, or -1 (all) if you use a pod name. This matches default behavior of 'kubectl logs'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#tail DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#tail}
  */
  readonly tail?: number;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClustersToTerraform(struct!.clusters),
    container: cdktf.stringToTerraform(struct!.container),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    tail: cdktf.numberToTerraform(struct!.tail),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters",
    },
    container: {
      value: cdktf.stringToHclTerraform(struct!.container),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tail: {
      value: cdktf.numberToHclTerraform(struct!.tail),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._container !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._tail !== undefined) {
      hasAnyValues = true;
      internalValueResult.tail = this._tail;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._container = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._tail = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._container = value.container;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._tail = value.tail;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // container - computed: false, optional: true, required: false
  private _container?: string; 
  public get container() {
    return this.getStringAttribute('container');
  }
  public set container(value: string) {
    this._container = value;
  }
  public resetContainer() {
    this._container = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // tail - computed: false, optional: true, required: false
  private _tail?: number; 
  public get tail() {
    return this.getNumberAttribute('tail');
  }
  public set tail(value: number) {
    this._tail = value;
  }
  public resetTail() {
    this._tail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tailInput() {
    return this._tail;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters;
  /**
  * Content defines a shell script (run with 'sh -c ...').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#content DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#content}
  */
  readonly content?: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for script.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClustersToTerraform(struct!.clusters),
    content: cdktf.stringToTerraform(struct!.content),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters",
    },
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._content = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._content = value.content;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep {
  /**
  * Duration is the delay used for sleeping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#duration DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#duration}
  */
  readonly duration: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleepToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleepToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition {
  /**
  * Name defines the specific condition to wait for, e.g., 'Available', 'Ready'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value defines the specific condition status to wait for, e.g., 'True', 'False'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForConditionToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForConditionToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath {
  /**
  * Path defines the json path to wait for, e.g. '{.status.phase}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#path}
  */
  readonly path: string;
  /**
  * Value defines the expected value to wait for, e.g., 'Running'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPathToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPathToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._value = value.value;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor {
  /**
  * Condition specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#condition DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#condition}
  */
  readonly condition?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition;
  /**
  * Deletion specifies parameters for waiting on a resource's deletion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion}
  */
  readonly deletion?: { [key: string]: string };
  /**
  * JsonPath specifies the json path condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#json_path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#json_path}
  */
  readonly jsonPath?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    condition: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForConditionToTerraform(struct!.condition),
    deletion: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deletion),
    json_path: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPathToTerraform(struct!.jsonPath),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    condition: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForConditionToHclTerraform(struct!.condition),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition",
    },
    deletion: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deletion),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    json_path: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPathToHclTerraform(struct!.jsonPath),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._condition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.condition = this._condition?.internalValue;
    }
    if (this._deletion !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletion = this._deletion;
    }
    if (this._jsonPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPath = this._jsonPath?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._condition.internalValue = undefined;
      this._deletion = undefined;
      this._jsonPath.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._condition.internalValue = value.condition;
      this._deletion = value.deletion;
      this._jsonPath.internalValue = value.jsonPath;
    }
  }

  // condition - computed: false, optional: true, required: false
  private _condition = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForConditionOutputReference(this, "condition");
  public get condition() {
    return this._condition;
  }
  public putCondition(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForCondition) {
    this._condition.internalValue = value;
  }
  public resetCondition() {
    this._condition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionInput() {
    return this._condition.internalValue;
  }

  // deletion - computed: false, optional: true, required: false
  private _deletion?: { [key: string]: string }; 
  public get deletion() {
    return this.getStringMapAttribute('deletion');
  }
  public set deletion(value: { [key: string]: string }) {
    this._deletion = value;
  }
  public resetDeletion() {
    this._deletion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionInput() {
    return this._deletion;
  }

  // json_path - computed: false, optional: true, required: false
  private _jsonPath = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPathOutputReference(this, "json_path");
  public get jsonPath() {
    return this._jsonPath;
  }
  public putJsonPath(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForJsonPath) {
    this._jsonPath.internalValue = value;
  }
  public resetJsonPath() {
    this._jsonPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPathInput() {
    return this._jsonPath.internalValue;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters;
  /**
  * WaitFor specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#for DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#for}
  */
  readonly for: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClustersToTerraform(struct!.clusters),
    for: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForToTerraform(struct!.for),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters",
    },
    for: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForToHclTerraform(struct!.for),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._for?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.for = this._for?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._for.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._for.internalValue = value.for;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // for - computed: false, optional: false, required: true
  private _for = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitForOutputReference(this, "for");
  public get for() {
    return this._for;
  }
  public putFor(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitFor) {
    this._for.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get forInput() {
    return this._for.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatch {
  /**
  * Command defines a command to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#command DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#command}
  */
  readonly command?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand;
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Delete represents a deletion operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#delete DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#delete}
  */
  readonly delete?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete;
  /**
  * Describe determines the resource describe collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#describe DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#describe}
  */
  readonly describe?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe;
  /**
  * Description contains a description of the operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#description DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#description}
  */
  readonly description?: string;
  /**
  * Events determines the events collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#events}
  */
  readonly events?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents;
  /**
  * Get determines the resource get collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#get DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#get}
  */
  readonly get?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet;
  /**
  * PodLogs determines the pod logs collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#pod_logs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#pod_logs}
  */
  readonly podLogs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs;
  /**
  * Script defines a script to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#script DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#script}
  */
  readonly script?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript;
  /**
  * Sleep defines zzzz.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#sleep DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#sleep}
  */
  readonly sleep?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep;
  /**
  * Wait determines the resource wait collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#wait DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#wait}
  */
  readonly wait?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandToTerraform(struct!.command),
    compiler: cdktf.stringToTerraform(struct!.compiler),
    delete: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteToTerraform(struct!.delete),
    describe: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeToTerraform(struct!.describe),
    description: cdktf.stringToTerraform(struct!.description),
    events: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsToTerraform(struct!.events),
    get: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetToTerraform(struct!.get),
    pod_logs: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsToTerraform(struct!.podLogs),
    script: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptToTerraform(struct!.script),
    sleep: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleepToTerraform(struct!.sleep),
    wait: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitToTerraform(struct!.wait),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandToHclTerraform(struct!.command),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand",
    },
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteToHclTerraform(struct!.delete),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete",
    },
    describe: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeToHclTerraform(struct!.describe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    events: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsToHclTerraform(struct!.events),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents",
    },
    get: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetToHclTerraform(struct!.get),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet",
    },
    pod_logs: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsToHclTerraform(struct!.podLogs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs",
    },
    script: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptToHclTerraform(struct!.script),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript",
    },
    sleep: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleepToHclTerraform(struct!.sleep),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep",
    },
    wait: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitToHclTerraform(struct!.wait),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command?.internalValue;
    }
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._delete?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete?.internalValue;
    }
    if (this._describe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.describe = this._describe?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._events?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.events = this._events?.internalValue;
    }
    if (this._get?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.get = this._get?.internalValue;
    }
    if (this._podLogs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podLogs = this._podLogs?.internalValue;
    }
    if (this._script?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.script = this._script?.internalValue;
    }
    if (this._sleep?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sleep = this._sleep?.internalValue;
    }
    if (this._wait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wait = this._wait?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command.internalValue = undefined;
      this._compiler = undefined;
      this._delete.internalValue = undefined;
      this._describe.internalValue = undefined;
      this._description = undefined;
      this._events.internalValue = undefined;
      this._get.internalValue = undefined;
      this._podLogs.internalValue = undefined;
      this._script.internalValue = undefined;
      this._sleep.internalValue = undefined;
      this._wait.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command.internalValue = value.command;
      this._compiler = value.compiler;
      this._delete.internalValue = value.delete;
      this._describe.internalValue = value.describe;
      this._description = value.description;
      this._events.internalValue = value.events;
      this._get.internalValue = value.get;
      this._podLogs.internalValue = value.podLogs;
      this._script.internalValue = value.script;
      this._sleep.internalValue = value.sleep;
      this._wait.internalValue = value.wait;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommandOutputReference(this, "command");
  public get command() {
    return this._command;
  }
  public putCommand(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchCommand) {
    this._command.internalValue = value;
  }
  public resetCommand() {
    this._command.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command.internalValue;
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // delete - computed: false, optional: true, required: false
  private _delete = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDeleteOutputReference(this, "delete");
  public get delete() {
    return this._delete;
  }
  public putDelete(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDelete) {
    this._delete.internalValue = value;
  }
  public resetDelete() {
    this._delete.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete.internalValue;
  }

  // describe - computed: false, optional: true, required: false
  private _describe = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribeOutputReference(this, "describe");
  public get describe() {
    return this._describe;
  }
  public putDescribe(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchDescribe) {
    this._describe.internalValue = value;
  }
  public resetDescribe() {
    this._describe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get describeInput() {
    return this._describe.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // events - computed: false, optional: true, required: false
  private _events = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEventsOutputReference(this, "events");
  public get events() {
    return this._events;
  }
  public putEvents(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchEvents) {
    this._events.internalValue = value;
  }
  public resetEvents() {
    this._events.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventsInput() {
    return this._events.internalValue;
  }

  // get - computed: false, optional: true, required: false
  private _get = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGetOutputReference(this, "get");
  public get get() {
    return this._get;
  }
  public putGet(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchGet) {
    this._get.internalValue = value;
  }
  public resetGet() {
    this._get.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get getInput() {
    return this._get.internalValue;
  }

  // pod_logs - computed: false, optional: true, required: false
  private _podLogs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogsOutputReference(this, "pod_logs");
  public get podLogs() {
    return this._podLogs;
  }
  public putPodLogs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchPodLogs) {
    this._podLogs.internalValue = value;
  }
  public resetPodLogs() {
    this._podLogs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podLogsInput() {
    return this._podLogs.internalValue;
  }

  // script - computed: false, optional: true, required: false
  private _script = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScriptOutputReference(this, "script");
  public get script() {
    return this._script;
  }
  public putScript(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchScript) {
    this._script.internalValue = value;
  }
  public resetScript() {
    this._script.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scriptInput() {
    return this._script.internalValue;
  }

  // sleep - computed: false, optional: true, required: false
  private _sleep = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleepOutputReference(this, "sleep");
  public get sleep() {
    return this._sleep;
  }
  public putSleep(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchSleep) {
    this._sleep.internalValue = value;
  }
  public resetSleep() {
    this._sleep.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sleepInput() {
    return this._sleep.internalValue;
  }

  // wait - computed: false, optional: true, required: false
  private _wait = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWaitOutputReference(this, "wait");
  public get wait() {
    return this._wait;
  }
  public putWait(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchWait) {
    this._wait.internalValue = value;
  }
  public resetWait() {
    this._wait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get waitInput() {
    return this._wait.internalValue;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatch[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCatchOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand {
  /**
  * Args is the command arguments.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#args DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#args}
  */
  readonly args?: string[];
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters;
  /**
  * Entrypoint is the command entry point to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#entrypoint DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#entrypoint}
  */
  readonly entrypoint: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for command.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClustersToTerraform(struct!.clusters),
    entrypoint: cdktf.stringToTerraform(struct!.entrypoint),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters",
    },
    entrypoint: {
      value: cdktf.stringToHclTerraform(struct!.entrypoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._entrypoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.entrypoint = this._entrypoint;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._entrypoint = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._entrypoint = value.entrypoint;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // entrypoint - computed: false, optional: false, required: true
  private _entrypoint?: string; 
  public get entrypoint() {
    return this.getStringAttribute('entrypoint');
  }
  public set entrypoint(value: string) {
    this._entrypoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get entrypointInput() {
    return this._entrypoint;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect {
  /**
  * Check defines the verification statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check: { [key: string]: string };
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._check = undefined;
      this._match = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._check = value.check;
      this._match = value.match;
    }
  }

  // check - computed: false, optional: false, required: true
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Label selector to match objects to delete
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#labels DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRefToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    kind: cdktf.stringToTerraform(struct!.kind),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRefToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._kind = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._kind = value.kind;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings[] | cdktf.IResolvable;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters;
  /**
  * DeletionPropagationPolicy decides if a deletion will propagate to the dependents of the object, and how the garbage collector will handle the propagation. Overrides the deletion propagation policy set in the Configuration, the Test and the TestStep.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion_propagation_policy DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion_propagation_policy}
  */
  readonly deletionPropagationPolicy?: string;
  /**
  * Expect defines a list of matched checks to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#expect DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#expect}
  */
  readonly expect?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect[] | cdktf.IResolvable;
  /**
  * File is the path to the referenced file. This can be a direct path to a file or an expression that matches multiple files, such as 'manifest/*.yaml' for all YAML files within the 'manifest' directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#file DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#file}
  */
  readonly file?: string;
  /**
  * Ref determines objects to be deleted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#ref DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#ref}
  */
  readonly ref?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef;
  /**
  * Template determines whether resources should be considered for templating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#template DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#template}
  */
  readonly template?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsToTerraform, false)(struct!.bindings),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClustersToTerraform(struct!.clusters),
    deletion_propagation_policy: cdktf.stringToTerraform(struct!.deletionPropagationPolicy),
    expect: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectToTerraform, false)(struct!.expect),
    file: cdktf.stringToTerraform(struct!.file),
    ref: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRefToTerraform(struct!.ref),
    template: cdktf.booleanToTerraform(struct!.template),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsList",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters",
    },
    deletion_propagation_policy: {
      value: cdktf.stringToHclTerraform(struct!.deletionPropagationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectToHclTerraform, false)(struct!.expect),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectList",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef",
    },
    template: {
      value: cdktf.booleanToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._deletionPropagationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletionPropagationPolicy = this._deletionPropagationPolicy;
    }
    if (this._expect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expect = this._expect?.internalValue;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._deletionPropagationPolicy = undefined;
      this._expect.internalValue = undefined;
      this._file = undefined;
      this._ref.internalValue = undefined;
      this._template = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._deletionPropagationPolicy = value.deletionPropagationPolicy;
      this._expect.internalValue = value.expect;
      this._file = value.file;
      this._ref.internalValue = value.ref;
      this._template = value.template;
      this._timeout = value.timeout;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // deletion_propagation_policy - computed: false, optional: true, required: false
  private _deletionPropagationPolicy?: string; 
  public get deletionPropagationPolicy() {
    return this.getStringAttribute('deletion_propagation_policy');
  }
  public set deletionPropagationPolicy(value: string) {
    this._deletionPropagationPolicy = value;
  }
  public resetDeletionPropagationPolicy() {
    this._deletionPropagationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionPropagationPolicyInput() {
    return this._deletionPropagationPolicy;
  }

  // expect - computed: false, optional: true, required: false
  private _expect = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpectList(this, "expect", false);
  public get expect() {
    return this._expect;
  }
  public putExpect(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteExpect[] | cdktf.IResolvable) {
    this._expect.internalValue = value;
  }
  public resetExpect() {
    this._expect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectInput() {
    return this._expect.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template?: boolean | cdktf.IResolvable; 
  public get template() {
    return this.getBooleanAttribute('template');
  }
  public set template(value: boolean | cdktf.IResolvable) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Show Events indicates whether to include related events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#show_events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#show_events}
  */
  readonly showEvents?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClustersToTerraform(struct!.clusters),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    show_events: cdktf.booleanToTerraform(struct!.showEvents),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    show_events: {
      value: cdktf.booleanToHclTerraform(struct!.showEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._showEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.showEvents = this._showEvents;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._showEvents = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._showEvents = value.showEvents;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // show_events - computed: false, optional: true, required: false
  private _showEvents?: boolean | cdktf.IResolvable; 
  public get showEvents() {
    return this.getBooleanAttribute('show_events');
  }
  public set showEvents(value: boolean | cdktf.IResolvable) {
    this._showEvents = value;
  }
  public resetShowEvents() {
    this._showEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get showEventsInput() {
    return this._showEvents;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters;
  /**
  * Container in pod to get logs from else --all-containers is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#container DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#container}
  */
  readonly container?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Tail is the number of last lines to collect from pods. If omitted or zero, then the default is 10 if you use a selector, or -1 (all) if you use a pod name. This matches default behavior of 'kubectl logs'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#tail DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#tail}
  */
  readonly tail?: number;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClustersToTerraform(struct!.clusters),
    container: cdktf.stringToTerraform(struct!.container),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    tail: cdktf.numberToTerraform(struct!.tail),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters",
    },
    container: {
      value: cdktf.stringToHclTerraform(struct!.container),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tail: {
      value: cdktf.numberToHclTerraform(struct!.tail),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._container !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._tail !== undefined) {
      hasAnyValues = true;
      internalValueResult.tail = this._tail;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._container = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._tail = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._container = value.container;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._tail = value.tail;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // container - computed: false, optional: true, required: false
  private _container?: string; 
  public get container() {
    return this.getStringAttribute('container');
  }
  public set container(value: string) {
    this._container = value;
  }
  public resetContainer() {
    this._container = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // tail - computed: false, optional: true, required: false
  private _tail?: number; 
  public get tail() {
    return this.getNumberAttribute('tail');
  }
  public set tail(value: number) {
    this._tail = value;
  }
  public resetTail() {
    this._tail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tailInput() {
    return this._tail;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters;
  /**
  * Content defines a shell script (run with 'sh -c ...').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#content DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#content}
  */
  readonly content?: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for script.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClustersToTerraform(struct!.clusters),
    content: cdktf.stringToTerraform(struct!.content),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters",
    },
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._content = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._content = value.content;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep {
  /**
  * Duration is the delay used for sleeping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#duration DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#duration}
  */
  readonly duration: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleepToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleepToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition {
  /**
  * Name defines the specific condition to wait for, e.g., 'Available', 'Ready'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value defines the specific condition status to wait for, e.g., 'True', 'False'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForConditionToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForConditionToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath {
  /**
  * Path defines the json path to wait for, e.g. '{.status.phase}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#path}
  */
  readonly path: string;
  /**
  * Value defines the expected value to wait for, e.g., 'Running'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPathToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPathToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._value = value.value;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor {
  /**
  * Condition specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#condition DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#condition}
  */
  readonly condition?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition;
  /**
  * Deletion specifies parameters for waiting on a resource's deletion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion}
  */
  readonly deletion?: { [key: string]: string };
  /**
  * JsonPath specifies the json path condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#json_path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#json_path}
  */
  readonly jsonPath?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    condition: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForConditionToTerraform(struct!.condition),
    deletion: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deletion),
    json_path: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPathToTerraform(struct!.jsonPath),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    condition: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForConditionToHclTerraform(struct!.condition),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition",
    },
    deletion: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deletion),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    json_path: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPathToHclTerraform(struct!.jsonPath),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._condition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.condition = this._condition?.internalValue;
    }
    if (this._deletion !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletion = this._deletion;
    }
    if (this._jsonPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPath = this._jsonPath?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._condition.internalValue = undefined;
      this._deletion = undefined;
      this._jsonPath.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._condition.internalValue = value.condition;
      this._deletion = value.deletion;
      this._jsonPath.internalValue = value.jsonPath;
    }
  }

  // condition - computed: false, optional: true, required: false
  private _condition = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForConditionOutputReference(this, "condition");
  public get condition() {
    return this._condition;
  }
  public putCondition(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForCondition) {
    this._condition.internalValue = value;
  }
  public resetCondition() {
    this._condition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionInput() {
    return this._condition.internalValue;
  }

  // deletion - computed: false, optional: true, required: false
  private _deletion?: { [key: string]: string }; 
  public get deletion() {
    return this.getStringMapAttribute('deletion');
  }
  public set deletion(value: { [key: string]: string }) {
    this._deletion = value;
  }
  public resetDeletion() {
    this._deletion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionInput() {
    return this._deletion;
  }

  // json_path - computed: false, optional: true, required: false
  private _jsonPath = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPathOutputReference(this, "json_path");
  public get jsonPath() {
    return this._jsonPath;
  }
  public putJsonPath(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForJsonPath) {
    this._jsonPath.internalValue = value;
  }
  public resetJsonPath() {
    this._jsonPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPathInput() {
    return this._jsonPath.internalValue;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters;
  /**
  * WaitFor specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#for DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#for}
  */
  readonly for: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClustersToTerraform(struct!.clusters),
    for: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForToTerraform(struct!.for),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters",
    },
    for: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForToHclTerraform(struct!.for),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._for?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.for = this._for?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._for.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._for.internalValue = value.for;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // for - computed: false, optional: false, required: true
  private _for = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitForOutputReference(this, "for");
  public get for() {
    return this._for;
  }
  public putFor(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitFor) {
    this._for.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get forInput() {
    return this._for.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanup {
  /**
  * Command defines a command to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#command DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#command}
  */
  readonly command?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand;
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Delete represents a deletion operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#delete DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#delete}
  */
  readonly delete?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete;
  /**
  * Describe determines the resource describe collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#describe DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#describe}
  */
  readonly describe?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe;
  /**
  * Description contains a description of the operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#description DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#description}
  */
  readonly description?: string;
  /**
  * Events determines the events collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#events}
  */
  readonly events?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents;
  /**
  * Get determines the resource get collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#get DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#get}
  */
  readonly get?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet;
  /**
  * PodLogs determines the pod logs collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#pod_logs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#pod_logs}
  */
  readonly podLogs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs;
  /**
  * Script defines a script to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#script DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#script}
  */
  readonly script?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript;
  /**
  * Sleep defines zzzz.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#sleep DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#sleep}
  */
  readonly sleep?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep;
  /**
  * Wait determines the resource wait collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#wait DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#wait}
  */
  readonly wait?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandToTerraform(struct!.command),
    compiler: cdktf.stringToTerraform(struct!.compiler),
    delete: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteToTerraform(struct!.delete),
    describe: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeToTerraform(struct!.describe),
    description: cdktf.stringToTerraform(struct!.description),
    events: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsToTerraform(struct!.events),
    get: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetToTerraform(struct!.get),
    pod_logs: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsToTerraform(struct!.podLogs),
    script: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptToTerraform(struct!.script),
    sleep: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleepToTerraform(struct!.sleep),
    wait: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitToTerraform(struct!.wait),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanup | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandToHclTerraform(struct!.command),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand",
    },
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteToHclTerraform(struct!.delete),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete",
    },
    describe: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeToHclTerraform(struct!.describe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    events: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsToHclTerraform(struct!.events),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents",
    },
    get: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetToHclTerraform(struct!.get),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet",
    },
    pod_logs: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsToHclTerraform(struct!.podLogs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs",
    },
    script: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptToHclTerraform(struct!.script),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript",
    },
    sleep: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleepToHclTerraform(struct!.sleep),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep",
    },
    wait: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitToHclTerraform(struct!.wait),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanup | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command?.internalValue;
    }
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._delete?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete?.internalValue;
    }
    if (this._describe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.describe = this._describe?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._events?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.events = this._events?.internalValue;
    }
    if (this._get?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.get = this._get?.internalValue;
    }
    if (this._podLogs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podLogs = this._podLogs?.internalValue;
    }
    if (this._script?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.script = this._script?.internalValue;
    }
    if (this._sleep?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sleep = this._sleep?.internalValue;
    }
    if (this._wait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wait = this._wait?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanup | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command.internalValue = undefined;
      this._compiler = undefined;
      this._delete.internalValue = undefined;
      this._describe.internalValue = undefined;
      this._description = undefined;
      this._events.internalValue = undefined;
      this._get.internalValue = undefined;
      this._podLogs.internalValue = undefined;
      this._script.internalValue = undefined;
      this._sleep.internalValue = undefined;
      this._wait.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command.internalValue = value.command;
      this._compiler = value.compiler;
      this._delete.internalValue = value.delete;
      this._describe.internalValue = value.describe;
      this._description = value.description;
      this._events.internalValue = value.events;
      this._get.internalValue = value.get;
      this._podLogs.internalValue = value.podLogs;
      this._script.internalValue = value.script;
      this._sleep.internalValue = value.sleep;
      this._wait.internalValue = value.wait;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommandOutputReference(this, "command");
  public get command() {
    return this._command;
  }
  public putCommand(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupCommand) {
    this._command.internalValue = value;
  }
  public resetCommand() {
    this._command.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command.internalValue;
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // delete - computed: false, optional: true, required: false
  private _delete = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDeleteOutputReference(this, "delete");
  public get delete() {
    return this._delete;
  }
  public putDelete(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDelete) {
    this._delete.internalValue = value;
  }
  public resetDelete() {
    this._delete.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete.internalValue;
  }

  // describe - computed: false, optional: true, required: false
  private _describe = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribeOutputReference(this, "describe");
  public get describe() {
    return this._describe;
  }
  public putDescribe(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupDescribe) {
    this._describe.internalValue = value;
  }
  public resetDescribe() {
    this._describe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get describeInput() {
    return this._describe.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // events - computed: false, optional: true, required: false
  private _events = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEventsOutputReference(this, "events");
  public get events() {
    return this._events;
  }
  public putEvents(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupEvents) {
    this._events.internalValue = value;
  }
  public resetEvents() {
    this._events.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventsInput() {
    return this._events.internalValue;
  }

  // get - computed: false, optional: true, required: false
  private _get = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGetOutputReference(this, "get");
  public get get() {
    return this._get;
  }
  public putGet(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupGet) {
    this._get.internalValue = value;
  }
  public resetGet() {
    this._get.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get getInput() {
    return this._get.internalValue;
  }

  // pod_logs - computed: false, optional: true, required: false
  private _podLogs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogsOutputReference(this, "pod_logs");
  public get podLogs() {
    return this._podLogs;
  }
  public putPodLogs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupPodLogs) {
    this._podLogs.internalValue = value;
  }
  public resetPodLogs() {
    this._podLogs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podLogsInput() {
    return this._podLogs.internalValue;
  }

  // script - computed: false, optional: true, required: false
  private _script = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScriptOutputReference(this, "script");
  public get script() {
    return this._script;
  }
  public putScript(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupScript) {
    this._script.internalValue = value;
  }
  public resetScript() {
    this._script.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scriptInput() {
    return this._script.internalValue;
  }

  // sleep - computed: false, optional: true, required: false
  private _sleep = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleepOutputReference(this, "sleep");
  public get sleep() {
    return this._sleep;
  }
  public putSleep(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupSleep) {
    this._sleep.internalValue = value;
  }
  public resetSleep() {
    this._sleep.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sleepInput() {
    return this._sleep.internalValue;
  }

  // wait - computed: false, optional: true, required: false
  private _wait = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWaitOutputReference(this, "wait");
  public get wait() {
    return this._wait;
  }
  public putWait(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupWait) {
    this._wait.internalValue = value;
  }
  public resetWait() {
    this._wait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get waitInput() {
    return this._wait.internalValue;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanup[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsCleanupOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand {
  /**
  * Args is the command arguments.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#args DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#args}
  */
  readonly args?: string[];
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters;
  /**
  * Entrypoint is the command entry point to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#entrypoint DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#entrypoint}
  */
  readonly entrypoint: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for command.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClustersToTerraform(struct!.clusters),
    entrypoint: cdktf.stringToTerraform(struct!.entrypoint),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters",
    },
    entrypoint: {
      value: cdktf.stringToHclTerraform(struct!.entrypoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._entrypoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.entrypoint = this._entrypoint;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._entrypoint = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._entrypoint = value.entrypoint;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // entrypoint - computed: false, optional: false, required: true
  private _entrypoint?: string; 
  public get entrypoint() {
    return this.getStringAttribute('entrypoint');
  }
  public set entrypoint(value: string) {
    this._entrypoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get entrypointInput() {
    return this._entrypoint;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect {
  /**
  * Check defines the verification statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check: { [key: string]: string };
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._check = undefined;
      this._match = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._check = value.check;
      this._match = value.match;
    }
  }

  // check - computed: false, optional: false, required: true
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Label selector to match objects to delete
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#labels DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRefToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    kind: cdktf.stringToTerraform(struct!.kind),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRefToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._kind = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._kind = value.kind;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings[] | cdktf.IResolvable;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters;
  /**
  * DeletionPropagationPolicy decides if a deletion will propagate to the dependents of the object, and how the garbage collector will handle the propagation. Overrides the deletion propagation policy set in the Configuration, the Test and the TestStep.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion_propagation_policy DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion_propagation_policy}
  */
  readonly deletionPropagationPolicy?: string;
  /**
  * Expect defines a list of matched checks to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#expect DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#expect}
  */
  readonly expect?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect[] | cdktf.IResolvable;
  /**
  * File is the path to the referenced file. This can be a direct path to a file or an expression that matches multiple files, such as 'manifest/*.yaml' for all YAML files within the 'manifest' directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#file DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#file}
  */
  readonly file?: string;
  /**
  * Ref determines objects to be deleted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#ref DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#ref}
  */
  readonly ref?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef;
  /**
  * Template determines whether resources should be considered for templating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#template DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#template}
  */
  readonly template?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsToTerraform, false)(struct!.bindings),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClustersToTerraform(struct!.clusters),
    deletion_propagation_policy: cdktf.stringToTerraform(struct!.deletionPropagationPolicy),
    expect: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectToTerraform, false)(struct!.expect),
    file: cdktf.stringToTerraform(struct!.file),
    ref: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRefToTerraform(struct!.ref),
    template: cdktf.booleanToTerraform(struct!.template),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsList",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters",
    },
    deletion_propagation_policy: {
      value: cdktf.stringToHclTerraform(struct!.deletionPropagationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectToHclTerraform, false)(struct!.expect),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectList",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef",
    },
    template: {
      value: cdktf.booleanToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._deletionPropagationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletionPropagationPolicy = this._deletionPropagationPolicy;
    }
    if (this._expect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expect = this._expect?.internalValue;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._deletionPropagationPolicy = undefined;
      this._expect.internalValue = undefined;
      this._file = undefined;
      this._ref.internalValue = undefined;
      this._template = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._deletionPropagationPolicy = value.deletionPropagationPolicy;
      this._expect.internalValue = value.expect;
      this._file = value.file;
      this._ref.internalValue = value.ref;
      this._template = value.template;
      this._timeout = value.timeout;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // deletion_propagation_policy - computed: false, optional: true, required: false
  private _deletionPropagationPolicy?: string; 
  public get deletionPropagationPolicy() {
    return this.getStringAttribute('deletion_propagation_policy');
  }
  public set deletionPropagationPolicy(value: string) {
    this._deletionPropagationPolicy = value;
  }
  public resetDeletionPropagationPolicy() {
    this._deletionPropagationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionPropagationPolicyInput() {
    return this._deletionPropagationPolicy;
  }

  // expect - computed: false, optional: true, required: false
  private _expect = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpectList(this, "expect", false);
  public get expect() {
    return this._expect;
  }
  public putExpect(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteExpect[] | cdktf.IResolvable) {
    this._expect.internalValue = value;
  }
  public resetExpect() {
    this._expect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectInput() {
    return this._expect.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }

  // template - computed: false, optional: true, required: false
  private _template?: boolean | cdktf.IResolvable; 
  public get template() {
    return this.getBooleanAttribute('template');
  }
  public set template(value: boolean | cdktf.IResolvable) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Show Events indicates whether to include related events.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#show_events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#show_events}
  */
  readonly showEvents?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClustersToTerraform(struct!.clusters),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    show_events: cdktf.booleanToTerraform(struct!.showEvents),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    show_events: {
      value: cdktf.booleanToHclTerraform(struct!.showEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._showEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.showEvents = this._showEvents;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._showEvents = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._showEvents = value.showEvents;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // show_events - computed: false, optional: true, required: false
  private _showEvents?: boolean | cdktf.IResolvable; 
  public get showEvents() {
    return this.getBooleanAttribute('show_events');
  }
  public set showEvents(value: boolean | cdktf.IResolvable) {
    this._showEvents = value;
  }
  public resetShowEvents() {
    this._showEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get showEventsInput() {
    return this._showEvents;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClustersToTerraform(struct!.clusters),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs {
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters;
  /**
  * Container in pod to get logs from else --all-containers is used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#container DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#container}
  */
  readonly container?: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Tail is the number of last lines to collect from pods. If omitted or zero, then the default is 10 if you use a selector, or -1 (all) if you use a pod name. This matches default behavior of 'kubectl logs'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#tail DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#tail}
  */
  readonly tail?: number;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClustersToTerraform(struct!.clusters),
    container: cdktf.stringToTerraform(struct!.container),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    tail: cdktf.numberToTerraform(struct!.tail),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters",
    },
    container: {
      value: cdktf.stringToHclTerraform(struct!.container),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tail: {
      value: cdktf.numberToHclTerraform(struct!.tail),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._container !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._tail !== undefined) {
      hasAnyValues = true;
      internalValueResult.tail = this._tail;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._container = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._tail = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._container = value.container;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._tail = value.tail;
      this._timeout = value.timeout;
    }
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // container - computed: false, optional: true, required: false
  private _container?: string; 
  public get container() {
    return this.getStringAttribute('container');
  }
  public set container(value: string) {
    this._container = value;
  }
  public resetContainer() {
    this._container = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // tail - computed: false, optional: true, required: false
  private _tail?: number; 
  public get tail() {
    return this.getNumberAttribute('tail');
  }
  public set tail(value: number) {
    this._tail = value;
  }
  public resetTail() {
    this._tail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tailInput() {
    return this._tail;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters;
  /**
  * Content defines a shell script (run with 'sh -c ...').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#content DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#content}
  */
  readonly content?: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for script.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClustersToTerraform(struct!.clusters),
    content: cdktf.stringToTerraform(struct!.content),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters",
    },
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._content = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._content = value.content;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep {
  /**
  * Duration is the delay used for sleeping.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#duration DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#duration}
  */
  readonly duration: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleepToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    duration: cdktf.stringToTerraform(struct!.duration),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleepToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    duration: {
      value: cdktf.stringToHclTerraform(struct!.duration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._duration !== undefined) {
      hasAnyValues = true;
      internalValueResult.duration = this._duration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._duration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._duration = value.duration;
    }
  }

  // duration - computed: false, optional: false, required: true
  private _duration?: string; 
  public get duration() {
    return this.getStringAttribute('duration');
  }
  public set duration(value: string) {
    this._duration = value;
  }
  // Temporarily expose input value. Use with caution.
  public get durationInput() {
    return this._duration;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition {
  /**
  * Name defines the specific condition to wait for, e.g., 'Available', 'Ready'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value defines the specific condition status to wait for, e.g., 'True', 'False'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForConditionToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForConditionToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForConditionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath {
  /**
  * Path defines the json path to wait for, e.g. '{.status.phase}'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#path}
  */
  readonly path: string;
  /**
  * Value defines the expected value to wait for, e.g., 'Running'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPathToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPathToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._value = value.value;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor {
  /**
  * Condition specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#condition DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#condition}
  */
  readonly condition?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition;
  /**
  * Deletion specifies parameters for waiting on a resource's deletion.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#deletion DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#deletion}
  */
  readonly deletion?: { [key: string]: string };
  /**
  * JsonPath specifies the json path condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#json_path DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#json_path}
  */
  readonly jsonPath?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    condition: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForConditionToTerraform(struct!.condition),
    deletion: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.deletion),
    json_path: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPathToTerraform(struct!.jsonPath),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    condition: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForConditionToHclTerraform(struct!.condition),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition",
    },
    deletion: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.deletion),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    json_path: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPathToHclTerraform(struct!.jsonPath),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._condition?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.condition = this._condition?.internalValue;
    }
    if (this._deletion !== undefined) {
      hasAnyValues = true;
      internalValueResult.deletion = this._deletion;
    }
    if (this._jsonPath?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPath = this._jsonPath?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._condition.internalValue = undefined;
      this._deletion = undefined;
      this._jsonPath.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._condition.internalValue = value.condition;
      this._deletion = value.deletion;
      this._jsonPath.internalValue = value.jsonPath;
    }
  }

  // condition - computed: false, optional: true, required: false
  private _condition = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForConditionOutputReference(this, "condition");
  public get condition() {
    return this._condition;
  }
  public putCondition(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForCondition) {
    this._condition.internalValue = value;
  }
  public resetCondition() {
    this._condition.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get conditionInput() {
    return this._condition.internalValue;
  }

  // deletion - computed: false, optional: true, required: false
  private _deletion?: { [key: string]: string }; 
  public get deletion() {
    return this.getStringMapAttribute('deletion');
  }
  public set deletion(value: { [key: string]: string }) {
    this._deletion = value;
  }
  public resetDeletion() {
    this._deletion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deletionInput() {
    return this._deletion;
  }

  // json_path - computed: false, optional: true, required: false
  private _jsonPath = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPathOutputReference(this, "json_path");
  public get jsonPath() {
    return this._jsonPath;
  }
  public putJsonPath(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForJsonPath) {
    this._jsonPath.internalValue = value;
  }
  public resetJsonPath() {
    this._jsonPath.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPathInput() {
    return this._jsonPath.internalValue;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait {
  /**
  * API version of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#api_version DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#api_version}
  */
  readonly apiVersion: string;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters;
  /**
  * WaitFor specifies the condition to wait for.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#for DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#for}
  */
  readonly for: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor;
  /**
  * Format determines the output format (json or yaml).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#format DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#format}
  */
  readonly format?: string;
  /**
  * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kind DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kind}
  */
  readonly kind: string;
  /**
  * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#namespace DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Selector defines labels selector.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#selector DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#selector}
  */
  readonly selector?: string;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClustersToTerraform(struct!.clusters),
    for: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForToTerraform(struct!.for),
    format: cdktf.stringToTerraform(struct!.format),
    kind: cdktf.stringToTerraform(struct!.kind),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    selector: cdktf.stringToTerraform(struct!.selector),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters",
    },
    for: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForToHclTerraform(struct!.for),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kind: {
      value: cdktf.stringToHclTerraform(struct!.kind),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    selector: {
      value: cdktf.stringToHclTerraform(struct!.selector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._for?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.for = this._for?.internalValue;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._kind !== undefined) {
      hasAnyValues = true;
      internalValueResult.kind = this._kind;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._selector !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._for.internalValue = undefined;
      this._format = undefined;
      this._kind = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._selector = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._for.internalValue = value.for;
      this._format = value.format;
      this._kind = value.kind;
      this._name = value.name;
      this._namespace = value.namespace;
      this._selector = value.selector;
      this._timeout = value.timeout;
    }
  }

  // api_version - computed: false, optional: false, required: true
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // for - computed: false, optional: false, required: true
  private _for = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitForOutputReference(this, "for");
  public get for() {
    return this._for;
  }
  public putFor(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitFor) {
    this._for.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get forInput() {
    return this._for.internalValue;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // kind - computed: false, optional: false, required: true
  private _kind?: string; 
  public get kind() {
    return this.getStringAttribute('kind');
  }
  public set kind(value: string) {
    this._kind = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kindInput() {
    return this._kind;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // selector - computed: false, optional: true, required: false
  private _selector?: string; 
  public get selector() {
    return this.getStringAttribute('selector');
  }
  public set selector(value: string) {
    this._selector = value;
  }
  public resetSelector() {
    this._selector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinally {
  /**
  * Command defines a command to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#command DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#command}
  */
  readonly command?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand;
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Delete represents a deletion operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#delete DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#delete}
  */
  readonly delete?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete;
  /**
  * Describe determines the resource describe collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#describe DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#describe}
  */
  readonly describe?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe;
  /**
  * Description contains a description of the operation.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#description DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#description}
  */
  readonly description?: string;
  /**
  * Events determines the events collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#events DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#events}
  */
  readonly events?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents;
  /**
  * Get determines the resource get collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#get DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#get}
  */
  readonly get?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet;
  /**
  * PodLogs determines the pod logs collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#pod_logs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#pod_logs}
  */
  readonly podLogs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs;
  /**
  * Script defines a script to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#script DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#script}
  */
  readonly script?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript;
  /**
  * Sleep defines zzzz.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#sleep DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#sleep}
  */
  readonly sleep?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep;
  /**
  * Wait determines the resource wait collector to execute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#wait DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#wait}
  */
  readonly wait?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinally | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    command: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandToTerraform(struct!.command),
    compiler: cdktf.stringToTerraform(struct!.compiler),
    delete: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteToTerraform(struct!.delete),
    describe: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeToTerraform(struct!.describe),
    description: cdktf.stringToTerraform(struct!.description),
    events: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsToTerraform(struct!.events),
    get: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetToTerraform(struct!.get),
    pod_logs: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsToTerraform(struct!.podLogs),
    script: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptToTerraform(struct!.script),
    sleep: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleepToTerraform(struct!.sleep),
    wait: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitToTerraform(struct!.wait),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinally | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    command: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandToHclTerraform(struct!.command),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand",
    },
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteToHclTerraform(struct!.delete),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete",
    },
    describe: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeToHclTerraform(struct!.describe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    events: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsToHclTerraform(struct!.events),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents",
    },
    get: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetToHclTerraform(struct!.get),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet",
    },
    pod_logs: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsToHclTerraform(struct!.podLogs),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs",
    },
    script: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptToHclTerraform(struct!.script),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript",
    },
    sleep: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleepToHclTerraform(struct!.sleep),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep",
    },
    wait: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitToHclTerraform(struct!.wait),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinally | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._command?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command?.internalValue;
    }
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._delete?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete?.internalValue;
    }
    if (this._describe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.describe = this._describe?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._events?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.events = this._events?.internalValue;
    }
    if (this._get?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.get = this._get?.internalValue;
    }
    if (this._podLogs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.podLogs = this._podLogs?.internalValue;
    }
    if (this._script?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.script = this._script?.internalValue;
    }
    if (this._sleep?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sleep = this._sleep?.internalValue;
    }
    if (this._wait?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.wait = this._wait?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinally | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._command.internalValue = undefined;
      this._compiler = undefined;
      this._delete.internalValue = undefined;
      this._describe.internalValue = undefined;
      this._description = undefined;
      this._events.internalValue = undefined;
      this._get.internalValue = undefined;
      this._podLogs.internalValue = undefined;
      this._script.internalValue = undefined;
      this._sleep.internalValue = undefined;
      this._wait.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._command.internalValue = value.command;
      this._compiler = value.compiler;
      this._delete.internalValue = value.delete;
      this._describe.internalValue = value.describe;
      this._description = value.description;
      this._events.internalValue = value.events;
      this._get.internalValue = value.get;
      this._podLogs.internalValue = value.podLogs;
      this._script.internalValue = value.script;
      this._sleep.internalValue = value.sleep;
      this._wait.internalValue = value.wait;
    }
  }

  // command - computed: false, optional: true, required: false
  private _command = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommandOutputReference(this, "command");
  public get command() {
    return this._command;
  }
  public putCommand(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyCommand) {
    this._command.internalValue = value;
  }
  public resetCommand() {
    this._command.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command.internalValue;
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // delete - computed: false, optional: true, required: false
  private _delete = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDeleteOutputReference(this, "delete");
  public get delete() {
    return this._delete;
  }
  public putDelete(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDelete) {
    this._delete.internalValue = value;
  }
  public resetDelete() {
    this._delete.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete.internalValue;
  }

  // describe - computed: false, optional: true, required: false
  private _describe = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribeOutputReference(this, "describe");
  public get describe() {
    return this._describe;
  }
  public putDescribe(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyDescribe) {
    this._describe.internalValue = value;
  }
  public resetDescribe() {
    this._describe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get describeInput() {
    return this._describe.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // events - computed: false, optional: true, required: false
  private _events = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEventsOutputReference(this, "events");
  public get events() {
    return this._events;
  }
  public putEvents(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyEvents) {
    this._events.internalValue = value;
  }
  public resetEvents() {
    this._events.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventsInput() {
    return this._events.internalValue;
  }

  // get - computed: false, optional: true, required: false
  private _get = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGetOutputReference(this, "get");
  public get get() {
    return this._get;
  }
  public putGet(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyGet) {
    this._get.internalValue = value;
  }
  public resetGet() {
    this._get.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get getInput() {
    return this._get.internalValue;
  }

  // pod_logs - computed: false, optional: true, required: false
  private _podLogs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogsOutputReference(this, "pod_logs");
  public get podLogs() {
    return this._podLogs;
  }
  public putPodLogs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyPodLogs) {
    this._podLogs.internalValue = value;
  }
  public resetPodLogs() {
    this._podLogs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get podLogsInput() {
    return this._podLogs.internalValue;
  }

  // script - computed: false, optional: true, required: false
  private _script = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScriptOutputReference(this, "script");
  public get script() {
    return this._script;
  }
  public putScript(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyScript) {
    this._script.internalValue = value;
  }
  public resetScript() {
    this._script.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scriptInput() {
    return this._script.internalValue;
  }

  // sleep - computed: false, optional: true, required: false
  private _sleep = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleepOutputReference(this, "sleep");
  public get sleep() {
    return this._sleep;
  }
  public putSleep(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallySleep) {
    this._sleep.internalValue = value;
  }
  public resetSleep() {
    this._sleep.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sleepInput() {
    return this._sleep.internalValue;
  }

  // wait - computed: false, optional: true, required: false
  private _wait = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWaitOutputReference(this, "wait");
  public get wait() {
    return this._wait;
  }
  public putWait(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyWait) {
    this._wait.internalValue = value;
  }
  public resetWait() {
    this._wait.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get waitInput() {
    return this._wait.internalValue;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinally[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsFinallyOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeouts {
  /**
  * Apply defines the timeout for the apply operation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#apply DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#apply}
  */
  readonly apply?: string;
  /**
  * Assert defines the timeout for the assert operation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#assert DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#assert}
  */
  readonly assert?: string;
  /**
  * Cleanup defines the timeout for the cleanup operation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cleanup DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cleanup}
  */
  readonly cleanup?: string;
  /**
  * Delete defines the timeout for the delete operation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#delete DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#delete}
  */
  readonly delete?: string;
  /**
  * Error defines the timeout for the error operation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#error DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#error}
  */
  readonly error?: string;
  /**
  * Exec defines the timeout for exec operations
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#exec DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#exec}
  */
  readonly exec?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeoutsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apply: cdktf.stringToTerraform(struct!.apply),
    assert: cdktf.stringToTerraform(struct!.assert),
    cleanup: cdktf.stringToTerraform(struct!.cleanup),
    delete: cdktf.stringToTerraform(struct!.delete),
    error: cdktf.stringToTerraform(struct!.error),
    exec: cdktf.stringToTerraform(struct!.exec),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeoutsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeouts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apply: {
      value: cdktf.stringToHclTerraform(struct!.apply),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assert: {
      value: cdktf.stringToHclTerraform(struct!.assert),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cleanup: {
      value: cdktf.stringToHclTerraform(struct!.cleanup),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    delete: {
      value: cdktf.stringToHclTerraform(struct!.delete),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    error: {
      value: cdktf.stringToHclTerraform(struct!.error),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exec: {
      value: cdktf.stringToHclTerraform(struct!.exec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeoutsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeouts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apply !== undefined) {
      hasAnyValues = true;
      internalValueResult.apply = this._apply;
    }
    if (this._assert !== undefined) {
      hasAnyValues = true;
      internalValueResult.assert = this._assert;
    }
    if (this._cleanup !== undefined) {
      hasAnyValues = true;
      internalValueResult.cleanup = this._cleanup;
    }
    if (this._delete !== undefined) {
      hasAnyValues = true;
      internalValueResult.delete = this._delete;
    }
    if (this._error !== undefined) {
      hasAnyValues = true;
      internalValueResult.error = this._error;
    }
    if (this._exec !== undefined) {
      hasAnyValues = true;
      internalValueResult.exec = this._exec;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTimeouts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apply = undefined;
      this._assert = undefined;
      this._cleanup = undefined;
      this._delete = undefined;
      this._error = undefined;
      this._exec = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apply = value.apply;
      this._assert = value.assert;
      this._cleanup = value.cleanup;
      this._delete = value.delete;
      this._error = value.error;
      this._exec = value.exec;
    }
  }

  // apply - computed: false, optional: true, required: false
  private _apply?: string; 
  public get apply() {
    return this.getStringAttribute('apply');
  }
  public set apply(value: string) {
    this._apply = value;
  }
  public resetApply() {
    this._apply = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get applyInput() {
    return this._apply;
  }

  // assert - computed: false, optional: true, required: false
  private _assert?: string; 
  public get assert() {
    return this.getStringAttribute('assert');
  }
  public set assert(value: string) {
    this._assert = value;
  }
  public resetAssert() {
    this._assert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assertInput() {
    return this._assert;
  }

  // cleanup - computed: false, optional: true, required: false
  private _cleanup?: string; 
  public get cleanup() {
    return this.getStringAttribute('cleanup');
  }
  public set cleanup(value: string) {
    this._cleanup = value;
  }
  public resetCleanup() {
    this._cleanup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cleanupInput() {
    return this._cleanup;
  }

  // delete - computed: false, optional: true, required: false
  private _delete?: string; 
  public get delete() {
    return this.getStringAttribute('delete');
  }
  public set delete(value: string) {
    this._delete = value;
  }
  public resetDelete() {
    this._delete = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deleteInput() {
    return this._delete;
  }

  // error - computed: false, optional: true, required: false
  private _error?: string; 
  public get error() {
    return this.getStringAttribute('error');
  }
  public set error(value: string) {
    this._error = value;
  }
  public resetError() {
    this._error = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get errorInput() {
    return this._error;
  }

  // exec - computed: false, optional: true, required: false
  private _exec?: string; 
  public get exec() {
    return this.getStringAttribute('exec');
  }
  public set exec(value: string) {
    this._exec = value;
  }
  public resetExec() {
    this._exec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execInput() {
    return this._exec;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect {
  /**
  * Check defines the verification statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check: { [key: string]: string };
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._check = undefined;
      this._match = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._check = value.check;
      this._match = value.match;
    }
  }

  // check - computed: false, optional: false, required: true
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApply {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings[] | cdktf.IResolvable;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters;
  /**
  * DryRun determines whether the file should be applied in dry run mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#dry_run DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#dry_run}
  */
  readonly dryRun?: boolean | cdktf.IResolvable;
  /**
  * Expect defines a list of matched checks to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#expect DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#expect}
  */
  readonly expect?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect[] | cdktf.IResolvable;
  /**
  * File is the path to the referenced file. This can be a direct path to a file or an expression that matches multiple files, such as 'manifest/*.yaml' for all YAML files within the 'manifest' directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#file DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#file}
  */
  readonly file?: string;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs[] | cdktf.IResolvable;
  /**
  * Resource provides a resource to be applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#resource DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#resource}
  */
  readonly resource?: { [key: string]: string };
  /**
  * Template determines whether resources should be considered for templating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#template DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#template}
  */
  readonly template?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApply | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsToTerraform, false)(struct!.bindings),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClustersToTerraform(struct!.clusters),
    dry_run: cdktf.booleanToTerraform(struct!.dryRun),
    expect: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectToTerraform, false)(struct!.expect),
    file: cdktf.stringToTerraform(struct!.file),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsToTerraform, false)(struct!.outputs),
    resource: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.resource),
    template: cdktf.booleanToTerraform(struct!.template),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApply | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsList",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters",
    },
    dry_run: {
      value: cdktf.booleanToHclTerraform(struct!.dryRun),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    expect: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectToHclTerraform, false)(struct!.expect),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectList",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsList",
    },
    resource: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.resource),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    template: {
      value: cdktf.booleanToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApply | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._dryRun !== undefined) {
      hasAnyValues = true;
      internalValueResult.dryRun = this._dryRun;
    }
    if (this._expect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expect = this._expect?.internalValue;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApply | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._dryRun = undefined;
      this._expect.internalValue = undefined;
      this._file = undefined;
      this._outputs.internalValue = undefined;
      this._resource = undefined;
      this._template = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._dryRun = value.dryRun;
      this._expect.internalValue = value.expect;
      this._file = value.file;
      this._outputs.internalValue = value.outputs;
      this._resource = value.resource;
      this._template = value.template;
      this._timeout = value.timeout;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // dry_run - computed: false, optional: true, required: false
  private _dryRun?: boolean | cdktf.IResolvable; 
  public get dryRun() {
    return this.getBooleanAttribute('dry_run');
  }
  public set dryRun(value: boolean | cdktf.IResolvable) {
    this._dryRun = value;
  }
  public resetDryRun() {
    this._dryRun = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dryRunInput() {
    return this._dryRun;
  }

  // expect - computed: false, optional: true, required: false
  private _expect = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpectList(this, "expect", false);
  public get expect() {
    return this._expect;
  }
  public putExpect(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyExpect[] | cdktf.IResolvable) {
    this._expect.internalValue = value;
  }
  public resetExpect() {
    this._expect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectInput() {
    return this._expect.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryApplyOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // resource - computed: false, optional: true, required: false
  private _resource?: { [key: string]: string }; 
  public get resource() {
    return this.getStringMapAttribute('resource');
  }
  public set resource(value: { [key: string]: string }) {
    this._resource = value;
  }
  public resetResource() {
    this._resource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }

  // template - computed: false, optional: true, required: false
  private _template?: boolean | cdktf.IResolvable; 
  public get template() {
    return this.getBooleanAttribute('template');
  }
  public set template(value: boolean | cdktf.IResolvable) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssert {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings[] | cdktf.IResolvable;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters;
  /**
  * File is the path to the referenced file. This can be a direct path to a file or an expression that matches multiple files, such as 'manifest/*.yaml' for all YAML files within the 'manifest' directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#file DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#file}
  */
  readonly file?: string;
  /**
  * Check provides a check used in assertions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#resource DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#resource}
  */
  readonly resource?: { [key: string]: string };
  /**
  * Template determines whether resources should be considered for templating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#template DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#template}
  */
  readonly template?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsToTerraform, false)(struct!.bindings),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClustersToTerraform(struct!.clusters),
    file: cdktf.stringToTerraform(struct!.file),
    resource: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.resource),
    template: cdktf.booleanToTerraform(struct!.template),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsList",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.resource),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    template: {
      value: cdktf.booleanToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._file = undefined;
      this._resource = undefined;
      this._template = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._file = value.file;
      this._resource = value.resource;
      this._template = value.template;
      this._timeout = value.timeout;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryAssertClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // resource - computed: false, optional: true, required: false
  private _resource?: { [key: string]: string }; 
  public get resource() {
    return this.getStringMapAttribute('resource');
  }
  public set resource(value: { [key: string]: string }) {
    this._resource = value;
  }
  public resetResource() {
    this._resource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }

  // template - computed: false, optional: true, required: false
  private _template?: boolean | cdktf.IResolvable; 
  public get template() {
    return this.getBooleanAttribute('template');
  }
  public set template(value: boolean | cdktf.IResolvable) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommand {
  /**
  * Args is the command arguments.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#args DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#args}
  */
  readonly args?: string[];
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings[] | cdktf.IResolvable;
  /**
  * Check is an assertion tree to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check?: { [key: string]: string };
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters;
  /**
  * Entrypoint is the command entry point to run.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#entrypoint DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#entrypoint}
  */
  readonly entrypoint: string;
  /**
  * Env defines additional environment variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#env DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#env}
  */
  readonly env?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv[] | cdktf.IResolvable;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs[] | cdktf.IResolvable;
  /**
  * SkipLogOutput removes the output from the command. Useful for sensitive logs or to reduce noise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#skip_log_output DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#skip_log_output}
  */
  readonly skipLogOutput?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
  /**
  * WorkDir is the working directory for command.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#work_dir DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#work_dir}
  */
  readonly workDir?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsToTerraform, false)(struct!.bindings),
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClustersToTerraform(struct!.clusters),
    entrypoint: cdktf.stringToTerraform(struct!.entrypoint),
    env: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvToTerraform, false)(struct!.env),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsToTerraform, false)(struct!.outputs),
    skip_log_output: cdktf.booleanToTerraform(struct!.skipLogOutput),
    timeout: cdktf.stringToTerraform(struct!.timeout),
    work_dir: cdktf.stringToTerraform(struct!.workDir),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommand | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsList",
    },
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters",
    },
    entrypoint: {
      value: cdktf.stringToHclTerraform(struct!.entrypoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    env: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvToHclTerraform, false)(struct!.env),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvList",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsList",
    },
    skip_log_output: {
      value: cdktf.booleanToHclTerraform(struct!.skipLogOutput),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    work_dir: {
      value: cdktf.stringToHclTerraform(struct!.workDir),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommand | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._entrypoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.entrypoint = this._entrypoint;
    }
    if (this._env?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.env = this._env?.internalValue;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._skipLogOutput !== undefined) {
      hasAnyValues = true;
      internalValueResult.skipLogOutput = this._skipLogOutput;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    if (this._workDir !== undefined) {
      hasAnyValues = true;
      internalValueResult.workDir = this._workDir;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommand | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._bindings.internalValue = undefined;
      this._check = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._entrypoint = undefined;
      this._env.internalValue = undefined;
      this._outputs.internalValue = undefined;
      this._skipLogOutput = undefined;
      this._timeout = undefined;
      this._workDir = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._bindings.internalValue = value.bindings;
      this._check = value.check;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._entrypoint = value.entrypoint;
      this._env.internalValue = value.env;
      this._outputs.internalValue = value.outputs;
      this._skipLogOutput = value.skipLogOutput;
      this._timeout = value.timeout;
      this._workDir = value.workDir;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // check - computed: false, optional: true, required: false
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  public resetCheck() {
    this._check = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // entrypoint - computed: false, optional: false, required: true
  private _entrypoint?: string; 
  public get entrypoint() {
    return this.getStringAttribute('entrypoint');
  }
  public set entrypoint(value: string) {
    this._entrypoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get entrypointInput() {
    return this._entrypoint;
  }

  // env - computed: false, optional: true, required: false
  private _env = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnvList(this, "env", false);
  public get env() {
    return this._env;
  }
  public putEnv(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandEnv[] | cdktf.IResolvable) {
    this._env.internalValue = value;
  }
  public resetEnv() {
    this._env.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get envInput() {
    return this._env.internalValue;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCommandOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // skip_log_output - computed: false, optional: true, required: false
  private _skipLogOutput?: boolean | cdktf.IResolvable; 
  public get skipLogOutput() {
    return this.getBooleanAttribute('skip_log_output');
  }
  public set skipLogOutput(value: boolean | cdktf.IResolvable) {
    this._skipLogOutput = value;
  }
  public resetSkipLogOutput() {
    this._skipLogOutput = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get skipLogOutputInput() {
    return this._skipLogOutput;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }

  // work_dir - computed: false, optional: true, required: false
  private _workDir?: string; 
  public get workDir() {
    return this.getStringAttribute('work_dir');
  }
  public set workDir(value: string) {
    this._workDir = value;
  }
  public resetWorkDir() {
    this._workDir = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workDirInput() {
    return this._workDir;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect {
  /**
  * Check defines the verification statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#check DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#check}
  */
  readonly check: { [key: string]: string };
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    check: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.check),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    check: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.check),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._check !== undefined) {
      hasAnyValues = true;
      internalValueResult.check = this._check;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._check = undefined;
      this._match = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._check = value.check;
      this._match = value.match;
    }
  }

  // check - computed: false, optional: false, required: true
  private _check?: { [key: string]: string }; 
  public get check() {
    return this.getStringMapAttribute('check');
  }
  public set check(value: { [key: string]: string }) {
    this._check = value;
  }
  // Temporarily expose input value. Use with caution.
  public get checkInput() {
    return this._check;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Match defines the matching statement.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#match DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#match}
  */
  readonly match?: { [key: string]: string };
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    match: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.match),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.match),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._match !== undefined) {
      hasAnyValues = true;
      internalValueResult.match = this._match;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._match = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._match = value.match;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // match - computed: false, optional: true, required: false
  private _match?: { [key: string]: string }; 
  public get match() {
    return this.getStringMapAttribute('match');
  }
  public set match(value: { [key: string]: string }) {
    this._match = value;
  }
  public resetMatch() {
    this._match = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchInput() {
    return this._match;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreate {
  /**
  * Bindings defines additional binding key/values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#bindings DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#bindings}
  */
  readonly bindings?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings[] | cdktf.IResolvable;
  /**
  * Cluster defines the target cluster (will be inherited if not specified).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#cluster DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#cluster}
  */
  readonly cluster?: string;
  /**
  * Clusters holds a registry to clusters to support multi-cluster tests.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#clusters DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#clusters}
  */
  readonly clusters?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters;
  /**
  * DryRun determines whether the file should be applied in dry run mode.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#dry_run DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#dry_run}
  */
  readonly dryRun?: boolean | cdktf.IResolvable;
  /**
  * Expect defines a list of matched checks to validate the operation outcome.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#expect DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#expect}
  */
  readonly expect?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect[] | cdktf.IResolvable;
  /**
  * File is the path to the referenced file. This can be a direct path to a file or an expression that matches multiple files, such as 'manifest/*.yaml' for all YAML files within the 'manifest' directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#file DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#file}
  */
  readonly file?: string;
  /**
  * Outputs defines output bindings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#outputs DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#outputs}
  */
  readonly outputs?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs[] | cdktf.IResolvable;
  /**
  * Resource provides a resource to be applied.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#resource DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#resource}
  */
  readonly resource?: { [key: string]: string };
  /**
  * Template determines whether resources should be considered for templating.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#template DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#template}
  */
  readonly template?: boolean | cdktf.IResolvable;
  /**
  * Timeout for the operation. Overrides the global timeout set in the Configuration.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#timeout DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bindings: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsToTerraform, false)(struct!.bindings),
    cluster: cdktf.stringToTerraform(struct!.cluster),
    clusters: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClustersToTerraform(struct!.clusters),
    dry_run: cdktf.booleanToTerraform(struct!.dryRun),
    expect: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectToTerraform, false)(struct!.expect),
    file: cdktf.stringToTerraform(struct!.file),
    outputs: cdktf.listMapper(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsToTerraform, false)(struct!.outputs),
    resource: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.resource),
    template: cdktf.booleanToTerraform(struct!.template),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bindings: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsToHclTerraform, false)(struct!.bindings),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsList",
    },
    cluster: {
      value: cdktf.stringToHclTerraform(struct!.cluster),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    clusters: {
      value: dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClustersToHclTerraform(struct!.clusters),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters",
    },
    dry_run: {
      value: cdktf.booleanToHclTerraform(struct!.dryRun),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    expect: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectToHclTerraform, false)(struct!.expect),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectList",
    },
    file: {
      value: cdktf.stringToHclTerraform(struct!.file),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    outputs: {
      value: cdktf.listMapperHcl(dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsToHclTerraform, false)(struct!.outputs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsList",
    },
    resource: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.resource),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    template: {
      value: cdktf.booleanToHclTerraform(struct!.template),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bindings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bindings = this._bindings?.internalValue;
    }
    if (this._cluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.cluster = this._cluster;
    }
    if (this._clusters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusters = this._clusters?.internalValue;
    }
    if (this._dryRun !== undefined) {
      hasAnyValues = true;
      internalValueResult.dryRun = this._dryRun;
    }
    if (this._expect?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expect = this._expect?.internalValue;
    }
    if (this._file !== undefined) {
      hasAnyValues = true;
      internalValueResult.file = this._file;
    }
    if (this._outputs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputs = this._outputs?.internalValue;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    if (this._template !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bindings.internalValue = undefined;
      this._cluster = undefined;
      this._clusters.internalValue = undefined;
      this._dryRun = undefined;
      this._expect.internalValue = undefined;
      this._file = undefined;
      this._outputs.internalValue = undefined;
      this._resource = undefined;
      this._template = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bindings.internalValue = value.bindings;
      this._cluster = value.cluster;
      this._clusters.internalValue = value.clusters;
      this._dryRun = value.dryRun;
      this._expect.internalValue = value.expect;
      this._file = value.file;
      this._outputs.internalValue = value.outputs;
      this._resource = value.resource;
      this._template = value.template;
      this._timeout = value.timeout;
    }
  }

  // bindings - computed: false, optional: true, required: false
  private _bindings = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindingsList(this, "bindings", false);
  public get bindings() {
    return this._bindings;
  }
  public putBindings(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateBindings[] | cdktf.IResolvable) {
    this._bindings.internalValue = value;
  }
  public resetBindings() {
    this._bindings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bindingsInput() {
    return this._bindings.internalValue;
  }

  // cluster - computed: false, optional: true, required: false
  private _cluster?: string; 
  public get cluster() {
    return this.getStringAttribute('cluster');
  }
  public set cluster(value: string) {
    this._cluster = value;
  }
  public resetCluster() {
    this._cluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterInput() {
    return this._cluster;
  }

  // clusters - computed: false, optional: true, required: false
  private _clusters = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClustersOutputReference(this, "clusters");
  public get clusters() {
    return this._clusters;
  }
  public putClusters(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateClusters) {
    this._clusters.internalValue = value;
  }
  public resetClusters() {
    this._clusters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clustersInput() {
    return this._clusters.internalValue;
  }

  // dry_run - computed: false, optional: true, required: false
  private _dryRun?: boolean | cdktf.IResolvable; 
  public get dryRun() {
    return this.getBooleanAttribute('dry_run');
  }
  public set dryRun(value: boolean | cdktf.IResolvable) {
    this._dryRun = value;
  }
  public resetDryRun() {
    this._dryRun = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dryRunInput() {
    return this._dryRun;
  }

  // expect - computed: false, optional: true, required: false
  private _expect = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpectList(this, "expect", false);
  public get expect() {
    return this._expect;
  }
  public putExpect(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateExpect[] | cdktf.IResolvable) {
    this._expect.internalValue = value;
  }
  public resetExpect() {
    this._expect.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectInput() {
    return this._expect.internalValue;
  }

  // file - computed: false, optional: true, required: false
  private _file?: string; 
  public get file() {
    return this.getStringAttribute('file');
  }
  public set file(value: string) {
    this._file = value;
  }
  public resetFile() {
    this._file = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileInput() {
    return this._file;
  }

  // outputs - computed: false, optional: true, required: false
  private _outputs = new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputsList(this, "outputs", false);
  public get outputs() {
    return this._outputs;
  }
  public putOutputs(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryCreateOutputs[] | cdktf.IResolvable) {
    this._outputs.internalValue = value;
  }
  public resetOutputs() {
    this._outputs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputsInput() {
    return this._outputs.internalValue;
  }

  // resource - computed: false, optional: true, required: false
  private _resource?: { [key: string]: string }; 
  public get resource() {
    return this.getStringMapAttribute('resource');
  }
  public set resource(value: { [key: string]: string }) {
    this._resource = value;
  }
  public resetResource() {
    this._resource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }

  // template - computed: false, optional: true, required: false
  private _template?: boolean | cdktf.IResolvable; 
  public get template() {
    return this.getBooleanAttribute('template');
  }
  public set template(value: boolean | cdktf.IResolvable) {
    this._template = value;
  }
  public resetTemplate() {
    this._template = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindings {
  /**
  * Compiler defines the default compiler to use when evaluating expressions.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#compiler DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#compiler}
  */
  readonly compiler?: string;
  /**
  * Name the name of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#name DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * Value value of the binding.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#value DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#value}
  */
  readonly value: { [key: string]: string };
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindingsToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compiler: cdktf.stringToTerraform(struct!.compiler),
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindingsToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compiler: {
      value: cdktf.stringToHclTerraform(struct!.compiler),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compiler !== undefined) {
      hasAnyValues = true;
      internalValueResult.compiler = this._compiler;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compiler = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compiler = value.compiler;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // compiler - computed: false, optional: true, required: false
  private _compiler?: string; 
  public get compiler() {
    return this.getStringAttribute('compiler');
  }
  public set compiler(value: string) {
    this._compiler = value;
  }
  public resetCompiler() {
    this._compiler = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compilerInput() {
    return this._compiler;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindingsList extends cdktf.ComplexList {
  public internalValue? : DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindingsOutputReference {
    return new DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteBindingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClusters {
  /**
  * Context is the name of the context to use.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#context DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#context}
  */
  readonly context?: string;
  /**
  * Kubeconfig is the path to the referenced file.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.11.17/docs/data-sources/chainsaw_kyverno_io_test_v1alpha1_manifest#kubeconfig DataK8SChainsawKyvernoIoTestV1Alpha1Manifest#kubeconfig}
  */
  readonly kubeconfig: string;
}

export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClustersToTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context: cdktf.stringToTerraform(struct!.context),
    kubeconfig: cdktf.stringToTerraform(struct!.kubeconfig),
  }
}


export function dataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClustersToHclTerraform(struct?: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClusters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context: {
      value: cdktf.stringToHclTerraform(struct!.context),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    kubeconfig: {
      value: cdktf.stringToHclTerraform(struct!.kubeconfig),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClustersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClusters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._context !== undefined) {
      hasAnyValues = true;
      internalValueResult.context = this._context;
    }
    if (this._kubeconfig !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubeconfig = this._kubeconfig;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SChainsawKyvernoIoTestV1Alpha1ManifestSpecStepsTryDeleteClusters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._context = undefined;
      this._kubeconfig = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._context = value.context;
      this._kubeconfig = value.kubeconfig;
    }
  }

  // context - computed: false, optional: true, required: false
  private _context?: string; 
  public get context() {
    return this.getStringAttribute('context');
  }
  public set context(value: string) {
    this._context = value;
  }
  public resetContext() {
    this._context = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextInput() {
    return this._context;
  }

  // kubeconfig - computed: false, optional: false, required: true
  private _kubeconfig?: string; 
  public get kubeconfig() {
    return this.getStringAttribute('kubeconfig');
  }
  public set kubeconfig(value: string) {
    this._kubeconfig = value;
  }
  // Temporarily expose input value. Use with caution.
  public get kubeconfigInput() {
    return this._kubeconfig;
  }
}
