import * as cdktf from 'cdktf';
export interface DataK8SGatewaySoloIoRouteTableV1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#annotations DataK8SGatewaySoloIoRouteTableV1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#labels DataK8SGatewaySoloIoRouteTableV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatuses {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#statuses DataK8SGatewaySoloIoRouteTableV1Manifest#statuses}
  */
  readonly statuses?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatusesToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    statuses: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.statuses),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatusesToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatuses | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    statuses: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.statuses),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatusesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._statuses !== undefined) {
      hasAnyValues = true;
      internalValueResult.statuses = this._statuses;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecNamespacedStatuses | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._statuses = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._statuses = value.statuses;
    }
  }

  // statuses - computed: false, optional: true, required: false
  private _statuses?: { [key: string]: string }; 
  public get statuses() {
    return this.getStringMapAttribute('statuses');
  }
  public set statuses(value: { [key: string]: string }) {
    this._statuses = value;
  }
  public resetStatuses() {
    this._statuses = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusesInput() {
    return this._statuses;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#operator DataK8SGatewaySoloIoRouteTableV1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#values DataK8SGatewaySoloIoRouteTableV1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#expressions DataK8SGatewaySoloIoRouteTableV1Manifest#expressions}
  */
  readonly expressions?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#labels DataK8SGatewaySoloIoRouteTableV1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespaces DataK8SGatewaySoloIoRouteTableV1Manifest#namespaces}
  */
  readonly namespaces?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expressions: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsToTerraform, false)(struct!.expressions),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expressions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsToHclTerraform, false)(struct!.expressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsList",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.expressions = this._expressions?.internalValue;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expressions.internalValue = undefined;
      this._labels = undefined;
      this._namespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expressions.internalValue = value.expressions;
      this._labels = value.labels;
      this._namespaces = value.namespaces;
    }
  }

  // expressions - computed: false, optional: true, required: false
  private _expressions = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressionsList(this, "expressions", false);
  public get expressions() {
    return this._expressions;
  }
  public putExpressions(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorExpressions[] | cdktf.IResolvable) {
    this._expressions.internalValue = value;
  }
  public resetExpressions() {
    this._expressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expressionsInput() {
    return this._expressions.internalValue;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#ref DataK8SGatewaySoloIoRouteTableV1Manifest#ref}
  */
  readonly ref?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#selector DataK8SGatewaySoloIoRouteTableV1Manifest#selector}
  */
  readonly selector?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRefToTerraform(struct!.ref),
    selector: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorToTerraform(struct!.selector),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRefToHclTerraform(struct!.ref),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef",
    },
    selector: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorToHclTerraform(struct!.selector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._ref?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ref = this._ref?.internalValue;
    }
    if (this._selector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.selector = this._selector?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._ref.internalValue = undefined;
      this._selector.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
      this._ref.internalValue = value.ref;
      this._selector.internalValue = value.selector;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // ref - computed: false, optional: true, required: false
  private _ref = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRefOutputReference(this, "ref");
  public get ref() {
    return this._ref;
  }
  public putRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionRef) {
    this._ref.internalValue = value;
  }
  public resetRef() {
    this._ref.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refInput() {
    return this._ref.internalValue;
  }

  // selector - computed: false, optional: true, required: false
  private _selector = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelectorOutputReference(this, "selector");
  public get selector() {
    return this._selector;
  }
  public putSelector(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDelegateActionSelector) {
    this._selector.internalValue = value;
  }
  public resetSelector() {
    this._selector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get selectorInput() {
    return this._selector.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#body DataK8SGatewaySoloIoRouteTableV1Manifest#body}
  */
  readonly body?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#status DataK8SGatewaySoloIoRouteTableV1Manifest#status}
  */
  readonly status?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseActionToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    body: cdktf.stringToTerraform(struct!.body),
    status: cdktf.numberToTerraform(struct!.status),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseActionToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    body: {
      value: cdktf.stringToHclTerraform(struct!.body),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status: {
      value: cdktf.numberToHclTerraform(struct!.status),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._body !== undefined) {
      hasAnyValues = true;
      internalValueResult.body = this._body;
    }
    if (this._status !== undefined) {
      hasAnyValues = true;
      internalValueResult.status = this._status;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesDirectResponseAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._body = undefined;
      this._status = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._body = value.body;
      this._status = value.status;
    }
  }

  // body - computed: false, optional: true, required: false
  private _body?: string; 
  public get body() {
    return this.getStringAttribute('body');
  }
  public set body(value: string) {
    this._body = value;
  }
  public resetBody() {
    this._body = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bodyInput() {
    return this._body;
  }

  // status - computed: false, optional: true, required: false
  private _status?: number; 
  public get status() {
    return this.getNumberAttribute('status');
  }
  public set status(value: number) {
    this._status = value;
  }
  public resetStatus() {
    this._status = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusInput() {
    return this._status;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesGraphqlApiRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#invert_match DataK8SGatewaySoloIoRouteTableV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    regex: cdktf.booleanToTerraform(struct!.regex),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    regex: {
      value: cdktf.booleanToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._regex = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._regex = value.regex;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: boolean | cdktf.IResolvable; 
  public get regex() {
    return this.getBooleanAttribute('regex');
  }
  public set regex(value: boolean | cdktf.IResolvable) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchers {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#case_sensitive DataK8SGatewaySoloIoRouteTableV1Manifest#case_sensitive}
  */
  readonly caseSensitive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#connect_matcher DataK8SGatewaySoloIoRouteTableV1Manifest#connect_matcher}
  */
  readonly connectMatcher?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#exact DataK8SGatewaySoloIoRouteTableV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#methods DataK8SGatewaySoloIoRouteTableV1Manifest#methods}
  */
  readonly methods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prefix DataK8SGatewaySoloIoRouteTableV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#query_parameters DataK8SGatewaySoloIoRouteTableV1Manifest#query_parameters}
  */
  readonly queryParameters?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    case_sensitive: cdktf.booleanToTerraform(struct!.caseSensitive),
    connect_matcher: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.connectMatcher),
    exact: cdktf.stringToTerraform(struct!.exact),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersToTerraform, false)(struct!.headers),
    methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.methods),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    query_parameters: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersToTerraform, false)(struct!.queryParameters),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    case_sensitive: {
      value: cdktf.booleanToHclTerraform(struct!.caseSensitive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connect_matcher: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.connectMatcher),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersList",
    },
    methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.methods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    query_parameters: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersToHclTerraform, false)(struct!.queryParameters),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersList",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caseSensitive !== undefined) {
      hasAnyValues = true;
      internalValueResult.caseSensitive = this._caseSensitive;
    }
    if (this._connectMatcher !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectMatcher = this._connectMatcher;
    }
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._methods !== undefined) {
      hasAnyValues = true;
      internalValueResult.methods = this._methods;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._queryParameters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParameters = this._queryParameters?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caseSensitive = undefined;
      this._connectMatcher = undefined;
      this._exact = undefined;
      this._headers.internalValue = undefined;
      this._methods = undefined;
      this._prefix = undefined;
      this._queryParameters.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caseSensitive = value.caseSensitive;
      this._connectMatcher = value.connectMatcher;
      this._exact = value.exact;
      this._headers.internalValue = value.headers;
      this._methods = value.methods;
      this._prefix = value.prefix;
      this._queryParameters.internalValue = value.queryParameters;
      this._regex = value.regex;
    }
  }

  // case_sensitive - computed: false, optional: true, required: false
  private _caseSensitive?: boolean | cdktf.IResolvable; 
  public get caseSensitive() {
    return this.getBooleanAttribute('case_sensitive');
  }
  public set caseSensitive(value: boolean | cdktf.IResolvable) {
    this._caseSensitive = value;
  }
  public resetCaseSensitive() {
    this._caseSensitive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caseSensitiveInput() {
    return this._caseSensitive;
  }

  // connect_matcher - computed: false, optional: true, required: false
  private _connectMatcher?: { [key: string]: string }; 
  public get connectMatcher() {
    return this.getStringMapAttribute('connect_matcher');
  }
  public set connectMatcher(value: { [key: string]: string }) {
    this._connectMatcher = value;
  }
  public resetConnectMatcher() {
    this._connectMatcher = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectMatcherInput() {
    return this._connectMatcher;
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // methods - computed: false, optional: true, required: false
  private _methods?: string[]; 
  public get methods() {
    return this.getListAttribute('methods');
  }
  public set methods(value: string[]) {
    this._methods = value;
  }
  public resetMethods() {
    this._methods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodsInput() {
    return this._methods;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // query_parameters - computed: false, optional: true, required: false
  private _queryParameters = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParametersList(this, "query_parameters", false);
  public get queryParameters() {
    return this._queryParameters;
  }
  public putQueryParameters(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersQueryParameters[] | cdktf.IResolvable) {
    this._queryParameters.internalValue = value;
  }
  public resetQueryParameters() {
    this._queryParameters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParametersInput() {
    return this._queryParameters.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchers[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesMatchersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#field DataK8SGatewaySoloIoRouteTableV1Manifest#field}
  */
  readonly field?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#override DataK8SGatewaySoloIoRouteTableV1Manifest#override}
  */
  readonly override?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field: cdktf.stringToTerraform(struct!.field),
    override: cdktf.booleanToTerraform(struct!.override),
    value: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field: {
      value: cdktf.stringToHclTerraform(struct!.field),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    override: {
      value: cdktf.booleanToHclTerraform(struct!.override),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    value: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.value),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._field !== undefined) {
      hasAnyValues = true;
      internalValueResult.field = this._field;
    }
    if (this._override !== undefined) {
      hasAnyValues = true;
      internalValueResult.override = this._override;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._field = undefined;
      this._override = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._field = value.field;
      this._override = value.override;
      this._value = value.value;
    }
  }

  // field - computed: false, optional: true, required: false
  private _field?: string; 
  public get field() {
    return this.getStringAttribute('field');
  }
  public set field(value: string) {
    this._field = value;
  }
  public resetField() {
    this._field = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldInput() {
    return this._field;
  }

  // override - computed: false, optional: true, required: false
  private _override?: boolean | cdktf.IResolvable; 
  public get override() {
    return this.getBooleanAttribute('override');
  }
  public set override(value: boolean | cdktf.IResolvable) {
    this._override = value;
  }
  public resetOverride() {
    this._override = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overrideInput() {
    return this._override;
  }

  // value - computed: false, optional: true, required: false
  private _value?: { [key: string]: string }; 
  public get value() {
    return this.getStringMapAttribute('value');
  }
  public set value(value: { [key: string]: string }) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#content DataK8SGatewaySoloIoRouteTableV1Manifest#content}
  */
  readonly content?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#role DataK8SGatewaySoloIoRouteTableV1Manifest#role}
  */
  readonly role?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content: cdktf.stringToTerraform(struct!.content),
    role: cdktf.stringToTerraform(struct!.role),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._content = undefined;
      this._role = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._content = value.content;
      this._role = value.role;
    }
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#content DataK8SGatewaySoloIoRouteTableV1Manifest#content}
  */
  readonly content?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#role DataK8SGatewaySoloIoRouteTableV1Manifest#role}
  */
  readonly role?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content: cdktf.stringToTerraform(struct!.content),
    role: cdktf.stringToTerraform(struct!.role),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content: {
      value: cdktf.stringToHclTerraform(struct!.content),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._content !== undefined) {
      hasAnyValues = true;
      internalValueResult.content = this._content;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._content = undefined;
      this._role = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._content = value.content;
      this._role = value.role;
    }
  }

  // content - computed: false, optional: true, required: false
  private _content?: string; 
  public get content() {
    return this.getStringAttribute('content');
  }
  public set content(value: string) {
    this._content = value;
  }
  public resetContent() {
    this._content = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentInput() {
    return this._content;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#append DataK8SGatewaySoloIoRouteTableV1Manifest#append}
  */
  readonly append?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prepend DataK8SGatewaySoloIoRouteTableV1Manifest#prepend}
  */
  readonly prepend?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendToTerraform, false)(struct!.append),
    prepend: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependToTerraform, false)(struct!.prepend),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendToHclTerraform, false)(struct!.append),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendList",
    },
    prepend: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependToHclTerraform, false)(struct!.prepend),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append?.internalValue;
    }
    if (this._prepend?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prepend = this._prepend?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append.internalValue = undefined;
      this._prepend.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append.internalValue = value.append;
      this._prepend.internalValue = value.prepend;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppendList(this, "append", false);
  public get append() {
    return this._append;
  }
  public putAppend(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentAppend[] | cdktf.IResolvable) {
    this._append.internalValue = value;
  }
  public resetAppend() {
    this._append.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append.internalValue;
  }

  // prepend - computed: false, optional: true, required: false
  private _prepend = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrependList(this, "prepend", false);
  public get prepend() {
    return this._prepend;
  }
  public putPrepend(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentPrepend[] | cdktf.IResolvable) {
    this._prepend.internalValue = value;
  }
  public resetPrepend() {
    this._prepend.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prependInput() {
    return this._prepend.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#message DataK8SGatewaySoloIoRouteTableV1Manifest#message}
  */
  readonly message?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#status_code DataK8SGatewaySoloIoRouteTableV1Manifest#status_code}
  */
  readonly statusCode?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponseToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    message: cdktf.stringToTerraform(struct!.message),
    status_code: cdktf.numberToTerraform(struct!.statusCode),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponseToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_code: {
      value: cdktf.numberToHclTerraform(struct!.statusCode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._statusCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusCode = this._statusCode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._message = undefined;
      this._statusCode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._message = value.message;
      this._statusCode = value.statusCode;
    }
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // status_code - computed: false, optional: true, required: false
  private _statusCode?: number; 
  public get statusCode() {
    return this.getNumberAttribute('status_code');
  }
  public set statusCode(value: number) {
    this._statusCode = value;
  }
  public resetStatusCode() {
    this._statusCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusCodeInput() {
    return this._statusCode;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#builtins DataK8SGatewaySoloIoRouteTableV1Manifest#builtins}
  */
  readonly builtins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#matches DataK8SGatewaySoloIoRouteTableV1Manifest#matches}
  */
  readonly matches?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    builtins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.builtins),
    matches: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matches),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    builtins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.builtins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matches),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._builtins !== undefined) {
      hasAnyValues = true;
      internalValueResult.builtins = this._builtins;
    }
    if (this._matches !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._builtins = undefined;
      this._matches = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._builtins = value.builtins;
      this._matches = value.matches;
    }
  }

  // builtins - computed: false, optional: true, required: false
  private _builtins?: string[]; 
  public get builtins() {
    return this.getListAttribute('builtins');
  }
  public set builtins(value: string[]) {
    this._builtins = value;
  }
  public resetBuiltins() {
    this._builtins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get builtinsInput() {
    return this._builtins;
  }

  // matches - computed: false, optional: true, required: false
  private _matches?: string[]; 
  public get matches() {
    return this.getListAttribute('matches');
  }
  public set matches(value: string[]) {
    this._matches = value;
  }
  public resetMatches() {
    this._matches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#match_type DataK8SGatewaySoloIoRouteTableV1Manifest#match_type}
  */
  readonly matchType?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    match_type: cdktf.stringToTerraform(struct!.matchType),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match_type: {
      value: cdktf.stringToHclTerraform(struct!.matchType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._matchType !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchType = this._matchType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._matchType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._matchType = value.matchType;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // match_type - computed: false, optional: true, required: false
  private _matchType?: string; 
  public get matchType() {
    return this.getStringAttribute('match_type');
  }
  public set matchType(value: string) {
    this._matchType = value;
  }
  public resetMatchType() {
    this._matchType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchTypeInput() {
    return this._matchType;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#host DataK8SGatewaySoloIoRouteTableV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#port DataK8SGatewaySoloIoRouteTableV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersToTerraform, false)(struct!.headers),
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersList",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#custom_response DataK8SGatewaySoloIoRouteTableV1Manifest#custom_response}
  */
  readonly customResponse?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#webhook DataK8SGatewaySoloIoRouteTableV1Manifest#webhook}
  */
  readonly webhook?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom_response: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponseToTerraform(struct!.customResponse),
    regex: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegexToTerraform(struct!.regex),
    webhook: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookToTerraform(struct!.webhook),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom_response: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponseToHclTerraform(struct!.customResponse),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse",
    },
    regex: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegexToHclTerraform(struct!.regex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex",
    },
    webhook: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookToHclTerraform(struct!.webhook),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._customResponse?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customResponse = this._customResponse?.internalValue;
    }
    if (this._regex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex?.internalValue;
    }
    if (this._webhook?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webhook = this._webhook?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._customResponse.internalValue = undefined;
      this._regex.internalValue = undefined;
      this._webhook.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._customResponse.internalValue = value.customResponse;
      this._regex.internalValue = value.regex;
      this._webhook.internalValue = value.webhook;
    }
  }

  // custom_response - computed: false, optional: true, required: false
  private _customResponse = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponseOutputReference(this, "custom_response");
  public get customResponse() {
    return this._customResponse;
  }
  public putCustomResponse(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestCustomResponse) {
    this._customResponse.internalValue = value;
  }
  public resetCustomResponse() {
    this._customResponse.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customResponseInput() {
    return this._customResponse.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegexOutputReference(this, "regex");
  public get regex() {
    return this._regex;
  }
  public putRegex(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestRegex) {
    this._regex.internalValue = value;
  }
  public resetRegex() {
    this._regex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex.internalValue;
  }

  // webhook - computed: false, optional: true, required: false
  private _webhook = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhookOutputReference(this, "webhook");
  public get webhook() {
    return this._webhook;
  }
  public putWebhook(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestWebhook) {
    this._webhook.internalValue = value;
  }
  public resetWebhook() {
    this._webhook.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webhookInput() {
    return this._webhook.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#builtins DataK8SGatewaySoloIoRouteTableV1Manifest#builtins}
  */
  readonly builtins?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#matches DataK8SGatewaySoloIoRouteTableV1Manifest#matches}
  */
  readonly matches?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    builtins: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.builtins),
    matches: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matches),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    builtins: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.builtins),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    matches: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matches),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._builtins !== undefined) {
      hasAnyValues = true;
      internalValueResult.builtins = this._builtins;
    }
    if (this._matches !== undefined) {
      hasAnyValues = true;
      internalValueResult.matches = this._matches;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._builtins = undefined;
      this._matches = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._builtins = value.builtins;
      this._matches = value.matches;
    }
  }

  // builtins - computed: false, optional: true, required: false
  private _builtins?: string[]; 
  public get builtins() {
    return this.getListAttribute('builtins');
  }
  public set builtins(value: string[]) {
    this._builtins = value;
  }
  public resetBuiltins() {
    this._builtins = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get builtinsInput() {
    return this._builtins;
  }

  // matches - computed: false, optional: true, required: false
  private _matches?: string[]; 
  public get matches() {
    return this.getListAttribute('matches');
  }
  public set matches(value: string[]) {
    this._matches = value;
  }
  public resetMatches() {
    this._matches = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchesInput() {
    return this._matches;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#match_type DataK8SGatewaySoloIoRouteTableV1Manifest#match_type}
  */
  readonly matchType?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    match_type: cdktf.stringToTerraform(struct!.matchType),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    match_type: {
      value: cdktf.stringToHclTerraform(struct!.matchType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._matchType !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchType = this._matchType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._matchType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._matchType = value.matchType;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // match_type - computed: false, optional: true, required: false
  private _matchType?: string; 
  public get matchType() {
    return this.getStringAttribute('match_type');
  }
  public set matchType(value: string) {
    this._matchType = value;
  }
  public resetMatchType() {
    this._matchType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchTypeInput() {
    return this._matchType;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#host DataK8SGatewaySoloIoRouteTableV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#port DataK8SGatewaySoloIoRouteTableV1Manifest#port}
  */
  readonly port?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersToTerraform, false)(struct!.headers),
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersList",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#webhook DataK8SGatewaySoloIoRouteTableV1Manifest#webhook}
  */
  readonly webhook?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegexToTerraform(struct!.regex),
    webhook: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookToTerraform(struct!.webhook),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegexToHclTerraform(struct!.regex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex",
    },
    webhook: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookToHclTerraform(struct!.webhook),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex?.internalValue;
    }
    if (this._webhook?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.webhook = this._webhook?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex.internalValue = undefined;
      this._webhook.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex.internalValue = value.regex;
      this._webhook.internalValue = value.webhook;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegexOutputReference(this, "regex");
  public get regex() {
    return this._regex;
  }
  public putRegex(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseRegex) {
    this._regex.internalValue = value;
  }
  public resetRegex() {
    this._regex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex.internalValue;
  }

  // webhook - computed: false, optional: true, required: false
  private _webhook = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhookOutputReference(this, "webhook");
  public get webhook() {
    return this._webhook;
  }
  public putWebhook(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseWebhook) {
    this._webhook.internalValue = value;
  }
  public resetWebhook() {
    this._webhook.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get webhookInput() {
    return this._webhook.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request DataK8SGatewaySoloIoRouteTableV1Manifest#request}
  */
  readonly request?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#response DataK8SGatewaySoloIoRouteTableV1Manifest#response}
  */
  readonly response?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestToTerraform(struct!.request),
    response: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseToTerraform(struct!.response),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestToHclTerraform(struct!.request),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest",
    },
    response: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseToHclTerraform(struct!.response),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._request?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.request = this._request?.internalValue;
    }
    if (this._response?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.response = this._response?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._request.internalValue = undefined;
      this._response.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._request.internalValue = value.request;
      this._response.internalValue = value.response;
    }
  }

  // request - computed: false, optional: true, required: false
  private _request = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequestOutputReference(this, "request");
  public get request() {
    return this._request;
  }
  public putRequest(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardRequest) {
    this._request.internalValue = value;
  }
  public resetRequest() {
    this._request.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestInput() {
    return this._request.internalValue;
  }

  // response - computed: false, optional: true, required: false
  private _response = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponseOutputReference(this, "response");
  public get response() {
    return this._response;
  }
  public putResponse(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardResponse) {
    this._response.internalValue = value;
  }
  public resetResponse() {
    this._response.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseInput() {
    return this._response.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#collection_name DataK8SGatewaySoloIoRouteTableV1Manifest#collection_name}
  */
  readonly collectionName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#connection_string DataK8SGatewaySoloIoRouteTableV1Manifest#connection_string}
  */
  readonly connectionString?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgresToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collection_name: cdktf.stringToTerraform(struct!.collectionName),
    connection_string: cdktf.stringToTerraform(struct!.connectionString),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgresToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collection_name: {
      value: cdktf.stringToHclTerraform(struct!.collectionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_string: {
      value: cdktf.stringToHclTerraform(struct!.connectionString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgresOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectionName = this._collectionName;
    }
    if (this._connectionString !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectionName = undefined;
      this._connectionString = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectionName = value.collectionName;
      this._connectionString = value.connectionString;
    }
  }

  // collection_name - computed: false, optional: true, required: false
  private _collectionName?: string; 
  public get collectionName() {
    return this.getStringAttribute('collection_name');
  }
  public set collectionName(value: string) {
    this._collectionName = value;
  }
  public resetCollectionName() {
    this._collectionName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectionNameInput() {
    return this._collectionName;
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString?: string; 
  public get connectionString() {
    return this.getStringAttribute('connection_string');
  }
  public set connectionString(value: string) {
    this._connectionString = value;
  }
  public resetConnectionString() {
    this._connectionString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#postgres DataK8SGatewaySoloIoRouteTableV1Manifest#postgres}
  */
  readonly postgres?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastoreToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    postgres: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgresToTerraform(struct!.postgres),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastoreToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    postgres: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgresToHclTerraform(struct!.postgres),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._postgres?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.postgres = this._postgres?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._postgres.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._postgres.internalValue = value.postgres;
    }
  }

  // postgres - computed: false, optional: true, required: false
  private _postgres = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgresOutputReference(this, "postgres");
  public get postgres() {
    return this._postgres;
  }
  public putPostgres(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastorePostgres) {
    this._postgres.internalValue = value;
  }
  public resetPostgres() {
    this._postgres.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get postgresInput() {
    return this._postgres.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#inline DataK8SGatewaySoloIoRouteTableV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteTableV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#api_version DataK8SGatewaySoloIoRouteTableV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#auth_token DataK8SGatewaySoloIoRouteTableV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#deployment_name DataK8SGatewaySoloIoRouteTableV1Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#endpoint DataK8SGatewaySoloIoRouteTableV1Manifest#endpoint}
  */
  readonly endpoint?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenToTerraform(struct!.authToken),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._deploymentName = undefined;
      this._endpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._deploymentName = value.deploymentName;
      this._endpoint = value.endpoint;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#inline DataK8SGatewaySoloIoRouteTableV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteTableV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#auth_token DataK8SGatewaySoloIoRouteTableV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenToTerraform(struct!.authToken),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#azure_openai DataK8SGatewaySoloIoRouteTableV1Manifest#azure_openai}
  */
  readonly azureOpenai?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#openai DataK8SGatewaySoloIoRouteTableV1Manifest#openai}
  */
  readonly openai?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    azure_openai: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiToTerraform(struct!.azureOpenai),
    openai: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiToTerraform(struct!.openai),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    azure_openai: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiToHclTerraform(struct!.azureOpenai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai",
    },
    openai: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiToHclTerraform(struct!.openai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._azureOpenai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureOpenai = this._azureOpenai?.internalValue;
    }
    if (this._openai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openai = this._openai?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = undefined;
      this._openai.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = value.azureOpenai;
      this._openai.internalValue = value.openai;
    }
  }

  // azure_openai - computed: false, optional: true, required: false
  private _azureOpenai = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenaiOutputReference(this, "azure_openai");
  public get azureOpenai() {
    return this._azureOpenai;
  }
  public putAzureOpenai(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingAzureOpenai) {
    this._azureOpenai.internalValue = value;
  }
  public resetAzureOpenai() {
    this._azureOpenai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureOpenaiInput() {
    return this._azureOpenai.internalValue;
  }

  // openai - computed: false, optional: true, required: false
  private _openai = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenaiOutputReference(this, "openai");
  public get openai() {
    return this._openai;
  }
  public putOpenai(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOpenai) {
    this._openai.internalValue = value;
  }
  public resetOpenai() {
    this._openai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openaiInput() {
    return this._openai.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#datastore DataK8SGatewaySoloIoRouteTableV1Manifest#datastore}
  */
  readonly datastore?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#embedding DataK8SGatewaySoloIoRouteTableV1Manifest#embedding}
  */
  readonly embedding?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prompt_template DataK8SGatewaySoloIoRouteTableV1Manifest#prompt_template}
  */
  readonly promptTemplate?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datastore: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastoreToTerraform(struct!.datastore),
    embedding: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingToTerraform(struct!.embedding),
    prompt_template: cdktf.stringToTerraform(struct!.promptTemplate),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datastore: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastoreToHclTerraform(struct!.datastore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore",
    },
    embedding: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingToHclTerraform(struct!.embedding),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding",
    },
    prompt_template: {
      value: cdktf.stringToHclTerraform(struct!.promptTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datastore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datastore = this._datastore?.internalValue;
    }
    if (this._embedding?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.embedding = this._embedding?.internalValue;
    }
    if (this._promptTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.promptTemplate = this._promptTemplate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datastore.internalValue = undefined;
      this._embedding.internalValue = undefined;
      this._promptTemplate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datastore.internalValue = value.datastore;
      this._embedding.internalValue = value.embedding;
      this._promptTemplate = value.promptTemplate;
    }
  }

  // datastore - computed: false, optional: true, required: false
  private _datastore = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastoreOutputReference(this, "datastore");
  public get datastore() {
    return this._datastore;
  }
  public putDatastore(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagDatastore) {
    this._datastore.internalValue = value;
  }
  public resetDatastore() {
    this._datastore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datastoreInput() {
    return this._datastore.internalValue;
  }

  // embedding - computed: false, optional: true, required: false
  private _embedding = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbeddingOutputReference(this, "embedding");
  public get embedding() {
    return this._embedding;
  }
  public putEmbedding(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagEmbedding) {
    this._embedding.internalValue = value;
  }
  public resetEmbedding() {
    this._embedding.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get embeddingInput() {
    return this._embedding.internalValue;
  }

  // prompt_template - computed: false, optional: true, required: false
  private _promptTemplate?: string; 
  public get promptTemplate() {
    return this.getStringAttribute('prompt_template');
  }
  public set promptTemplate(value: string) {
    this._promptTemplate = value;
  }
  public resetPromptTemplate() {
    this._promptTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promptTemplateInput() {
    return this._promptTemplate;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#connection_string DataK8SGatewaySoloIoRouteTableV1Manifest#connection_string}
  */
  readonly connectionString?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#score_threshold DataK8SGatewaySoloIoRouteTableV1Manifest#score_threshold}
  */
  readonly scoreThreshold?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedisToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_string: cdktf.stringToTerraform(struct!.connectionString),
    score_threshold: cdktf.numberToTerraform(struct!.scoreThreshold),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedisToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_string: {
      value: cdktf.stringToHclTerraform(struct!.connectionString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    score_threshold: {
      value: cdktf.numberToHclTerraform(struct!.scoreThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionString !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString;
    }
    if (this._scoreThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.scoreThreshold = this._scoreThreshold;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionString = undefined;
      this._scoreThreshold = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionString = value.connectionString;
      this._scoreThreshold = value.scoreThreshold;
    }
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString?: string; 
  public get connectionString() {
    return this.getStringAttribute('connection_string');
  }
  public set connectionString(value: string) {
    this._connectionString = value;
  }
  public resetConnectionString() {
    this._connectionString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString;
  }

  // score_threshold - computed: false, optional: true, required: false
  private _scoreThreshold?: number; 
  public get scoreThreshold() {
    return this.getNumberAttribute('score_threshold');
  }
  public set scoreThreshold(value: number) {
    this._scoreThreshold = value;
  }
  public resetScoreThreshold() {
    this._scoreThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scoreThresholdInput() {
    return this._scoreThreshold;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#grpc_port DataK8SGatewaySoloIoRouteTableV1Manifest#grpc_port}
  */
  readonly grpcPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#host DataK8SGatewaySoloIoRouteTableV1Manifest#host}
  */
  readonly host?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#http_port DataK8SGatewaySoloIoRouteTableV1Manifest#http_port}
  */
  readonly httpPort?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#insecure DataK8SGatewaySoloIoRouteTableV1Manifest#insecure}
  */
  readonly insecure?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviateToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_port: cdktf.numberToTerraform(struct!.grpcPort),
    host: cdktf.stringToTerraform(struct!.host),
    http_port: cdktf.numberToTerraform(struct!.httpPort),
    insecure: cdktf.booleanToTerraform(struct!.insecure),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviateToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_port: {
      value: cdktf.numberToHclTerraform(struct!.grpcPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_port: {
      value: cdktf.numberToHclTerraform(struct!.httpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    insecure: {
      value: cdktf.booleanToHclTerraform(struct!.insecure),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcPort = this._grpcPort;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._httpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpPort = this._httpPort;
    }
    if (this._insecure !== undefined) {
      hasAnyValues = true;
      internalValueResult.insecure = this._insecure;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcPort = undefined;
      this._host = undefined;
      this._httpPort = undefined;
      this._insecure = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcPort = value.grpcPort;
      this._host = value.host;
      this._httpPort = value.httpPort;
      this._insecure = value.insecure;
    }
  }

  // grpc_port - computed: false, optional: true, required: false
  private _grpcPort?: number; 
  public get grpcPort() {
    return this.getNumberAttribute('grpc_port');
  }
  public set grpcPort(value: number) {
    this._grpcPort = value;
  }
  public resetGrpcPort() {
    this._grpcPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcPortInput() {
    return this._grpcPort;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // http_port - computed: false, optional: true, required: false
  private _httpPort?: number; 
  public get httpPort() {
    return this.getNumberAttribute('http_port');
  }
  public set httpPort(value: number) {
    this._httpPort = value;
  }
  public resetHttpPort() {
    this._httpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpPortInput() {
    return this._httpPort;
  }

  // insecure - computed: false, optional: true, required: false
  private _insecure?: boolean | cdktf.IResolvable; 
  public get insecure() {
    return this.getBooleanAttribute('insecure');
  }
  public set insecure(value: boolean | cdktf.IResolvable) {
    this._insecure = value;
  }
  public resetInsecure() {
    this._insecure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insecureInput() {
    return this._insecure;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#redis DataK8SGatewaySoloIoRouteTableV1Manifest#redis}
  */
  readonly redis?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#weaviate DataK8SGatewaySoloIoRouteTableV1Manifest#weaviate}
  */
  readonly weaviate?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    redis: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedisToTerraform(struct!.redis),
    weaviate: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviateToTerraform(struct!.weaviate),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    redis: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedisToHclTerraform(struct!.redis),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis",
    },
    weaviate: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviateToHclTerraform(struct!.weaviate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._redis?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.redis = this._redis?.internalValue;
    }
    if (this._weaviate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.weaviate = this._weaviate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._redis.internalValue = undefined;
      this._weaviate.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._redis.internalValue = value.redis;
      this._weaviate.internalValue = value.weaviate;
    }
  }

  // redis - computed: false, optional: true, required: false
  private _redis = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedisOutputReference(this, "redis");
  public get redis() {
    return this._redis;
  }
  public putRedis(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreRedis) {
    this._redis.internalValue = value;
  }
  public resetRedis() {
    this._redis.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get redisInput() {
    return this._redis.internalValue;
  }

  // weaviate - computed: false, optional: true, required: false
  private _weaviate = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviateOutputReference(this, "weaviate");
  public get weaviate() {
    return this._weaviate;
  }
  public putWeaviate(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreWeaviate) {
    this._weaviate.internalValue = value;
  }
  public resetWeaviate() {
    this._weaviate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weaviateInput() {
    return this._weaviate.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#inline DataK8SGatewaySoloIoRouteTableV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteTableV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#api_version DataK8SGatewaySoloIoRouteTableV1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#auth_token DataK8SGatewaySoloIoRouteTableV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#deployment_name DataK8SGatewaySoloIoRouteTableV1Manifest#deployment_name}
  */
  readonly deploymentName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#endpoint DataK8SGatewaySoloIoRouteTableV1Manifest#endpoint}
  */
  readonly endpoint?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    auth_token: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToTerraform(struct!.authToken),
    deployment_name: cdktf.stringToTerraform(struct!.deploymentName),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_token: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken",
    },
    deployment_name: {
      value: cdktf.stringToHclTerraform(struct!.deploymentName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    if (this._deploymentName !== undefined) {
      hasAnyValues = true;
      internalValueResult.deploymentName = this._deploymentName;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._authToken.internalValue = undefined;
      this._deploymentName = undefined;
      this._endpoint = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._authToken.internalValue = value.authToken;
      this._deploymentName = value.deploymentName;
      this._endpoint = value.endpoint;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }

  // deployment_name - computed: false, optional: true, required: false
  private _deploymentName?: string; 
  public get deploymentName() {
    return this.getStringAttribute('deployment_name');
  }
  public set deploymentName(value: string) {
    this._deploymentName = value;
  }
  public resetDeploymentName() {
    this._deploymentName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deploymentNameInput() {
    return this._deploymentName;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#inline DataK8SGatewaySoloIoRouteTableV1Manifest#inline}
  */
  readonly inline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#secret_ref DataK8SGatewaySoloIoRouteTableV1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    inline: cdktf.stringToTerraform(struct!.inline),
    secret_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    inline: {
      value: cdktf.stringToHclTerraform(struct!.inline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inline !== undefined) {
      hasAnyValues = true;
      internalValueResult.inline = this._inline;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inline = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inline = value.inline;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // inline - computed: false, optional: true, required: false
  private _inline?: string; 
  public get inline() {
    return this.getStringAttribute('inline');
  }
  public set inline(value: string) {
    this._inline = value;
  }
  public resetInline() {
    this._inline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inlineInput() {
    return this._inline;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#auth_token DataK8SGatewaySoloIoRouteTableV1Manifest#auth_token}
  */
  readonly authToken?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToTerraform(struct!.authToken),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenToHclTerraform(struct!.authToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken.internalValue = value.authToken;
    }
  }

  // auth_token - computed: false, optional: true, required: false
  private _authToken = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthTokenOutputReference(this, "auth_token");
  public get authToken() {
    return this._authToken;
  }
  public putAuthToken(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiAuthToken) {
    this._authToken.internalValue = value;
  }
  public resetAuthToken() {
    this._authToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#azure_openai DataK8SGatewaySoloIoRouteTableV1Manifest#azure_openai}
  */
  readonly azureOpenai?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#openai DataK8SGatewaySoloIoRouteTableV1Manifest#openai}
  */
  readonly openai?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    azure_openai: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiToTerraform(struct!.azureOpenai),
    openai: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiToTerraform(struct!.openai),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    azure_openai: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiToHclTerraform(struct!.azureOpenai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai",
    },
    openai: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiToHclTerraform(struct!.openai),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._azureOpenai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureOpenai = this._azureOpenai?.internalValue;
    }
    if (this._openai?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.openai = this._openai?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = undefined;
      this._openai.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._azureOpenai.internalValue = value.azureOpenai;
      this._openai.internalValue = value.openai;
    }
  }

  // azure_openai - computed: false, optional: true, required: false
  private _azureOpenai = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenaiOutputReference(this, "azure_openai");
  public get azureOpenai() {
    return this._azureOpenai;
  }
  public putAzureOpenai(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingAzureOpenai) {
    this._azureOpenai.internalValue = value;
  }
  public resetAzureOpenai() {
    this._azureOpenai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureOpenaiInput() {
    return this._azureOpenai.internalValue;
  }

  // openai - computed: false, optional: true, required: false
  private _openai = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenaiOutputReference(this, "openai");
  public get openai() {
    return this._openai;
  }
  public putOpenai(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOpenai) {
    this._openai.internalValue = value;
  }
  public resetOpenai() {
    this._openai.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get openaiInput() {
    return this._openai.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#datastore DataK8SGatewaySoloIoRouteTableV1Manifest#datastore}
  */
  readonly datastore?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#embedding DataK8SGatewaySoloIoRouteTableV1Manifest#embedding}
  */
  readonly embedding?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#mode DataK8SGatewaySoloIoRouteTableV1Manifest#mode}
  */
  readonly mode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#ttl DataK8SGatewaySoloIoRouteTableV1Manifest#ttl}
  */
  readonly ttl?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    datastore: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreToTerraform(struct!.datastore),
    embedding: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingToTerraform(struct!.embedding),
    mode: cdktf.stringToTerraform(struct!.mode),
    ttl: cdktf.numberToTerraform(struct!.ttl),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    datastore: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreToHclTerraform(struct!.datastore),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore",
    },
    embedding: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingToHclTerraform(struct!.embedding),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.numberToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._datastore?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.datastore = this._datastore?.internalValue;
    }
    if (this._embedding?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.embedding = this._embedding?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._datastore.internalValue = undefined;
      this._embedding.internalValue = undefined;
      this._mode = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._datastore.internalValue = value.datastore;
      this._embedding.internalValue = value.embedding;
      this._mode = value.mode;
      this._ttl = value.ttl;
    }
  }

  // datastore - computed: false, optional: true, required: false
  private _datastore = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastoreOutputReference(this, "datastore");
  public get datastore() {
    return this._datastore;
  }
  public putDatastore(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheDatastore) {
    this._datastore.internalValue = value;
  }
  public resetDatastore() {
    this._datastore.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get datastoreInput() {
    return this._datastore.internalValue;
  }

  // embedding - computed: false, optional: true, required: false
  private _embedding = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbeddingOutputReference(this, "embedding");
  public get embedding() {
    return this._embedding;
  }
  public putEmbedding(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheEmbedding) {
    this._embedding.internalValue = value;
  }
  public resetEmbedding() {
    this._embedding.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get embeddingInput() {
    return this._embedding.internalValue;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: number; 
  public get ttl() {
    return this.getNumberAttribute('ttl');
  }
  public set ttl(value: number) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAi {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#defaults DataK8SGatewaySoloIoRouteTableV1Manifest#defaults}
  */
  readonly defaults?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prompt_enrichment DataK8SGatewaySoloIoRouteTableV1Manifest#prompt_enrichment}
  */
  readonly promptEnrichment?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prompt_guard DataK8SGatewaySoloIoRouteTableV1Manifest#prompt_guard}
  */
  readonly promptGuard?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#rag DataK8SGatewaySoloIoRouteTableV1Manifest#rag}
  */
  readonly rag?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#route_type DataK8SGatewaySoloIoRouteTableV1Manifest#route_type}
  */
  readonly routeType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#semantic_cache DataK8SGatewaySoloIoRouteTableV1Manifest#semantic_cache}
  */
  readonly semanticCache?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    defaults: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsToTerraform, false)(struct!.defaults),
    prompt_enrichment: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentToTerraform(struct!.promptEnrichment),
    prompt_guard: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardToTerraform(struct!.promptGuard),
    rag: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagToTerraform(struct!.rag),
    route_type: cdktf.stringToTerraform(struct!.routeType),
    semantic_cache: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheToTerraform(struct!.semanticCache),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    defaults: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsToHclTerraform, false)(struct!.defaults),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsList",
    },
    prompt_enrichment: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentToHclTerraform(struct!.promptEnrichment),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment",
    },
    prompt_guard: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardToHclTerraform(struct!.promptGuard),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard",
    },
    rag: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagToHclTerraform(struct!.rag),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag",
    },
    route_type: {
      value: cdktf.stringToHclTerraform(struct!.routeType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    semantic_cache: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheToHclTerraform(struct!.semanticCache),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaults?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaults = this._defaults?.internalValue;
    }
    if (this._promptEnrichment?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.promptEnrichment = this._promptEnrichment?.internalValue;
    }
    if (this._promptGuard?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.promptGuard = this._promptGuard?.internalValue;
    }
    if (this._rag?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rag = this._rag?.internalValue;
    }
    if (this._routeType !== undefined) {
      hasAnyValues = true;
      internalValueResult.routeType = this._routeType;
    }
    if (this._semanticCache?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.semanticCache = this._semanticCache?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaults.internalValue = undefined;
      this._promptEnrichment.internalValue = undefined;
      this._promptGuard.internalValue = undefined;
      this._rag.internalValue = undefined;
      this._routeType = undefined;
      this._semanticCache.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaults.internalValue = value.defaults;
      this._promptEnrichment.internalValue = value.promptEnrichment;
      this._promptGuard.internalValue = value.promptGuard;
      this._rag.internalValue = value.rag;
      this._routeType = value.routeType;
      this._semanticCache.internalValue = value.semanticCache;
    }
  }

  // defaults - computed: false, optional: true, required: false
  private _defaults = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaultsList(this, "defaults", false);
  public get defaults() {
    return this._defaults;
  }
  public putDefaults(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiDefaults[] | cdktf.IResolvable) {
    this._defaults.internalValue = value;
  }
  public resetDefaults() {
    this._defaults.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultsInput() {
    return this._defaults.internalValue;
  }

  // prompt_enrichment - computed: false, optional: true, required: false
  private _promptEnrichment = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichmentOutputReference(this, "prompt_enrichment");
  public get promptEnrichment() {
    return this._promptEnrichment;
  }
  public putPromptEnrichment(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptEnrichment) {
    this._promptEnrichment.internalValue = value;
  }
  public resetPromptEnrichment() {
    this._promptEnrichment.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promptEnrichmentInput() {
    return this._promptEnrichment.internalValue;
  }

  // prompt_guard - computed: false, optional: true, required: false
  private _promptGuard = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuardOutputReference(this, "prompt_guard");
  public get promptGuard() {
    return this._promptGuard;
  }
  public putPromptGuard(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiPromptGuard) {
    this._promptGuard.internalValue = value;
  }
  public resetPromptGuard() {
    this._promptGuard.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get promptGuardInput() {
    return this._promptGuard.internalValue;
  }

  // rag - computed: false, optional: true, required: false
  private _rag = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRagOutputReference(this, "rag");
  public get rag() {
    return this._rag;
  }
  public putRag(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiRag) {
    this._rag.internalValue = value;
  }
  public resetRag() {
    this._rag.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ragInput() {
    return this._rag.internalValue;
  }

  // route_type - computed: false, optional: true, required: false
  private _routeType?: string; 
  public get routeType() {
    return this.getStringAttribute('route_type');
  }
  public set routeType(value: string) {
    this._routeType = value;
  }
  public resetRouteType() {
    this._routeType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routeTypeInput() {
    return this._routeType;
  }

  // semantic_cache - computed: false, optional: true, required: false
  private _semanticCache = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCacheOutputReference(this, "semantic_cache");
  public get semanticCache() {
    return this._semanticCache;
  }
  public putSemanticCache(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsAiSemanticCache) {
    this._semanticCache.internalValue = value;
  }
  public resetSemanticCache() {
    this._semanticCache.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get semanticCacheInput() {
    return this._semanticCache.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_request_bytes DataK8SGatewaySoloIoRouteTableV1Manifest#max_request_bytes}
  */
  readonly maxRequestBytes?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBufferToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_request_bytes: cdktf.numberToTerraform(struct!.maxRequestBytes),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBufferToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_request_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBufferOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxRequestBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestBytes = this._maxRequestBytes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxRequestBytes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxRequestBytes = value.maxRequestBytes;
    }
  }

  // max_request_bytes - computed: false, optional: true, required: false
  private _maxRequestBytes?: number; 
  public get maxRequestBytes() {
    return this.getNumberAttribute('max_request_bytes');
  }
  public set maxRequestBytes(value: number) {
    this._maxRequestBytes = value;
  }
  public resetMaxRequestBytes() {
    this._maxRequestBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestBytesInput() {
    return this._maxRequestBytes;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRoute {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#buffer DataK8SGatewaySoloIoRouteTableV1Manifest#buffer}
  */
  readonly buffer?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#disabled DataK8SGatewaySoloIoRouteTableV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    buffer: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBufferToTerraform(struct!.buffer),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRoute | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    buffer: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBufferToHclTerraform(struct!.buffer),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRoute | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._buffer?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.buffer = this._buffer?.internalValue;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRoute | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._buffer.internalValue = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._buffer.internalValue = value.buffer;
      this._disabled = value.disabled;
    }
  }

  // buffer - computed: false, optional: true, required: false
  private _buffer = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBufferOutputReference(this, "buffer");
  public get buffer() {
    return this._buffer;
  }
  public putBuffer(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsBufferPerRouteBuffer) {
    this._buffer.internalValue = value;
  }
  public resetBuffer() {
    this._buffer.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bufferInput() {
    return this._buffer.internalValue;
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCors {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#allow_credentials DataK8SGatewaySoloIoRouteTableV1Manifest#allow_credentials}
  */
  readonly allowCredentials?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#allow_headers DataK8SGatewaySoloIoRouteTableV1Manifest#allow_headers}
  */
  readonly allowHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#allow_methods DataK8SGatewaySoloIoRouteTableV1Manifest#allow_methods}
  */
  readonly allowMethods?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#allow_origin DataK8SGatewaySoloIoRouteTableV1Manifest#allow_origin}
  */
  readonly allowOrigin?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#allow_origin_regex DataK8SGatewaySoloIoRouteTableV1Manifest#allow_origin_regex}
  */
  readonly allowOriginRegex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#disable_for_route DataK8SGatewaySoloIoRouteTableV1Manifest#disable_for_route}
  */
  readonly disableForRoute?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#expose_headers DataK8SGatewaySoloIoRouteTableV1Manifest#expose_headers}
  */
  readonly exposeHeaders?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_age DataK8SGatewaySoloIoRouteTableV1Manifest#max_age}
  */
  readonly maxAge?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCorsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_credentials: cdktf.booleanToTerraform(struct!.allowCredentials),
    allow_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowHeaders),
    allow_methods: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowMethods),
    allow_origin: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowOrigin),
    allow_origin_regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowOriginRegex),
    disable_for_route: cdktf.booleanToTerraform(struct!.disableForRoute),
    expose_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.exposeHeaders),
    max_age: cdktf.stringToTerraform(struct!.maxAge),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCorsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_credentials: {
      value: cdktf.booleanToHclTerraform(struct!.allowCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    allow_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_methods: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowMethods),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_origin: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowOrigin),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    allow_origin_regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowOriginRegex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    disable_for_route: {
      value: cdktf.booleanToHclTerraform(struct!.disableForRoute),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    expose_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.exposeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_age: {
      value: cdktf.stringToHclTerraform(struct!.maxAge),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowCredentials = this._allowCredentials;
    }
    if (this._allowHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowHeaders = this._allowHeaders;
    }
    if (this._allowMethods !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMethods = this._allowMethods;
    }
    if (this._allowOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowOrigin = this._allowOrigin;
    }
    if (this._allowOriginRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowOriginRegex = this._allowOriginRegex;
    }
    if (this._disableForRoute !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableForRoute = this._disableForRoute;
    }
    if (this._exposeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.exposeHeaders = this._exposeHeaders;
    }
    if (this._maxAge !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxAge = this._maxAge;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowCredentials = undefined;
      this._allowHeaders = undefined;
      this._allowMethods = undefined;
      this._allowOrigin = undefined;
      this._allowOriginRegex = undefined;
      this._disableForRoute = undefined;
      this._exposeHeaders = undefined;
      this._maxAge = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowCredentials = value.allowCredentials;
      this._allowHeaders = value.allowHeaders;
      this._allowMethods = value.allowMethods;
      this._allowOrigin = value.allowOrigin;
      this._allowOriginRegex = value.allowOriginRegex;
      this._disableForRoute = value.disableForRoute;
      this._exposeHeaders = value.exposeHeaders;
      this._maxAge = value.maxAge;
    }
  }

  // allow_credentials - computed: false, optional: true, required: false
  private _allowCredentials?: boolean | cdktf.IResolvable; 
  public get allowCredentials() {
    return this.getBooleanAttribute('allow_credentials');
  }
  public set allowCredentials(value: boolean | cdktf.IResolvable) {
    this._allowCredentials = value;
  }
  public resetAllowCredentials() {
    this._allowCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowCredentialsInput() {
    return this._allowCredentials;
  }

  // allow_headers - computed: false, optional: true, required: false
  private _allowHeaders?: string[]; 
  public get allowHeaders() {
    return this.getListAttribute('allow_headers');
  }
  public set allowHeaders(value: string[]) {
    this._allowHeaders = value;
  }
  public resetAllowHeaders() {
    this._allowHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowHeadersInput() {
    return this._allowHeaders;
  }

  // allow_methods - computed: false, optional: true, required: false
  private _allowMethods?: string[]; 
  public get allowMethods() {
    return this.getListAttribute('allow_methods');
  }
  public set allowMethods(value: string[]) {
    this._allowMethods = value;
  }
  public resetAllowMethods() {
    this._allowMethods = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMethodsInput() {
    return this._allowMethods;
  }

  // allow_origin - computed: false, optional: true, required: false
  private _allowOrigin?: string[]; 
  public get allowOrigin() {
    return this.getListAttribute('allow_origin');
  }
  public set allowOrigin(value: string[]) {
    this._allowOrigin = value;
  }
  public resetAllowOrigin() {
    this._allowOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowOriginInput() {
    return this._allowOrigin;
  }

  // allow_origin_regex - computed: false, optional: true, required: false
  private _allowOriginRegex?: string[]; 
  public get allowOriginRegex() {
    return this.getListAttribute('allow_origin_regex');
  }
  public set allowOriginRegex(value: string[]) {
    this._allowOriginRegex = value;
  }
  public resetAllowOriginRegex() {
    this._allowOriginRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowOriginRegexInput() {
    return this._allowOriginRegex;
  }

  // disable_for_route - computed: false, optional: true, required: false
  private _disableForRoute?: boolean | cdktf.IResolvable; 
  public get disableForRoute() {
    return this.getBooleanAttribute('disable_for_route');
  }
  public set disableForRoute(value: boolean | cdktf.IResolvable) {
    this._disableForRoute = value;
  }
  public resetDisableForRoute() {
    this._disableForRoute = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableForRouteInput() {
    return this._disableForRoute;
  }

  // expose_headers - computed: false, optional: true, required: false
  private _exposeHeaders?: string[]; 
  public get exposeHeaders() {
    return this.getListAttribute('expose_headers');
  }
  public set exposeHeaders(value: string[]) {
    this._exposeHeaders = value;
  }
  public resetExposeHeaders() {
    this._exposeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exposeHeadersInput() {
    return this._exposeHeaders;
  }

  // max_age - computed: false, optional: true, required: false
  private _maxAge?: string; 
  public get maxAge() {
    return this.getStringAttribute('max_age');
  }
  public set maxAge(value: string) {
    this._maxAge = value;
  }
  public resetMaxAge() {
    this._maxAge = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxAgeInput() {
    return this._maxAge;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_program_size DataK8SGatewaySoloIoRouteTableV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#google_re2 DataK8SGatewaySoloIoRouteTableV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#exact DataK8SGatewaySoloIoRouteTableV1Manifest#exact}
  */
  readonly exact?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#ignore_case DataK8SGatewaySoloIoRouteTableV1Manifest#ignore_case}
  */
  readonly ignoreCase?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prefix DataK8SGatewaySoloIoRouteTableV1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#safe_regex DataK8SGatewaySoloIoRouteTableV1Manifest#safe_regex}
  */
  readonly safeRegex?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#suffix DataK8SGatewaySoloIoRouteTableV1Manifest#suffix}
  */
  readonly suffix?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact: cdktf.stringToTerraform(struct!.exact),
    ignore_case: cdktf.booleanToTerraform(struct!.ignoreCase),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    safe_regex: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexToTerraform(struct!.safeRegex),
    suffix: cdktf.stringToTerraform(struct!.suffix),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact: {
      value: cdktf.stringToHclTerraform(struct!.exact),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_case: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreCase),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    safe_regex: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexToHclTerraform(struct!.safeRegex),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex",
    },
    suffix: {
      value: cdktf.stringToHclTerraform(struct!.suffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exact !== undefined) {
      hasAnyValues = true;
      internalValueResult.exact = this._exact;
    }
    if (this._ignoreCase !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreCase = this._ignoreCase;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._safeRegex?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeRegex = this._safeRegex?.internalValue;
    }
    if (this._suffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffix = this._suffix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exact = undefined;
      this._ignoreCase = undefined;
      this._prefix = undefined;
      this._safeRegex.internalValue = undefined;
      this._suffix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exact = value.exact;
      this._ignoreCase = value.ignoreCase;
      this._prefix = value.prefix;
      this._safeRegex.internalValue = value.safeRegex;
      this._suffix = value.suffix;
    }
  }

  // exact - computed: false, optional: true, required: false
  private _exact?: string; 
  public get exact() {
    return this.getStringAttribute('exact');
  }
  public set exact(value: string) {
    this._exact = value;
  }
  public resetExact() {
    this._exact = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactInput() {
    return this._exact;
  }

  // ignore_case - computed: false, optional: true, required: false
  private _ignoreCase?: boolean | cdktf.IResolvable; 
  public get ignoreCase() {
    return this.getBooleanAttribute('ignore_case');
  }
  public set ignoreCase(value: boolean | cdktf.IResolvable) {
    this._ignoreCase = value;
  }
  public resetIgnoreCase() {
    this._ignoreCase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreCaseInput() {
    return this._ignoreCase;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // safe_regex - computed: false, optional: true, required: false
  private _safeRegex = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegexOutputReference(this, "safe_regex");
  public get safeRegex() {
    return this._safeRegex;
  }
  public putSafeRegex(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsSafeRegex) {
    this._safeRegex.internalValue = value;
  }
  public resetSafeRegex() {
    this._safeRegex.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeRegexInput() {
    return this._safeRegex.internalValue;
  }

  // suffix - computed: false, optional: true, required: false
  private _suffix?: string; 
  public get suffix() {
    return this.getStringAttribute('suffix');
  }
  public set suffix(value: string) {
    this._suffix = value;
  }
  public resetSuffix() {
    this._suffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixInput() {
    return this._suffix;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#denominator DataK8SGatewaySoloIoRouteTableV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#numerator DataK8SGatewaySoloIoRouteTableV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#default_value DataK8SGatewaySoloIoRouteTableV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#runtime_key DataK8SGatewaySoloIoRouteTableV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#denominator DataK8SGatewaySoloIoRouteTableV1Manifest#denominator}
  */
  readonly denominator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#numerator DataK8SGatewaySoloIoRouteTableV1Manifest#numerator}
  */
  readonly numerator?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValueToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    denominator: cdktf.stringToTerraform(struct!.denominator),
    numerator: cdktf.numberToTerraform(struct!.numerator),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    denominator: {
      value: cdktf.stringToHclTerraform(struct!.denominator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    numerator: {
      value: cdktf.numberToHclTerraform(struct!.numerator),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValueOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._denominator !== undefined) {
      hasAnyValues = true;
      internalValueResult.denominator = this._denominator;
    }
    if (this._numerator !== undefined) {
      hasAnyValues = true;
      internalValueResult.numerator = this._numerator;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._denominator = undefined;
      this._numerator = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._denominator = value.denominator;
      this._numerator = value.numerator;
    }
  }

  // denominator - computed: false, optional: true, required: false
  private _denominator?: string; 
  public get denominator() {
    return this.getStringAttribute('denominator');
  }
  public set denominator(value: string) {
    this._denominator = value;
  }
  public resetDenominator() {
    this._denominator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get denominatorInput() {
    return this._denominator;
  }

  // numerator - computed: false, optional: true, required: false
  private _numerator?: number; 
  public get numerator() {
    return this.getNumberAttribute('numerator');
  }
  public set numerator(value: number) {
    this._numerator = value;
  }
  public resetNumerator() {
    this._numerator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numeratorInput() {
    return this._numerator;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#default_value DataK8SGatewaySoloIoRouteTableV1Manifest#default_value}
  */
  readonly defaultValue?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#runtime_key DataK8SGatewaySoloIoRouteTableV1Manifest#runtime_key}
  */
  readonly runtimeKey?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValueToTerraform(struct!.defaultValue),
    runtime_key: cdktf.stringToTerraform(struct!.runtimeKey),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValueToHclTerraform(struct!.defaultValue),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue",
    },
    runtime_key: {
      value: cdktf.stringToHclTerraform(struct!.runtimeKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue?.internalValue;
    }
    if (this._runtimeKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.runtimeKey = this._runtimeKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = undefined;
      this._runtimeKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue.internalValue = value.defaultValue;
      this._runtimeKey = value.runtimeKey;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValueOutputReference(this, "default_value");
  public get defaultValue() {
    return this._defaultValue;
  }
  public putDefaultValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledDefaultValue) {
    this._defaultValue.internalValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue.internalValue;
  }

  // runtime_key - computed: false, optional: true, required: false
  private _runtimeKey?: string; 
  public get runtimeKey() {
    return this.getStringAttribute('runtime_key');
  }
  public set runtimeKey(value: string) {
    this._runtimeKey = value;
  }
  public resetRuntimeKey() {
    this._runtimeKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runtimeKeyInput() {
    return this._runtimeKey;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrf {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#additional_origins DataK8SGatewaySoloIoRouteTableV1Manifest#additional_origins}
  */
  readonly additionalOrigins?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#filter_enabled DataK8SGatewaySoloIoRouteTableV1Manifest#filter_enabled}
  */
  readonly filterEnabled?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#shadow_enabled DataK8SGatewaySoloIoRouteTableV1Manifest#shadow_enabled}
  */
  readonly shadowEnabled?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_origins: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsToTerraform, false)(struct!.additionalOrigins),
    filter_enabled: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledToTerraform(struct!.filterEnabled),
    shadow_enabled: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledToTerraform(struct!.shadowEnabled),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrf | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_origins: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsToHclTerraform, false)(struct!.additionalOrigins),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsList",
    },
    filter_enabled: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledToHclTerraform(struct!.filterEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled",
    },
    shadow_enabled: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledToHclTerraform(struct!.shadowEnabled),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrf | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalOrigins?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalOrigins = this._additionalOrigins?.internalValue;
    }
    if (this._filterEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filterEnabled = this._filterEnabled?.internalValue;
    }
    if (this._shadowEnabled?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadowEnabled = this._shadowEnabled?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrf | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = undefined;
      this._filterEnabled.internalValue = undefined;
      this._shadowEnabled.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalOrigins.internalValue = value.additionalOrigins;
      this._filterEnabled.internalValue = value.filterEnabled;
      this._shadowEnabled.internalValue = value.shadowEnabled;
    }
  }

  // additional_origins - computed: false, optional: true, required: false
  private _additionalOrigins = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOriginsList(this, "additional_origins", false);
  public get additionalOrigins() {
    return this._additionalOrigins;
  }
  public putAdditionalOrigins(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfAdditionalOrigins[] | cdktf.IResolvable) {
    this._additionalOrigins.internalValue = value;
  }
  public resetAdditionalOrigins() {
    this._additionalOrigins.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalOriginsInput() {
    return this._additionalOrigins.internalValue;
  }

  // filter_enabled - computed: false, optional: true, required: false
  private _filterEnabled = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabledOutputReference(this, "filter_enabled");
  public get filterEnabled() {
    return this._filterEnabled;
  }
  public putFilterEnabled(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfFilterEnabled) {
    this._filterEnabled.internalValue = value;
  }
  public resetFilterEnabled() {
    this._filterEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filterEnabledInput() {
    return this._filterEnabled.internalValue;
  }

  // shadow_enabled - computed: false, optional: true, required: false
  private _shadowEnabled = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabledOutputReference(this, "shadow_enabled");
  public get shadowEnabled() {
    return this._shadowEnabled;
  }
  public putShadowEnabled(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsCsrfShadowEnabled) {
    this._shadowEnabled.internalValue = value;
  }
  public resetShadowEnabled() {
    this._shadowEnabled.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowEnabledInput() {
    return this._shadowEnabled.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercentToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#subgroup DataK8SGatewaySoloIoRouteTableV1Manifest#subgroup}
  */
  readonly subgroup?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    regex: cdktf.stringToTerraform(struct!.regex),
    subgroup: cdktf.numberToTerraform(struct!.subgroup),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subgroup: {
      value: cdktf.numberToHclTerraform(struct!.subgroup),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._subgroup !== undefined) {
      hasAnyValues = true;
      internalValueResult.subgroup = this._subgroup;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._regex = undefined;
      this._subgroup = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._regex = value.regex;
      this._subgroup = value.subgroup;
    }
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // subgroup - computed: false, optional: true, required: false
  private _subgroup?: number; 
  public get subgroup() {
    return this.getNumberAttribute('subgroup');
  }
  public set subgroup(value: number) {
    this._subgroup = value;
  }
  public resetSubgroup() {
    this._subgroup = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subgroupInput() {
    return this._subgroup;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#mask_char DataK8SGatewaySoloIoRouteTableV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#percent DataK8SGatewaySoloIoRouteTableV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex_actions DataK8SGatewaySoloIoRouteTableV1Manifest#regex_actions}
  */
  readonly regexActions?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercentToTerraform(struct!.percent),
    regex: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.regex),
    regex_actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsToTerraform, false)(struct!.regexActions),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent",
    },
    regex: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.regex),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    regex_actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsToHclTerraform, false)(struct!.regexActions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    if (this._regexActions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexActions = this._regexActions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
      this._regex = undefined;
      this._regexActions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
      this._regex = value.regex;
      this._regexActions.internalValue = value.regexActions;
    }
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string[]; 
  public get regex() {
    return this.getListAttribute('regex');
  }
  public set regex(value: string[]) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }

  // regex_actions - computed: false, optional: true, required: false
  private _regexActions = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActionsList(this, "regex_actions", false);
  public get regexActions() {
    return this._regexActions;
  }
  public putRegexActions(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionRegexActions[] | cdktf.IResolvable) {
    this._regexActions.internalValue = value;
  }
  public resetRegexActions() {
    this._regexActions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexActionsInput() {
    return this._regexActions.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercentToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.numberToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercentToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.numberToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercentOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: true, required: false
  private _value?: number; 
  public get value() {
    return this.getNumberAttribute('value');
  }
  public set value(value: number) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key_to_mask DataK8SGatewaySoloIoRouteTableV1Manifest#key_to_mask}
  */
  readonly keyToMask?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#mask_char DataK8SGatewaySoloIoRouteTableV1Manifest#mask_char}
  */
  readonly maskChar?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#percent DataK8SGatewaySoloIoRouteTableV1Manifest#percent}
  */
  readonly percent?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key_to_mask: cdktf.stringToTerraform(struct!.keyToMask),
    mask_char: cdktf.stringToTerraform(struct!.maskChar),
    name: cdktf.stringToTerraform(struct!.name),
    percent: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercentToTerraform(struct!.percent),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key_to_mask: {
      value: cdktf.stringToHclTerraform(struct!.keyToMask),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mask_char: {
      value: cdktf.stringToHclTerraform(struct!.maskChar),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percent: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercentToHclTerraform(struct!.percent),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._keyToMask !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyToMask = this._keyToMask;
    }
    if (this._maskChar !== undefined) {
      hasAnyValues = true;
      internalValueResult.maskChar = this._maskChar;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._percent?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.percent = this._percent?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._keyToMask = undefined;
      this._maskChar = undefined;
      this._name = undefined;
      this._percent.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._keyToMask = value.keyToMask;
      this._maskChar = value.maskChar;
      this._name = value.name;
      this._percent.internalValue = value.percent;
    }
  }

  // key_to_mask - computed: false, optional: true, required: false
  private _keyToMask?: string; 
  public get keyToMask() {
    return this.getStringAttribute('key_to_mask');
  }
  public set keyToMask(value: string) {
    this._keyToMask = value;
  }
  public resetKeyToMask() {
    this._keyToMask = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyToMaskInput() {
    return this._keyToMask;
  }

  // mask_char - computed: false, optional: true, required: false
  private _maskChar?: string; 
  public get maskChar() {
    return this.getStringAttribute('mask_char');
  }
  public set maskChar(value: string) {
    this._maskChar = value;
  }
  public resetMaskChar() {
    this._maskChar = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maskCharInput() {
    return this._maskChar;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // percent - computed: false, optional: true, required: false
  private _percent = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercentOutputReference(this, "percent");
  public get percent() {
    return this._percent;
  }
  public putPercent(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionPercent) {
    this._percent.internalValue = value;
  }
  public resetPercent() {
    this._percent.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentInput() {
    return this._percent.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#action_type DataK8SGatewaySoloIoRouteTableV1Manifest#action_type}
  */
  readonly actionType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#custom_action DataK8SGatewaySoloIoRouteTableV1Manifest#custom_action}
  */
  readonly customAction?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key_value_action DataK8SGatewaySoloIoRouteTableV1Manifest#key_value_action}
  */
  readonly keyValueAction?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#shadow DataK8SGatewaySoloIoRouteTableV1Manifest#shadow}
  */
  readonly shadow?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    action_type: cdktf.stringToTerraform(struct!.actionType),
    custom_action: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionToTerraform(struct!.customAction),
    key_value_action: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionToTerraform(struct!.keyValueAction),
    shadow: cdktf.booleanToTerraform(struct!.shadow),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    action_type: {
      value: cdktf.stringToHclTerraform(struct!.actionType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_action: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionToHclTerraform(struct!.customAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction",
    },
    key_value_action: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionToHclTerraform(struct!.keyValueAction),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction",
    },
    shadow: {
      value: cdktf.booleanToHclTerraform(struct!.shadow),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actionType !== undefined) {
      hasAnyValues = true;
      internalValueResult.actionType = this._actionType;
    }
    if (this._customAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAction = this._customAction?.internalValue;
    }
    if (this._keyValueAction?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueAction = this._keyValueAction?.internalValue;
    }
    if (this._shadow !== undefined) {
      hasAnyValues = true;
      internalValueResult.shadow = this._shadow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actionType = undefined;
      this._customAction.internalValue = undefined;
      this._keyValueAction.internalValue = undefined;
      this._shadow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actionType = value.actionType;
      this._customAction.internalValue = value.customAction;
      this._keyValueAction.internalValue = value.keyValueAction;
      this._shadow = value.shadow;
    }
  }

  // action_type - computed: false, optional: true, required: false
  private _actionType?: string; 
  public get actionType() {
    return this.getStringAttribute('action_type');
  }
  public set actionType(value: string) {
    this._actionType = value;
  }
  public resetActionType() {
    this._actionType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionTypeInput() {
    return this._actionType;
  }

  // custom_action - computed: false, optional: true, required: false
  private _customAction = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomActionOutputReference(this, "custom_action");
  public get customAction() {
    return this._customAction;
  }
  public putCustomAction(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsCustomAction) {
    this._customAction.internalValue = value;
  }
  public resetCustomAction() {
    this._customAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customActionInput() {
    return this._customAction.internalValue;
  }

  // key_value_action - computed: false, optional: true, required: false
  private _keyValueAction = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueActionOutputReference(this, "key_value_action");
  public get keyValueAction() {
    return this._keyValueAction;
  }
  public putKeyValueAction(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsKeyValueAction) {
    this._keyValueAction.internalValue = value;
  }
  public resetKeyValueAction() {
    this._keyValueAction.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueActionInput() {
    return this._keyValueAction.internalValue;
  }

  // shadow - computed: false, optional: true, required: false
  private _shadow?: boolean | cdktf.IResolvable; 
  public get shadow() {
    return this.getBooleanAttribute('shadow');
  }
  public set shadow(value: boolean | cdktf.IResolvable) {
    this._shadow = value;
  }
  public resetShadow() {
    this._shadow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shadowInput() {
    return this._shadow;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#actions DataK8SGatewaySoloIoRouteTableV1Manifest#actions}
  */
  readonly actions?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#enabled_for DataK8SGatewaySoloIoRouteTableV1Manifest#enabled_for}
  */
  readonly enabledFor?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsToTerraform, false)(struct!.actions),
    enabled_for: cdktf.stringToTerraform(struct!.enabledFor),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsToHclTerraform, false)(struct!.actions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsList",
    },
    enabled_for: {
      value: cdktf.stringToHclTerraform(struct!.enabledFor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions?.internalValue;
    }
    if (this._enabledFor !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabledFor = this._enabledFor;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actions.internalValue = undefined;
      this._enabledFor = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actions.internalValue = value.actions;
      this._enabledFor = value.enabledFor;
    }
  }

  // actions - computed: false, optional: true, required: false
  private _actions = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsDlpActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // enabled_for - computed: false, optional: true, required: false
  private _enabledFor?: string; 
  public get enabledFor() {
    return this.getStringAttribute('enabled_for');
  }
  public set enabledFor(value: string) {
    this._enabledFor = value;
  }
  public resetEnabledFor() {
    this._enabledFor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledForInput() {
    return this._enabledFor;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#base_interval DataK8SGatewaySoloIoRouteTableV1Manifest#base_interval}
  */
  readonly baseInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_interval DataK8SGatewaySoloIoRouteTableV1Manifest#max_interval}
  */
  readonly maxInterval?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    base_interval: cdktf.stringToTerraform(struct!.baseInterval),
    max_interval: cdktf.stringToTerraform(struct!.maxInterval),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    base_interval: {
      value: cdktf.stringToHclTerraform(struct!.baseInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_interval: {
      value: cdktf.stringToHclTerraform(struct!.maxInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._baseInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseInterval = this._baseInterval;
    }
    if (this._maxInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInterval = this._maxInterval;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._baseInterval = undefined;
      this._maxInterval = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._baseInterval = value.baseInterval;
      this._maxInterval = value.maxInterval;
    }
  }

  // base_interval - computed: false, optional: true, required: false
  private _baseInterval?: string; 
  public get baseInterval() {
    return this.getStringAttribute('base_interval');
  }
  public set baseInterval(value: string) {
    this._baseInterval = value;
  }
  public resetBaseInterval() {
    this._baseInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseIntervalInput() {
    return this._baseInterval;
  }

  // max_interval - computed: false, optional: true, required: false
  private _maxInterval?: string; 
  public get maxInterval() {
    return this.getStringAttribute('max_interval');
  }
  public set maxInterval(value: string) {
    this._maxInterval = value;
  }
  public resetMaxInterval() {
    this._maxInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxIntervalInput() {
    return this._maxInterval;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#num_retries DataK8SGatewaySoloIoRouteTableV1Manifest#num_retries}
  */
  readonly numRetries?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#retry_back_off DataK8SGatewaySoloIoRouteTableV1Manifest#retry_back_off}
  */
  readonly retryBackOff?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    num_retries: cdktf.numberToTerraform(struct!.numRetries),
    retry_back_off: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToTerraform(struct!.retryBackOff),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    num_retries: {
      value: cdktf.numberToHclTerraform(struct!.numRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_back_off: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffToHclTerraform(struct!.retryBackOff),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._numRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.numRetries = this._numRetries;
    }
    if (this._retryBackOff?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryBackOff = this._retryBackOff?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._numRetries = undefined;
      this._retryBackOff.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._numRetries = value.numRetries;
      this._retryBackOff.internalValue = value.retryBackOff;
    }
  }

  // num_retries - computed: false, optional: true, required: false
  private _numRetries?: number; 
  public get numRetries() {
    return this.getNumberAttribute('num_retries');
  }
  public set numRetries(value: number) {
    this._numRetries = value;
  }
  public resetNumRetries() {
    this._numRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numRetriesInput() {
    return this._numRetries;
  }

  // retry_back_off - computed: false, optional: true, required: false
  private _retryBackOff = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOffOutputReference(this, "retry_back_off");
  public get retryBackOff() {
    return this._retryBackOff;
  }
  public putRetryBackOff(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyRetryBackOff) {
    this._retryBackOff.internalValue = value;
  }
  public resetRetryBackOff() {
    this._retryBackOff.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryBackOffInput() {
    return this._retryBackOff.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#authority DataK8SGatewaySoloIoRouteTableV1Manifest#authority}
  */
  readonly authority?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#ext_proc_server_ref DataK8SGatewaySoloIoRouteTableV1Manifest#ext_proc_server_ref}
  */
  readonly extProcServerRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#initial_metadata DataK8SGatewaySoloIoRouteTableV1Manifest#initial_metadata}
  */
  readonly initialMetadata?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#retry_policy DataK8SGatewaySoloIoRouteTableV1Manifest#retry_policy}
  */
  readonly retryPolicy?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#timeout DataK8SGatewaySoloIoRouteTableV1Manifest#timeout}
  */
  readonly timeout?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    authority: cdktf.stringToTerraform(struct!.authority),
    ext_proc_server_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRefToTerraform(struct!.extProcServerRef),
    initial_metadata: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataToTerraform, false)(struct!.initialMetadata),
    retry_policy: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyToTerraform(struct!.retryPolicy),
    timeout: cdktf.stringToTerraform(struct!.timeout),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    authority: {
      value: cdktf.stringToHclTerraform(struct!.authority),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ext_proc_server_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRefToHclTerraform(struct!.extProcServerRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef",
    },
    initial_metadata: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataToHclTerraform, false)(struct!.initialMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataList",
    },
    retry_policy: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyToHclTerraform(struct!.retryPolicy),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy",
    },
    timeout: {
      value: cdktf.stringToHclTerraform(struct!.timeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authority !== undefined) {
      hasAnyValues = true;
      internalValueResult.authority = this._authority;
    }
    if (this._extProcServerRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extProcServerRef = this._extProcServerRef?.internalValue;
    }
    if (this._initialMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialMetadata = this._initialMetadata?.internalValue;
    }
    if (this._retryPolicy?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryPolicy = this._retryPolicy?.internalValue;
    }
    if (this._timeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeout = this._timeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authority = undefined;
      this._extProcServerRef.internalValue = undefined;
      this._initialMetadata.internalValue = undefined;
      this._retryPolicy.internalValue = undefined;
      this._timeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authority = value.authority;
      this._extProcServerRef.internalValue = value.extProcServerRef;
      this._initialMetadata.internalValue = value.initialMetadata;
      this._retryPolicy.internalValue = value.retryPolicy;
      this._timeout = value.timeout;
    }
  }

  // authority - computed: false, optional: true, required: false
  private _authority?: string; 
  public get authority() {
    return this.getStringAttribute('authority');
  }
  public set authority(value: string) {
    this._authority = value;
  }
  public resetAuthority() {
    this._authority = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorityInput() {
    return this._authority;
  }

  // ext_proc_server_ref - computed: false, optional: true, required: false
  private _extProcServerRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRefOutputReference(this, "ext_proc_server_ref");
  public get extProcServerRef() {
    return this._extProcServerRef;
  }
  public putExtProcServerRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceExtProcServerRef) {
    this._extProcServerRef.internalValue = value;
  }
  public resetExtProcServerRef() {
    this._extProcServerRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extProcServerRefInput() {
    return this._extProcServerRef.internalValue;
  }

  // initial_metadata - computed: false, optional: true, required: false
  private _initialMetadata = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadataList(this, "initial_metadata", false);
  public get initialMetadata() {
    return this._initialMetadata;
  }
  public putInitialMetadata(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceInitialMetadata[] | cdktf.IResolvable) {
    this._initialMetadata.internalValue = value;
  }
  public resetInitialMetadata() {
    this._initialMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialMetadataInput() {
    return this._initialMetadata.internalValue;
  }

  // retry_policy - computed: false, optional: true, required: false
  private _retryPolicy = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicyOutputReference(this, "retry_policy");
  public get retryPolicy() {
    return this._retryPolicy;
  }
  public putRetryPolicy(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceRetryPolicy) {
    this._retryPolicy.internalValue = value;
  }
  public resetRetryPolicy() {
    this._retryPolicy.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryPolicyInput() {
    return this._retryPolicy.internalValue;
  }

  // timeout - computed: false, optional: true, required: false
  private _timeout?: string; 
  public get timeout() {
    return this.getStringAttribute('timeout');
  }
  public set timeout(value: string) {
    this._timeout = value;
  }
  public resetTimeout() {
    this._timeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutInput() {
    return this._timeout;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_body_mode DataK8SGatewaySoloIoRouteTableV1Manifest#request_body_mode}
  */
  readonly requestBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_header_mode DataK8SGatewaySoloIoRouteTableV1Manifest#request_header_mode}
  */
  readonly requestHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_trailer_mode DataK8SGatewaySoloIoRouteTableV1Manifest#request_trailer_mode}
  */
  readonly requestTrailerMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#response_body_mode DataK8SGatewaySoloIoRouteTableV1Manifest#response_body_mode}
  */
  readonly responseBodyMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#response_header_mode DataK8SGatewaySoloIoRouteTableV1Manifest#response_header_mode}
  */
  readonly responseHeaderMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#response_trailer_mode DataK8SGatewaySoloIoRouteTableV1Manifest#response_trailer_mode}
  */
  readonly responseTrailerMode?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingModeToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_body_mode: cdktf.stringToTerraform(struct!.requestBodyMode),
    request_header_mode: cdktf.stringToTerraform(struct!.requestHeaderMode),
    request_trailer_mode: cdktf.stringToTerraform(struct!.requestTrailerMode),
    response_body_mode: cdktf.stringToTerraform(struct!.responseBodyMode),
    response_header_mode: cdktf.stringToTerraform(struct!.responseHeaderMode),
    response_trailer_mode: cdktf.stringToTerraform(struct!.responseTrailerMode),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingModeToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.requestTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_body_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseBodyMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_header_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseHeaderMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_trailer_mode: {
      value: cdktf.stringToHclTerraform(struct!.responseTrailerMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingModeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestBodyMode = this._requestBodyMode;
    }
    if (this._requestHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaderMode = this._requestHeaderMode;
    }
    if (this._requestTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTrailerMode = this._requestTrailerMode;
    }
    if (this._responseBodyMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseBodyMode = this._responseBodyMode;
    }
    if (this._responseHeaderMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeaderMode = this._responseHeaderMode;
    }
    if (this._responseTrailerMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseTrailerMode = this._responseTrailerMode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestBodyMode = undefined;
      this._requestHeaderMode = undefined;
      this._requestTrailerMode = undefined;
      this._responseBodyMode = undefined;
      this._responseHeaderMode = undefined;
      this._responseTrailerMode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestBodyMode = value.requestBodyMode;
      this._requestHeaderMode = value.requestHeaderMode;
      this._requestTrailerMode = value.requestTrailerMode;
      this._responseBodyMode = value.responseBodyMode;
      this._responseHeaderMode = value.responseHeaderMode;
      this._responseTrailerMode = value.responseTrailerMode;
    }
  }

  // request_body_mode - computed: false, optional: true, required: false
  private _requestBodyMode?: string; 
  public get requestBodyMode() {
    return this.getStringAttribute('request_body_mode');
  }
  public set requestBodyMode(value: string) {
    this._requestBodyMode = value;
  }
  public resetRequestBodyMode() {
    this._requestBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestBodyModeInput() {
    return this._requestBodyMode;
  }

  // request_header_mode - computed: false, optional: true, required: false
  private _requestHeaderMode?: string; 
  public get requestHeaderMode() {
    return this.getStringAttribute('request_header_mode');
  }
  public set requestHeaderMode(value: string) {
    this._requestHeaderMode = value;
  }
  public resetRequestHeaderMode() {
    this._requestHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeaderModeInput() {
    return this._requestHeaderMode;
  }

  // request_trailer_mode - computed: false, optional: true, required: false
  private _requestTrailerMode?: string; 
  public get requestTrailerMode() {
    return this.getStringAttribute('request_trailer_mode');
  }
  public set requestTrailerMode(value: string) {
    this._requestTrailerMode = value;
  }
  public resetRequestTrailerMode() {
    this._requestTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTrailerModeInput() {
    return this._requestTrailerMode;
  }

  // response_body_mode - computed: false, optional: true, required: false
  private _responseBodyMode?: string; 
  public get responseBodyMode() {
    return this.getStringAttribute('response_body_mode');
  }
  public set responseBodyMode(value: string) {
    this._responseBodyMode = value;
  }
  public resetResponseBodyMode() {
    this._responseBodyMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseBodyModeInput() {
    return this._responseBodyMode;
  }

  // response_header_mode - computed: false, optional: true, required: false
  private _responseHeaderMode?: string; 
  public get responseHeaderMode() {
    return this.getStringAttribute('response_header_mode');
  }
  public set responseHeaderMode(value: string) {
    this._responseHeaderMode = value;
  }
  public resetResponseHeaderMode() {
    this._responseHeaderMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeaderModeInput() {
    return this._responseHeaderMode;
  }

  // response_trailer_mode - computed: false, optional: true, required: false
  private _responseTrailerMode?: string; 
  public get responseTrailerMode() {
    return this.getStringAttribute('response_trailer_mode');
  }
  public set responseTrailerMode(value: string) {
    this._responseTrailerMode = value;
  }
  public resetResponseTrailerMode() {
    this._responseTrailerMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseTrailerModeInput() {
    return this._responseTrailerMode;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#async_mode DataK8SGatewaySoloIoRouteTableV1Manifest#async_mode}
  */
  readonly asyncMode?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#grpc_service DataK8SGatewaySoloIoRouteTableV1Manifest#grpc_service}
  */
  readonly grpcService?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata_context_namespaces DataK8SGatewaySoloIoRouteTableV1Manifest#metadata_context_namespaces}
  */
  readonly metadataContextNamespaces?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#processing_mode DataK8SGatewaySoloIoRouteTableV1Manifest#processing_mode}
  */
  readonly processingMode?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_attributes DataK8SGatewaySoloIoRouteTableV1Manifest#request_attributes}
  */
  readonly requestAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#response_attributes DataK8SGatewaySoloIoRouteTableV1Manifest#response_attributes}
  */
  readonly responseAttributes?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#typed_metadata_context_namespaces DataK8SGatewaySoloIoRouteTableV1Manifest#typed_metadata_context_namespaces}
  */
  readonly typedMetadataContextNamespaces?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_mode: cdktf.booleanToTerraform(struct!.asyncMode),
    grpc_service: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceToTerraform(struct!.grpcService),
    metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.metadataContextNamespaces),
    processing_mode: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingModeToTerraform(struct!.processingMode),
    request_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestAttributes),
    response_attributes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.responseAttributes),
    typed_metadata_context_namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.typedMetadataContextNamespaces),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_mode: {
      value: cdktf.booleanToHclTerraform(struct!.asyncMode),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    grpc_service: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceToHclTerraform(struct!.grpcService),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService",
    },
    metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.metadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    processing_mode: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingModeToHclTerraform(struct!.processingMode),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode",
    },
    request_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_attributes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.responseAttributes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    typed_metadata_context_namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.typedMetadataContextNamespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncMode = this._asyncMode;
    }
    if (this._grpcService?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcService = this._grpcService?.internalValue;
    }
    if (this._metadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataContextNamespaces = this._metadataContextNamespaces;
    }
    if (this._processingMode?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.processingMode = this._processingMode?.internalValue;
    }
    if (this._requestAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestAttributes = this._requestAttributes;
    }
    if (this._responseAttributes !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseAttributes = this._responseAttributes;
    }
    if (this._typedMetadataContextNamespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.typedMetadataContextNamespaces = this._typedMetadataContextNamespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncMode = undefined;
      this._grpcService.internalValue = undefined;
      this._metadataContextNamespaces = undefined;
      this._processingMode.internalValue = undefined;
      this._requestAttributes = undefined;
      this._responseAttributes = undefined;
      this._typedMetadataContextNamespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncMode = value.asyncMode;
      this._grpcService.internalValue = value.grpcService;
      this._metadataContextNamespaces = value.metadataContextNamespaces;
      this._processingMode.internalValue = value.processingMode;
      this._requestAttributes = value.requestAttributes;
      this._responseAttributes = value.responseAttributes;
      this._typedMetadataContextNamespaces = value.typedMetadataContextNamespaces;
    }
  }

  // async_mode - computed: false, optional: true, required: false
  private _asyncMode?: boolean | cdktf.IResolvable; 
  public get asyncMode() {
    return this.getBooleanAttribute('async_mode');
  }
  public set asyncMode(value: boolean | cdktf.IResolvable) {
    this._asyncMode = value;
  }
  public resetAsyncMode() {
    this._asyncMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncModeInput() {
    return this._asyncMode;
  }

  // grpc_service - computed: false, optional: true, required: false
  private _grpcService = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcServiceOutputReference(this, "grpc_service");
  public get grpcService() {
    return this._grpcService;
  }
  public putGrpcService(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesGrpcService) {
    this._grpcService.internalValue = value;
  }
  public resetGrpcService() {
    this._grpcService.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcServiceInput() {
    return this._grpcService.internalValue;
  }

  // metadata_context_namespaces - computed: false, optional: true, required: false
  private _metadataContextNamespaces?: string[]; 
  public get metadataContextNamespaces() {
    return this.getListAttribute('metadata_context_namespaces');
  }
  public set metadataContextNamespaces(value: string[]) {
    this._metadataContextNamespaces = value;
  }
  public resetMetadataContextNamespaces() {
    this._metadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataContextNamespacesInput() {
    return this._metadataContextNamespaces;
  }

  // processing_mode - computed: false, optional: true, required: false
  private _processingMode = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingModeOutputReference(this, "processing_mode");
  public get processingMode() {
    return this._processingMode;
  }
  public putProcessingMode(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesProcessingMode) {
    this._processingMode.internalValue = value;
  }
  public resetProcessingMode() {
    this._processingMode.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processingModeInput() {
    return this._processingMode.internalValue;
  }

  // request_attributes - computed: false, optional: true, required: false
  private _requestAttributes?: string[]; 
  public get requestAttributes() {
    return this.getListAttribute('request_attributes');
  }
  public set requestAttributes(value: string[]) {
    this._requestAttributes = value;
  }
  public resetRequestAttributes() {
    this._requestAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestAttributesInput() {
    return this._requestAttributes;
  }

  // response_attributes - computed: false, optional: true, required: false
  private _responseAttributes?: string[]; 
  public get responseAttributes() {
    return this.getListAttribute('response_attributes');
  }
  public set responseAttributes(value: string[]) {
    this._responseAttributes = value;
  }
  public resetResponseAttributes() {
    this._responseAttributes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseAttributesInput() {
    return this._responseAttributes;
  }

  // typed_metadata_context_namespaces - computed: false, optional: true, required: false
  private _typedMetadataContextNamespaces?: string[]; 
  public get typedMetadataContextNamespaces() {
    return this.getListAttribute('typed_metadata_context_namespaces');
  }
  public set typedMetadataContextNamespaces(value: string[]) {
    this._typedMetadataContextNamespaces = value;
  }
  public resetTypedMetadataContextNamespaces() {
    this._typedMetadataContextNamespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typedMetadataContextNamespacesInput() {
    return this._typedMetadataContextNamespaces;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProc {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#disabled DataK8SGatewaySoloIoRouteTableV1Manifest#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#overrides DataK8SGatewaySoloIoRouteTableV1Manifest#overrides}
  */
  readonly overrides?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    overrides: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesToTerraform(struct!.overrides),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProc | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    overrides: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesToHclTerraform(struct!.overrides),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProc | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._overrides?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.overrides = this._overrides?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProc | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._overrides.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._overrides.internalValue = value.overrides;
    }
  }

  // disabled - computed: false, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // overrides - computed: false, optional: true, required: false
  private _overrides = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverridesOutputReference(this, "overrides");
  public get overrides() {
    return this._overrides;
  }
  public putOverrides(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtProcOverrides) {
    this._overrides.internalValue = value;
  }
  public resetOverrides() {
    this._overrides.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get overridesInput() {
    return this._overrides.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#context_extensions DataK8SGatewaySoloIoRouteTableV1Manifest#context_extensions}
  */
  readonly contextExtensions?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    context_extensions: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.contextExtensions),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    context_extensions: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.contextExtensions),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contextExtensions !== undefined) {
      hasAnyValues = true;
      internalValueResult.contextExtensions = this._contextExtensions;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contextExtensions = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contextExtensions = value.contextExtensions;
      this._name = value.name;
    }
  }

  // context_extensions - computed: false, optional: true, required: false
  private _contextExtensions?: { [key: string]: string }; 
  public get contextExtensions() {
    return this.getStringMapAttribute('context_extensions');
  }
  public set contextExtensions(value: { [key: string]: string }) {
    this._contextExtensions = value;
  }
  public resetContextExtensions() {
    this._contextExtensions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contextExtensionsInput() {
    return this._contextExtensions;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#config_ref DataK8SGatewaySoloIoRouteTableV1Manifest#config_ref}
  */
  readonly configRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#custom_auth DataK8SGatewaySoloIoRouteTableV1Manifest#custom_auth}
  */
  readonly customAuth?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#disable DataK8SGatewaySoloIoRouteTableV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRefToTerraform(struct!.configRef),
    custom_auth: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuthToTerraform(struct!.customAuth),
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRefToHclTerraform(struct!.configRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef",
    },
    custom_auth: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuthToHclTerraform(struct!.customAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth",
    },
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configRef = this._configRef?.internalValue;
    }
    if (this._customAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customAuth = this._customAuth?.internalValue;
    }
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configRef.internalValue = undefined;
      this._customAuth.internalValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configRef.internalValue = value.configRef;
      this._customAuth.internalValue = value.customAuth;
      this._disable = value.disable;
    }
  }

  // config_ref - computed: false, optional: true, required: false
  private _configRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRefOutputReference(this, "config_ref");
  public get configRef() {
    return this._configRef;
  }
  public putConfigRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthConfigRef) {
    this._configRef.internalValue = value;
  }
  public resetConfigRef() {
    this._configRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configRefInput() {
    return this._configRef.internalValue;
  }

  // custom_auth - computed: false, optional: true, required: false
  private _customAuth = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuthOutputReference(this, "custom_auth");
  public get customAuth() {
    return this._customAuth;
  }
  public putCustomAuth(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtauthCustomAuth) {
    this._customAuth.internalValue = value;
  }
  public resetCustomAuth() {
    this._customAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customAuthInput() {
    return this._customAuth.internalValue;
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#configs DataK8SGatewaySoloIoRouteTableV1Manifest#configs}
  */
  readonly configs?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensionsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    configs: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.configs),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    configs: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.configs),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configs !== undefined) {
      hasAnyValues = true;
      internalValueResult.configs = this._configs;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsExtensions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configs = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configs = value.configs;
    }
  }

  // configs - computed: false, optional: true, required: false
  private _configs?: { [key: string]: string }; 
  public get configs() {
    return this.getStringMapAttribute('configs');
  }
  public set configs(value: { [key: string]: string }) {
    this._configs = value;
  }
  public resetConfigs() {
    this._configs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configsInput() {
    return this._configs;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#http_status DataK8SGatewaySoloIoRouteTableV1Manifest#http_status}
  */
  readonly httpStatus?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#percentage DataK8SGatewaySoloIoRouteTableV1Manifest#percentage}
  */
  readonly percentage?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbortToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    percentage: cdktf.numberToTerraform(struct!.percentage),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbortToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    percentage: {
      value: cdktf.numberToHclTerraform(struct!.percentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbortOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._percentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.percentage = this._percentage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._httpStatus = undefined;
      this._percentage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._httpStatus = value.httpStatus;
      this._percentage = value.percentage;
    }
  }

  // http_status - computed: false, optional: true, required: false
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  public resetHttpStatus() {
    this._httpStatus = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // percentage - computed: false, optional: true, required: false
  private _percentage?: number; 
  public get percentage() {
    return this.getNumberAttribute('percentage');
  }
  public set percentage(value: number) {
    this._percentage = value;
  }
  public resetPercentage() {
    this._percentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentageInput() {
    return this._percentage;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#fixed_delay DataK8SGatewaySoloIoRouteTableV1Manifest#fixed_delay}
  */
  readonly fixedDelay?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#percentage DataK8SGatewaySoloIoRouteTableV1Manifest#percentage}
  */
  readonly percentage?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelayToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fixed_delay: cdktf.stringToTerraform(struct!.fixedDelay),
    percentage: cdktf.numberToTerraform(struct!.percentage),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelayToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fixed_delay: {
      value: cdktf.stringToHclTerraform(struct!.fixedDelay),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    percentage: {
      value: cdktf.numberToHclTerraform(struct!.percentage),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelayOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fixedDelay !== undefined) {
      hasAnyValues = true;
      internalValueResult.fixedDelay = this._fixedDelay;
    }
    if (this._percentage !== undefined) {
      hasAnyValues = true;
      internalValueResult.percentage = this._percentage;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fixedDelay = undefined;
      this._percentage = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fixedDelay = value.fixedDelay;
      this._percentage = value.percentage;
    }
  }

  // fixed_delay - computed: false, optional: true, required: false
  private _fixedDelay?: string; 
  public get fixedDelay() {
    return this.getStringAttribute('fixed_delay');
  }
  public set fixedDelay(value: string) {
    this._fixedDelay = value;
  }
  public resetFixedDelay() {
    this._fixedDelay = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fixedDelayInput() {
    return this._fixedDelay;
  }

  // percentage - computed: false, optional: true, required: false
  private _percentage?: number; 
  public get percentage() {
    return this.getNumberAttribute('percentage');
  }
  public set percentage(value: number) {
    this._percentage = value;
  }
  public resetPercentage() {
    this._percentage = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get percentageInput() {
    return this._percentage;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaults {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#abort DataK8SGatewaySoloIoRouteTableV1Manifest#abort}
  */
  readonly abort?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#delay DataK8SGatewaySoloIoRouteTableV1Manifest#delay}
  */
  readonly delay?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    abort: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbortToTerraform(struct!.abort),
    delay: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelayToTerraform(struct!.delay),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaults | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    abort: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbortToHclTerraform(struct!.abort),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort",
    },
    delay: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelayToHclTerraform(struct!.delay),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaults | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._abort?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.abort = this._abort?.internalValue;
    }
    if (this._delay?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.delay = this._delay?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaults | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._abort.internalValue = undefined;
      this._delay.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._abort.internalValue = value.abort;
      this._delay.internalValue = value.delay;
    }
  }

  // abort - computed: false, optional: true, required: false
  private _abort = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbortOutputReference(this, "abort");
  public get abort() {
    return this._abort;
  }
  public putAbort(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsAbort) {
    this._abort.internalValue = value;
  }
  public resetAbort() {
    this._abort.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get abortInput() {
    return this._abort.internalValue;
  }

  // delay - computed: false, optional: true, required: false
  private _delay = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelayOutputReference(this, "delay");
  public get delay() {
    return this._delay;
  }
  public putDelay(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsFaultsDelay) {
    this._delay.internalValue = value;
  }
  public resetDelay() {
    this._delay.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get delayInput() {
    return this._delay.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#append DataK8SGatewaySoloIoRouteTableV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header DataK8SGatewaySoloIoRouteTableV1Manifest#header}
  */
  readonly header?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header_secret_ref DataK8SGatewaySoloIoRouteTableV1Manifest#header_secret_ref}
  */
  readonly headerSecretRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderToTerraform(struct!.header),
    header_secret_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToTerraform(struct!.headerSecretRef),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader",
    },
    header_secret_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefToHclTerraform(struct!.headerSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    if (this._headerSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerSecretRef = this._headerSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
      this._headerSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
      this._headerSecretRef.internalValue = value.headerSecretRef;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }

  // header_secret_ref - computed: false, optional: true, required: false
  private _headerSecretRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRefOutputReference(this, "header_secret_ref");
  public get headerSecretRef() {
    return this._headerSecretRef;
  }
  public putHeaderSecretRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddHeaderSecretRef) {
    this._headerSecretRef.internalValue = value;
  }
  public resetHeaderSecretRef() {
    this._headerSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerSecretRefInput() {
    return this._headerSecretRef.internalValue;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#value DataK8SGatewaySoloIoRouteTableV1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeaderToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeaderToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeaderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#append DataK8SGatewaySoloIoRouteTableV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header DataK8SGatewaySoloIoRouteTableV1Manifest#header}
  */
  readonly header?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    header: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeaderToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    header: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeaderToHclTerraform(struct!.header),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._header?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._header.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._header.internalValue = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // header - computed: false, optional: true, required: false
  private _header = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeaderOutputReference(this, "header");
  public get header() {
    return this._header;
  }
  public putHeader(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddHeader) {
    this._header.internalValue = value;
  }
  public resetHeader() {
    this._header.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header.internalValue;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulation {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_headers_to_add DataK8SGatewaySoloIoRouteTableV1Manifest#request_headers_to_add}
  */
  readonly requestHeadersToAdd?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_headers_to_remove DataK8SGatewaySoloIoRouteTableV1Manifest#request_headers_to_remove}
  */
  readonly requestHeadersToRemove?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#response_headers_to_add DataK8SGatewaySoloIoRouteTableV1Manifest#response_headers_to_add}
  */
  readonly responseHeadersToAdd?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#response_headers_to_remove DataK8SGatewaySoloIoRouteTableV1Manifest#response_headers_to_remove}
  */
  readonly responseHeadersToRemove?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    request_headers_to_add: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddToTerraform, false)(struct!.requestHeadersToAdd),
    request_headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.requestHeadersToRemove),
    response_headers_to_add: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddToTerraform, false)(struct!.responseHeadersToAdd),
    response_headers_to_remove: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.responseHeadersToRemove),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulation | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    request_headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddToHclTerraform, false)(struct!.requestHeadersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddList",
    },
    request_headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.requestHeadersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    response_headers_to_add: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddToHclTerraform, false)(struct!.responseHeadersToAdd),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddList",
    },
    response_headers_to_remove: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.responseHeadersToRemove),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulation | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestHeadersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToAdd = this._requestHeadersToAdd?.internalValue;
    }
    if (this._requestHeadersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeadersToRemove = this._requestHeadersToRemove;
    }
    if (this._responseHeadersToAdd?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersToAdd = this._responseHeadersToAdd?.internalValue;
    }
    if (this._responseHeadersToRemove !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHeadersToRemove = this._responseHeadersToRemove;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulation | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestHeadersToAdd.internalValue = undefined;
      this._requestHeadersToRemove = undefined;
      this._responseHeadersToAdd.internalValue = undefined;
      this._responseHeadersToRemove = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestHeadersToAdd.internalValue = value.requestHeadersToAdd;
      this._requestHeadersToRemove = value.requestHeadersToRemove;
      this._responseHeadersToAdd.internalValue = value.responseHeadersToAdd;
      this._responseHeadersToRemove = value.responseHeadersToRemove;
    }
  }

  // request_headers_to_add - computed: false, optional: true, required: false
  private _requestHeadersToAdd = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAddList(this, "request_headers_to_add", false);
  public get requestHeadersToAdd() {
    return this._requestHeadersToAdd;
  }
  public putRequestHeadersToAdd(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationRequestHeadersToAdd[] | cdktf.IResolvable) {
    this._requestHeadersToAdd.internalValue = value;
  }
  public resetRequestHeadersToAdd() {
    this._requestHeadersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToAddInput() {
    return this._requestHeadersToAdd.internalValue;
  }

  // request_headers_to_remove - computed: false, optional: true, required: false
  private _requestHeadersToRemove?: string[]; 
  public get requestHeadersToRemove() {
    return this.getListAttribute('request_headers_to_remove');
  }
  public set requestHeadersToRemove(value: string[]) {
    this._requestHeadersToRemove = value;
  }
  public resetRequestHeadersToRemove() {
    this._requestHeadersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersToRemoveInput() {
    return this._requestHeadersToRemove;
  }

  // response_headers_to_add - computed: false, optional: true, required: false
  private _responseHeadersToAdd = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAddList(this, "response_headers_to_add", false);
  public get responseHeadersToAdd() {
    return this._responseHeadersToAdd;
  }
  public putResponseHeadersToAdd(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHeaderManipulationResponseHeadersToAdd[] | cdktf.IResolvable) {
    this._responseHeadersToAdd.internalValue = value;
  }
  public resetResponseHeadersToAdd() {
    this._responseHeadersToAdd.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersToAddInput() {
    return this._responseHeadersToAdd.internalValue;
  }

  // response_headers_to_remove - computed: false, optional: true, required: false
  private _responseHeadersToRemove?: string[]; 
  public get responseHeadersToRemove() {
    return this.getListAttribute('response_headers_to_remove');
  }
  public set responseHeadersToRemove(value: string[]) {
    this._responseHeadersToRemove = value;
  }
  public resetResponseHeadersToRemove() {
    this._responseHeadersToRemove = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHeadersToRemoveInput() {
    return this._responseHeadersToRemove;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2 {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_program_size DataK8SGatewaySoloIoRouteTableV1Manifest#max_program_size}
  */
  readonly maxProgramSize?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2ToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    max_program_size: cdktf.numberToTerraform(struct!.maxProgramSize),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2ToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    max_program_size: {
      value: cdktf.numberToHclTerraform(struct!.maxProgramSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._maxProgramSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxProgramSize = this._maxProgramSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._maxProgramSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._maxProgramSize = value.maxProgramSize;
    }
  }

  // max_program_size - computed: false, optional: true, required: false
  private _maxProgramSize?: number; 
  public get maxProgramSize() {
    return this.getNumberAttribute('max_program_size');
  }
  public set maxProgramSize(value: number) {
    this._maxProgramSize = value;
  }
  public resetMaxProgramSize() {
    this._maxProgramSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxProgramSizeInput() {
    return this._maxProgramSize;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#google_re2 DataK8SGatewaySoloIoRouteTableV1Manifest#google_re2}
  */
  readonly googleRe2?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex DataK8SGatewaySoloIoRouteTableV1Manifest#regex}
  */
  readonly regex?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    google_re2: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2ToTerraform(struct!.googleRe2),
    regex: cdktf.stringToTerraform(struct!.regex),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    google_re2: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2ToHclTerraform(struct!.googleRe2),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2",
    },
    regex: {
      value: cdktf.stringToHclTerraform(struct!.regex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._googleRe2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleRe2 = this._googleRe2?.internalValue;
    }
    if (this._regex !== undefined) {
      hasAnyValues = true;
      internalValueResult.regex = this._regex;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = undefined;
      this._regex = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._googleRe2.internalValue = value.googleRe2;
      this._regex = value.regex;
    }
  }

  // google_re2 - computed: false, optional: true, required: false
  private _googleRe2 = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2OutputReference(this, "google_re2");
  public get googleRe2() {
    return this._googleRe2;
  }
  public putGoogleRe2(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternGoogleRe2) {
    this._googleRe2.internalValue = value;
  }
  public resetGoogleRe2() {
    this._googleRe2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleRe2Input() {
    return this._googleRe2.internalValue;
  }

  // regex - computed: false, optional: true, required: false
  private _regex?: string; 
  public get regex() {
    return this.getStringAttribute('regex');
  }
  public set regex(value: string) {
    this._regex = value;
  }
  public resetRegex() {
    this._regex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexInput() {
    return this._regex;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegex {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#pattern DataK8SGatewaySoloIoRouteTableV1Manifest#pattern}
  */
  readonly pattern?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#substitution DataK8SGatewaySoloIoRouteTableV1Manifest#substitution}
  */
  readonly substitution?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    pattern: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternToTerraform(struct!.pattern),
    substitution: cdktf.stringToTerraform(struct!.substitution),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegex | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    pattern: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternToHclTerraform(struct!.pattern),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern",
    },
    substitution: {
      value: cdktf.stringToHclTerraform(struct!.substitution),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegex | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._pattern?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pattern = this._pattern?.internalValue;
    }
    if (this._substitution !== undefined) {
      hasAnyValues = true;
      internalValueResult.substitution = this._substitution;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegex | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._pattern.internalValue = undefined;
      this._substitution = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._pattern.internalValue = value.pattern;
      this._substitution = value.substitution;
    }
  }

  // pattern - computed: false, optional: true, required: false
  private _pattern = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPatternOutputReference(this, "pattern");
  public get pattern() {
    return this._pattern;
  }
  public putPattern(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsHostRewritePathRegexPattern) {
    this._pattern.internalValue = value;
  }
  public resetPattern() {
    this._pattern.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get patternInput() {
    return this._pattern.internalValue;
  }

  // substitution - computed: false, optional: true, required: false
  private _substitution?: string; 
  public get substitution() {
    return this.getStringAttribute('substitution');
  }
  public set substitution(value: string) {
    this._substitution = value;
  }
  public resetSubstitution() {
    this._substitution = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get substitutionInput() {
    return this._substitution;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwt {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#disable DataK8SGatewaySoloIoRouteTableV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#append DataK8SGatewaySoloIoRouteTableV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#claim DataK8SGatewaySoloIoRouteTableV1Manifest#claim}
  */
  readonly claim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header DataK8SGatewaySoloIoRouteTableV1Manifest#header}
  */
  readonly header?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    claim: cdktf.stringToTerraform(struct!.claim),
    header: cdktf.stringToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    claim: {
      value: cdktf.stringToHclTerraform(struct!.claim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._claim !== undefined) {
      hasAnyValues = true;
      internalValueResult.claim = this._claim;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._claim = undefined;
      this._header = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._claim = value.claim;
      this._header = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // claim - computed: false, optional: true, required: false
  private _claim?: string; 
  public get claim() {
    return this.getStringAttribute('claim');
  }
  public set claim(value: string) {
    this._claim = value;
  }
  public resetClaim() {
    this._claim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimInput() {
    return this._claim;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#fast_listener DataK8SGatewaySoloIoRouteTableV1Manifest#fast_listener}
  */
  readonly fastListener?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fast_listener: cdktf.booleanToTerraform(struct!.fastListener),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fast_listener: {
      value: cdktf.booleanToHclTerraform(struct!.fastListener),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fastListener !== undefined) {
      hasAnyValues = true;
      internalValueResult.fastListener = this._fastListener;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fastListener = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fastListener = value.fastListener;
    }
  }

  // fast_listener - computed: false, optional: true, required: false
  private _fastListener?: boolean | cdktf.IResolvable; 
  public get fastListener() {
    return this.getBooleanAttribute('fast_listener');
  }
  public set fastListener(value: boolean | cdktf.IResolvable) {
    this._fastListener = value;
  }
  public resetFastListener() {
    this._fastListener = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fastListenerInput() {
    return this._fastListener;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#async_fetch DataK8SGatewaySoloIoRouteTableV1Manifest#async_fetch}
  */
  readonly asyncFetch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#cache_duration DataK8SGatewaySoloIoRouteTableV1Manifest#cache_duration}
  */
  readonly cacheDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#upstream_ref DataK8SGatewaySoloIoRouteTableV1Manifest#upstream_ref}
  */
  readonly upstreamRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#url DataK8SGatewaySoloIoRouteTableV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_fetch: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct!.asyncFetch),
    cache_duration: cdktf.stringToTerraform(struct!.cacheDuration),
    upstream_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct!.upstreamRef),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_fetch: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct!.asyncFetch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch",
    },
    cache_duration: {
      value: cdktf.stringToHclTerraform(struct!.cacheDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upstream_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct!.upstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncFetch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncFetch = this._asyncFetch?.internalValue;
    }
    if (this._cacheDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheDuration = this._cacheDuration;
    }
    if (this._upstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstreamRef = this._upstreamRef?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = undefined;
      this._cacheDuration = undefined;
      this._upstreamRef.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = value.asyncFetch;
      this._cacheDuration = value.cacheDuration;
      this._upstreamRef.internalValue = value.upstreamRef;
      this._url = value.url;
    }
  }

  // async_fetch - computed: false, optional: true, required: false
  private _asyncFetch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetchOutputReference(this, "async_fetch");
  public get asyncFetch() {
    return this._asyncFetch;
  }
  public putAsyncFetch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteAsyncFetch) {
    this._asyncFetch.internalValue = value;
  }
  public resetAsyncFetch() {
    this._asyncFetch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncFetchInput() {
    return this._asyncFetch.internalValue;
  }

  // cache_duration - computed: false, optional: true, required: false
  private _cacheDuration?: string; 
  public get cacheDuration() {
    return this.getStringAttribute('cache_duration');
  }
  public set cacheDuration(value: string) {
    this._cacheDuration = value;
  }
  public resetCacheDuration() {
    this._cacheDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheDurationInput() {
    return this._cacheDuration;
  }

  // upstream_ref - computed: false, optional: true, required: false
  private _upstreamRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRefOutputReference(this, "upstream_ref");
  public get upstreamRef() {
    return this._upstreamRef;
  }
  public putUpstreamRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteUpstreamRef) {
    this._upstreamRef.internalValue = value;
  }
  public resetUpstreamRef() {
    this._upstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamRefInput() {
    return this._upstreamRef.internalValue;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#local DataK8SGatewaySoloIoRouteTableV1Manifest#local}
  */
  readonly local?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#remote DataK8SGatewaySoloIoRouteTableV1Manifest#remote}
  */
  readonly remote?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    local: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToTerraform(struct!.local),
    remote: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToTerraform(struct!.remote),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    local: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal",
    },
    remote: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteToHclTerraform(struct!.remote),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._remote?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._local.internalValue = undefined;
      this._remote.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._local.internalValue = value.local;
      this._remote.internalValue = value.remote;
    }
  }

  // local - computed: false, optional: true, required: false
  private _local = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // remote - computed: false, optional: true, required: false
  private _remote = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemoteOutputReference(this, "remote");
  public get remote() {
    return this._remote;
  }
  public putRemote(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksRemote) {
    this._remote.internalValue = value;
  }
  public resetRemote() {
    this._remote.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header DataK8SGatewaySoloIoRouteTableV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prefix DataK8SGatewaySoloIoRouteTableV1Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._prefix = value.prefix;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#query_params DataK8SGatewaySoloIoRouteTableV1Manifest#query_params}
  */
  readonly queryParams?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToTerraform, false)(struct!.headers),
    query_params: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersList",
    },
    query_params: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.queryParams),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._queryParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._queryParams = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._queryParams = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams?: string[]; 
  public get queryParams() {
    return this.getListAttribute('query_params');
  }
  public set queryParams(value: string[]) {
    this._queryParams = value;
  }
  public resetQueryParams() {
    this._queryParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#audiences DataK8SGatewaySoloIoRouteTableV1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#claims_to_headers DataK8SGatewaySoloIoRouteTableV1Manifest#claims_to_headers}
  */
  readonly claimsToHeaders?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#clock_skew_seconds DataK8SGatewaySoloIoRouteTableV1Manifest#clock_skew_seconds}
  */
  readonly clockSkewSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#issuer DataK8SGatewaySoloIoRouteTableV1Manifest#issuer}
  */
  readonly issuer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#jwks DataK8SGatewaySoloIoRouteTableV1Manifest#jwks}
  */
  readonly jwks?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#keep_token DataK8SGatewaySoloIoRouteTableV1Manifest#keep_token}
  */
  readonly keepToken?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#token_source DataK8SGatewaySoloIoRouteTableV1Manifest#token_source}
  */
  readonly tokenSource?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    claims_to_headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToTerraform, false)(struct!.claimsToHeaders),
    clock_skew_seconds: cdktf.numberToTerraform(struct!.clockSkewSeconds),
    issuer: cdktf.stringToTerraform(struct!.issuer),
    jwks: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToTerraform(struct!.jwks),
    keep_token: cdktf.booleanToTerraform(struct!.keepToken),
    token_source: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToTerraform(struct!.tokenSource),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    claims_to_headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersToHclTerraform, false)(struct!.claimsToHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersList",
    },
    clock_skew_seconds: {
      value: cdktf.numberToHclTerraform(struct!.clockSkewSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    issuer: {
      value: cdktf.stringToHclTerraform(struct!.issuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwks: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksToHclTerraform(struct!.jwks),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks",
    },
    keep_token: {
      value: cdktf.booleanToHclTerraform(struct!.keepToken),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    token_source: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceToHclTerraform(struct!.tokenSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._claimsToHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimsToHeaders = this._claimsToHeaders?.internalValue;
    }
    if (this._clockSkewSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.clockSkewSeconds = this._clockSkewSeconds;
    }
    if (this._issuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuer = this._issuer;
    }
    if (this._jwks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwks = this._jwks?.internalValue;
    }
    if (this._keepToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepToken = this._keepToken;
    }
    if (this._tokenSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSource = this._tokenSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._claimsToHeaders.internalValue = undefined;
      this._clockSkewSeconds = undefined;
      this._issuer = undefined;
      this._jwks.internalValue = undefined;
      this._keepToken = undefined;
      this._tokenSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._claimsToHeaders.internalValue = value.claimsToHeaders;
      this._clockSkewSeconds = value.clockSkewSeconds;
      this._issuer = value.issuer;
      this._jwks.internalValue = value.jwks;
      this._keepToken = value.keepToken;
      this._tokenSource.internalValue = value.tokenSource;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // claims_to_headers - computed: false, optional: true, required: false
  private _claimsToHeaders = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeadersList(this, "claims_to_headers", false);
  public get claimsToHeaders() {
    return this._claimsToHeaders;
  }
  public putClaimsToHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable) {
    this._claimsToHeaders.internalValue = value;
  }
  public resetClaimsToHeaders() {
    this._claimsToHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsToHeadersInput() {
    return this._claimsToHeaders.internalValue;
  }

  // clock_skew_seconds - computed: false, optional: true, required: false
  private _clockSkewSeconds?: number; 
  public get clockSkewSeconds() {
    return this.getNumberAttribute('clock_skew_seconds');
  }
  public set clockSkewSeconds(value: number) {
    this._clockSkewSeconds = value;
  }
  public resetClockSkewSeconds() {
    this._clockSkewSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clockSkewSecondsInput() {
    return this._clockSkewSeconds;
  }

  // issuer - computed: false, optional: true, required: false
  private _issuer?: string; 
  public get issuer() {
    return this.getStringAttribute('issuer');
  }
  public set issuer(value: string) {
    this._issuer = value;
  }
  public resetIssuer() {
    this._issuer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerInput() {
    return this._issuer;
  }

  // jwks - computed: false, optional: true, required: false
  private _jwks = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwksOutputReference(this, "jwks");
  public get jwks() {
    return this._jwks;
  }
  public putJwks(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersJwks) {
    this._jwks.internalValue = value;
  }
  public resetJwks() {
    this._jwks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwksInput() {
    return this._jwks.internalValue;
  }

  // keep_token - computed: false, optional: true, required: false
  private _keepToken?: boolean | cdktf.IResolvable; 
  public get keepToken() {
    return this.getBooleanAttribute('keep_token');
  }
  public set keepToken(value: boolean | cdktf.IResolvable) {
    this._keepToken = value;
  }
  public resetKeepToken() {
    this._keepToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepTokenInput() {
    return this._keepToken;
  }

  // token_source - computed: false, optional: true, required: false
  private _tokenSource = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSourceOutputReference(this, "token_source");
  public get tokenSource() {
    return this._tokenSource;
  }
  public putTokenSource(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersTokenSource) {
    this._tokenSource.internalValue = value;
  }
  public resetTokenSource() {
    this._tokenSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSourceInput() {
    return this._tokenSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#allow_missing_or_failed_jwt DataK8SGatewaySoloIoRouteTableV1Manifest#allow_missing_or_failed_jwt}
  */
  readonly allowMissingOrFailedJwt?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#providers DataK8SGatewaySoloIoRouteTableV1Manifest#providers}
  */
  readonly providers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#validation_policy DataK8SGatewaySoloIoRouteTableV1Manifest#validation_policy}
  */
  readonly validationPolicy?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_missing_or_failed_jwt: cdktf.booleanToTerraform(struct!.allowMissingOrFailedJwt),
    providers: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersToTerraform(struct!.providers),
    validation_policy: cdktf.stringToTerraform(struct!.validationPolicy),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_missing_or_failed_jwt: {
      value: cdktf.booleanToHclTerraform(struct!.allowMissingOrFailedJwt),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersToHclTerraform(struct!.providers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders",
    },
    validation_policy: {
      value: cdktf.stringToHclTerraform(struct!.validationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowMissingOrFailedJwt !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMissingOrFailedJwt = this._allowMissingOrFailedJwt;
    }
    if (this._providers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers?.internalValue;
    }
    if (this._validationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationPolicy = this._validationPolicy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = undefined;
      this._providers.internalValue = undefined;
      this._validationPolicy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = value.allowMissingOrFailedJwt;
      this._providers.internalValue = value.providers;
      this._validationPolicy = value.validationPolicy;
    }
  }

  // allow_missing_or_failed_jwt - computed: false, optional: true, required: false
  private _allowMissingOrFailedJwt?: boolean | cdktf.IResolvable; 
  public get allowMissingOrFailedJwt() {
    return this.getBooleanAttribute('allow_missing_or_failed_jwt');
  }
  public set allowMissingOrFailedJwt(value: boolean | cdktf.IResolvable) {
    this._allowMissingOrFailedJwt = value;
  }
  public resetAllowMissingOrFailedJwt() {
    this._allowMissingOrFailedJwt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMissingOrFailedJwtInput() {
    return this._allowMissingOrFailedJwt;
  }

  // providers - computed: false, optional: true, required: false
  private _providers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProvidersOutputReference(this, "providers");
  public get providers() {
    return this._providers;
  }
  public putProviders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthProviders) {
    this._providers.internalValue = value;
  }
  public resetProviders() {
    this._providers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers.internalValue;
  }

  // validation_policy - computed: false, optional: true, required: false
  private _validationPolicy?: string; 
  public get validationPolicy() {
    return this.getStringAttribute('validation_policy');
  }
  public set validationPolicy(value: string) {
    this._validationPolicy = value;
  }
  public resetValidationPolicy() {
    this._validationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationPolicyInput() {
    return this._validationPolicy;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#append DataK8SGatewaySoloIoRouteTableV1Manifest#append}
  */
  readonly append?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#claim DataK8SGatewaySoloIoRouteTableV1Manifest#claim}
  */
  readonly claim?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header DataK8SGatewaySoloIoRouteTableV1Manifest#header}
  */
  readonly header?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    append: cdktf.booleanToTerraform(struct!.append),
    claim: cdktf.stringToTerraform(struct!.claim),
    header: cdktf.stringToTerraform(struct!.header),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    append: {
      value: cdktf.booleanToHclTerraform(struct!.append),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    claim: {
      value: cdktf.stringToHclTerraform(struct!.claim),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._append !== undefined) {
      hasAnyValues = true;
      internalValueResult.append = this._append;
    }
    if (this._claim !== undefined) {
      hasAnyValues = true;
      internalValueResult.claim = this._claim;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._append = undefined;
      this._claim = undefined;
      this._header = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._append = value.append;
      this._claim = value.claim;
      this._header = value.header;
    }
  }

  // append - computed: false, optional: true, required: false
  private _append?: boolean | cdktf.IResolvable; 
  public get append() {
    return this.getBooleanAttribute('append');
  }
  public set append(value: boolean | cdktf.IResolvable) {
    this._append = value;
  }
  public resetAppend() {
    this._append = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appendInput() {
    return this._append;
  }

  // claim - computed: false, optional: true, required: false
  private _claim?: string; 
  public get claim() {
    return this.getStringAttribute('claim');
  }
  public set claim(value: string) {
    this._claim = value;
  }
  public resetClaim() {
    this._claim = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimInput() {
    return this._claim;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#fast_listener DataK8SGatewaySoloIoRouteTableV1Manifest#fast_listener}
  */
  readonly fastListener?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fast_listener: cdktf.booleanToTerraform(struct!.fastListener),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fast_listener: {
      value: cdktf.booleanToHclTerraform(struct!.fastListener),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fastListener !== undefined) {
      hasAnyValues = true;
      internalValueResult.fastListener = this._fastListener;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fastListener = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fastListener = value.fastListener;
    }
  }

  // fast_listener - computed: false, optional: true, required: false
  private _fastListener?: boolean | cdktf.IResolvable; 
  public get fastListener() {
    return this.getBooleanAttribute('fast_listener');
  }
  public set fastListener(value: boolean | cdktf.IResolvable) {
    this._fastListener = value;
  }
  public resetFastListener() {
    this._fastListener = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fastListenerInput() {
    return this._fastListener;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#async_fetch DataK8SGatewaySoloIoRouteTableV1Manifest#async_fetch}
  */
  readonly asyncFetch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#cache_duration DataK8SGatewaySoloIoRouteTableV1Manifest#cache_duration}
  */
  readonly cacheDuration?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#upstream_ref DataK8SGatewaySoloIoRouteTableV1Manifest#upstream_ref}
  */
  readonly upstreamRef?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#url DataK8SGatewaySoloIoRouteTableV1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_fetch: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToTerraform(struct!.asyncFetch),
    cache_duration: cdktf.stringToTerraform(struct!.cacheDuration),
    upstream_ref: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToTerraform(struct!.upstreamRef),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_fetch: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchToHclTerraform(struct!.asyncFetch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch",
    },
    cache_duration: {
      value: cdktf.stringToHclTerraform(struct!.cacheDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    upstream_ref: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefToHclTerraform(struct!.upstreamRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncFetch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncFetch = this._asyncFetch?.internalValue;
    }
    if (this._cacheDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheDuration = this._cacheDuration;
    }
    if (this._upstreamRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.upstreamRef = this._upstreamRef?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = undefined;
      this._cacheDuration = undefined;
      this._upstreamRef.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncFetch.internalValue = value.asyncFetch;
      this._cacheDuration = value.cacheDuration;
      this._upstreamRef.internalValue = value.upstreamRef;
      this._url = value.url;
    }
  }

  // async_fetch - computed: false, optional: true, required: false
  private _asyncFetch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetchOutputReference(this, "async_fetch");
  public get asyncFetch() {
    return this._asyncFetch;
  }
  public putAsyncFetch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteAsyncFetch) {
    this._asyncFetch.internalValue = value;
  }
  public resetAsyncFetch() {
    this._asyncFetch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncFetchInput() {
    return this._asyncFetch.internalValue;
  }

  // cache_duration - computed: false, optional: true, required: false
  private _cacheDuration?: string; 
  public get cacheDuration() {
    return this.getStringAttribute('cache_duration');
  }
  public set cacheDuration(value: string) {
    this._cacheDuration = value;
  }
  public resetCacheDuration() {
    this._cacheDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheDurationInput() {
    return this._cacheDuration;
  }

  // upstream_ref - computed: false, optional: true, required: false
  private _upstreamRef = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRefOutputReference(this, "upstream_ref");
  public get upstreamRef() {
    return this._upstreamRef;
  }
  public putUpstreamRef(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteUpstreamRef) {
    this._upstreamRef.internalValue = value;
  }
  public resetUpstreamRef() {
    this._upstreamRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get upstreamRefInput() {
    return this._upstreamRef.internalValue;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#local DataK8SGatewaySoloIoRouteTableV1Manifest#local}
  */
  readonly local?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#remote DataK8SGatewaySoloIoRouteTableV1Manifest#remote}
  */
  readonly remote?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    local: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToTerraform(struct!.local),
    remote: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToTerraform(struct!.remote),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    local: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalToHclTerraform(struct!.local),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal",
    },
    remote: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteToHclTerraform(struct!.remote),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._local?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.local = this._local?.internalValue;
    }
    if (this._remote?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.remote = this._remote?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._local.internalValue = undefined;
      this._remote.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._local.internalValue = value.local;
      this._remote.internalValue = value.remote;
    }
  }

  // local - computed: false, optional: true, required: false
  private _local = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocalOutputReference(this, "local");
  public get local() {
    return this._local;
  }
  public putLocal(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksLocal) {
    this._local.internalValue = value;
  }
  public resetLocal() {
    this._local.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localInput() {
    return this._local.internalValue;
  }

  // remote - computed: false, optional: true, required: false
  private _remote = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemoteOutputReference(this, "remote");
  public get remote() {
    return this._remote;
  }
  public putRemote(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksRemote) {
    this._remote.internalValue = value;
  }
  public resetRemote() {
    this._remote.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteInput() {
    return this._remote.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header DataK8SGatewaySoloIoRouteTableV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prefix DataK8SGatewaySoloIoRouteTableV1Manifest#prefix}
  */
  readonly prefix?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    header: cdktf.stringToTerraform(struct!.header),
    prefix: cdktf.stringToTerraform(struct!.prefix),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._header = undefined;
      this._prefix = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._header = value.header;
      this._prefix = value.prefix;
    }
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#query_params DataK8SGatewaySoloIoRouteTableV1Manifest#query_params}
  */
  readonly queryParams?: string[];
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToTerraform, false)(struct!.headers),
    query_params: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.queryParams),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersList",
    },
    query_params: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.queryParams),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    if (this._queryParams !== undefined) {
      hasAnyValues = true;
      internalValueResult.queryParams = this._queryParams;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._headers.internalValue = undefined;
      this._queryParams = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._headers.internalValue = value.headers;
      this._queryParams = value.queryParams;
    }
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }

  // query_params - computed: false, optional: true, required: false
  private _queryParams?: string[]; 
  public get queryParams() {
    return this.getListAttribute('query_params');
  }
  public set queryParams(value: string[]) {
    this._queryParams = value;
  }
  public resetQueryParams() {
    this._queryParams = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queryParamsInput() {
    return this._queryParams;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#audiences DataK8SGatewaySoloIoRouteTableV1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#claims_to_headers DataK8SGatewaySoloIoRouteTableV1Manifest#claims_to_headers}
  */
  readonly claimsToHeaders?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#clock_skew_seconds DataK8SGatewaySoloIoRouteTableV1Manifest#clock_skew_seconds}
  */
  readonly clockSkewSeconds?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#issuer DataK8SGatewaySoloIoRouteTableV1Manifest#issuer}
  */
  readonly issuer?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#jwks DataK8SGatewaySoloIoRouteTableV1Manifest#jwks}
  */
  readonly jwks?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#keep_token DataK8SGatewaySoloIoRouteTableV1Manifest#keep_token}
  */
  readonly keepToken?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#token_source DataK8SGatewaySoloIoRouteTableV1Manifest#token_source}
  */
  readonly tokenSource?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    claims_to_headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToTerraform, false)(struct!.claimsToHeaders),
    clock_skew_seconds: cdktf.numberToTerraform(struct!.clockSkewSeconds),
    issuer: cdktf.stringToTerraform(struct!.issuer),
    jwks: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToTerraform(struct!.jwks),
    keep_token: cdktf.booleanToTerraform(struct!.keepToken),
    token_source: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToTerraform(struct!.tokenSource),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    claims_to_headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersToHclTerraform, false)(struct!.claimsToHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersList",
    },
    clock_skew_seconds: {
      value: cdktf.numberToHclTerraform(struct!.clockSkewSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    issuer: {
      value: cdktf.stringToHclTerraform(struct!.issuer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwks: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksToHclTerraform(struct!.jwks),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks",
    },
    keep_token: {
      value: cdktf.booleanToHclTerraform(struct!.keepToken),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    token_source: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceToHclTerraform(struct!.tokenSource),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._claimsToHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimsToHeaders = this._claimsToHeaders?.internalValue;
    }
    if (this._clockSkewSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.clockSkewSeconds = this._clockSkewSeconds;
    }
    if (this._issuer !== undefined) {
      hasAnyValues = true;
      internalValueResult.issuer = this._issuer;
    }
    if (this._jwks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwks = this._jwks?.internalValue;
    }
    if (this._keepToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepToken = this._keepToken;
    }
    if (this._tokenSource?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSource = this._tokenSource?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._claimsToHeaders.internalValue = undefined;
      this._clockSkewSeconds = undefined;
      this._issuer = undefined;
      this._jwks.internalValue = undefined;
      this._keepToken = undefined;
      this._tokenSource.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._claimsToHeaders.internalValue = value.claimsToHeaders;
      this._clockSkewSeconds = value.clockSkewSeconds;
      this._issuer = value.issuer;
      this._jwks.internalValue = value.jwks;
      this._keepToken = value.keepToken;
      this._tokenSource.internalValue = value.tokenSource;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // claims_to_headers - computed: false, optional: true, required: false
  private _claimsToHeaders = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeadersList(this, "claims_to_headers", false);
  public get claimsToHeaders() {
    return this._claimsToHeaders;
  }
  public putClaimsToHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersClaimsToHeaders[] | cdktf.IResolvable) {
    this._claimsToHeaders.internalValue = value;
  }
  public resetClaimsToHeaders() {
    this._claimsToHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get claimsToHeadersInput() {
    return this._claimsToHeaders.internalValue;
  }

  // clock_skew_seconds - computed: false, optional: true, required: false
  private _clockSkewSeconds?: number; 
  public get clockSkewSeconds() {
    return this.getNumberAttribute('clock_skew_seconds');
  }
  public set clockSkewSeconds(value: number) {
    this._clockSkewSeconds = value;
  }
  public resetClockSkewSeconds() {
    this._clockSkewSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clockSkewSecondsInput() {
    return this._clockSkewSeconds;
  }

  // issuer - computed: false, optional: true, required: false
  private _issuer?: string; 
  public get issuer() {
    return this.getStringAttribute('issuer');
  }
  public set issuer(value: string) {
    this._issuer = value;
  }
  public resetIssuer() {
    this._issuer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get issuerInput() {
    return this._issuer;
  }

  // jwks - computed: false, optional: true, required: false
  private _jwks = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwksOutputReference(this, "jwks");
  public get jwks() {
    return this._jwks;
  }
  public putJwks(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersJwks) {
    this._jwks.internalValue = value;
  }
  public resetJwks() {
    this._jwks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwksInput() {
    return this._jwks.internalValue;
  }

  // keep_token - computed: false, optional: true, required: false
  private _keepToken?: boolean | cdktf.IResolvable; 
  public get keepToken() {
    return this.getBooleanAttribute('keep_token');
  }
  public set keepToken(value: boolean | cdktf.IResolvable) {
    this._keepToken = value;
  }
  public resetKeepToken() {
    this._keepToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepTokenInput() {
    return this._keepToken;
  }

  // token_source - computed: false, optional: true, required: false
  private _tokenSource = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSourceOutputReference(this, "token_source");
  public get tokenSource() {
    return this._tokenSource;
  }
  public putTokenSource(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersTokenSource) {
    this._tokenSource.internalValue = value;
  }
  public resetTokenSource() {
    this._tokenSource.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSourceInput() {
    return this._tokenSource.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#allow_missing_or_failed_jwt DataK8SGatewaySoloIoRouteTableV1Manifest#allow_missing_or_failed_jwt}
  */
  readonly allowMissingOrFailedJwt?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#providers DataK8SGatewaySoloIoRouteTableV1Manifest#providers}
  */
  readonly providers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#validation_policy DataK8SGatewaySoloIoRouteTableV1Manifest#validation_policy}
  */
  readonly validationPolicy?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_missing_or_failed_jwt: cdktf.booleanToTerraform(struct!.allowMissingOrFailedJwt),
    providers: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersToTerraform(struct!.providers),
    validation_policy: cdktf.stringToTerraform(struct!.validationPolicy),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_missing_or_failed_jwt: {
      value: cdktf.booleanToHclTerraform(struct!.allowMissingOrFailedJwt),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    providers: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersToHclTerraform(struct!.providers),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders",
    },
    validation_policy: {
      value: cdktf.stringToHclTerraform(struct!.validationPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowMissingOrFailedJwt !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMissingOrFailedJwt = this._allowMissingOrFailedJwt;
    }
    if (this._providers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.providers = this._providers?.internalValue;
    }
    if (this._validationPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.validationPolicy = this._validationPolicy;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = undefined;
      this._providers.internalValue = undefined;
      this._validationPolicy = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowMissingOrFailedJwt = value.allowMissingOrFailedJwt;
      this._providers.internalValue = value.providers;
      this._validationPolicy = value.validationPolicy;
    }
  }

  // allow_missing_or_failed_jwt - computed: false, optional: true, required: false
  private _allowMissingOrFailedJwt?: boolean | cdktf.IResolvable; 
  public get allowMissingOrFailedJwt() {
    return this.getBooleanAttribute('allow_missing_or_failed_jwt');
  }
  public set allowMissingOrFailedJwt(value: boolean | cdktf.IResolvable) {
    this._allowMissingOrFailedJwt = value;
  }
  public resetAllowMissingOrFailedJwt() {
    this._allowMissingOrFailedJwt = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMissingOrFailedJwtInput() {
    return this._allowMissingOrFailedJwt;
  }

  // providers - computed: false, optional: true, required: false
  private _providers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProvidersOutputReference(this, "providers");
  public get providers() {
    return this._providers;
  }
  public putProviders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthProviders) {
    this._providers.internalValue = value;
  }
  public resetProviders() {
    this._providers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providersInput() {
    return this._providers.internalValue;
  }

  // validation_policy - computed: false, optional: true, required: false
  private _validationPolicy?: string; 
  public get validationPolicy() {
    return this.getStringAttribute('validation_policy');
  }
  public set validationPolicy(value: string) {
    this._validationPolicy = value;
  }
  public resetValidationPolicy() {
    this._validationPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validationPolicyInput() {
    return this._validationPolicy;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStaged {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#after_ext_auth DataK8SGatewaySoloIoRouteTableV1Manifest#after_ext_auth}
  */
  readonly afterExtAuth?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#before_ext_auth DataK8SGatewaySoloIoRouteTableV1Manifest#before_ext_auth}
  */
  readonly beforeExtAuth?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    after_ext_auth: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthToTerraform(struct!.afterExtAuth),
    before_ext_auth: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthToTerraform(struct!.beforeExtAuth),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    after_ext_auth: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthToHclTerraform(struct!.afterExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth",
    },
    before_ext_auth: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthToHclTerraform(struct!.beforeExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStaged | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._afterExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.afterExtAuth = this._afterExtAuth?.internalValue;
    }
    if (this._beforeExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.beforeExtAuth = this._beforeExtAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStaged | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = undefined;
      this._beforeExtAuth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = value.afterExtAuth;
      this._beforeExtAuth.internalValue = value.beforeExtAuth;
    }
  }

  // after_ext_auth - computed: false, optional: true, required: false
  private _afterExtAuth = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuthOutputReference(this, "after_ext_auth");
  public get afterExtAuth() {
    return this._afterExtAuth;
  }
  public putAfterExtAuth(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedAfterExtAuth) {
    this._afterExtAuth.internalValue = value;
  }
  public resetAfterExtAuth() {
    this._afterExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afterExtAuthInput() {
    return this._afterExtAuth.internalValue;
  }

  // before_ext_auth - computed: false, optional: true, required: false
  private _beforeExtAuth = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuthOutputReference(this, "before_ext_auth");
  public get beforeExtAuth() {
    return this._beforeExtAuth;
  }
  public putBeforeExtAuth(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtProvidersStagedBeforeExtAuth) {
    this._beforeExtAuth.internalValue = value;
  }
  public resetBeforeExtAuth() {
    this._beforeExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beforeExtAuthInput() {
    return this._beforeExtAuth.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#disable DataK8SGatewaySoloIoRouteTableV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#disable DataK8SGatewaySoloIoRouteTableV1Manifest#disable}
  */
  readonly disable?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuthToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disable: cdktf.booleanToTerraform(struct!.disable),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuthToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disable: {
      value: cdktf.booleanToHclTerraform(struct!.disable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disable !== undefined) {
      hasAnyValues = true;
      internalValueResult.disable = this._disable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disable = value.disable;
    }
  }

  // disable - computed: false, optional: true, required: false
  private _disable?: boolean | cdktf.IResolvable; 
  public get disable() {
    return this.getBooleanAttribute('disable');
  }
  public set disable(value: boolean | cdktf.IResolvable) {
    this._disable = value;
  }
  public resetDisable() {
    this._disable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableInput() {
    return this._disable;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStaged {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#after_ext_auth DataK8SGatewaySoloIoRouteTableV1Manifest#after_ext_auth}
  */
  readonly afterExtAuth?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#before_ext_auth DataK8SGatewaySoloIoRouteTableV1Manifest#before_ext_auth}
  */
  readonly beforeExtAuth?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    after_ext_auth: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuthToTerraform(struct!.afterExtAuth),
    before_ext_auth: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuthToTerraform(struct!.beforeExtAuth),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStaged | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    after_ext_auth: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuthToHclTerraform(struct!.afterExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth",
    },
    before_ext_auth: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuthToHclTerraform(struct!.beforeExtAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStaged | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._afterExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.afterExtAuth = this._afterExtAuth?.internalValue;
    }
    if (this._beforeExtAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.beforeExtAuth = this._beforeExtAuth?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStaged | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = undefined;
      this._beforeExtAuth.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._afterExtAuth.internalValue = value.afterExtAuth;
      this._beforeExtAuth.internalValue = value.beforeExtAuth;
    }
  }

  // after_ext_auth - computed: false, optional: true, required: false
  private _afterExtAuth = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuthOutputReference(this, "after_ext_auth");
  public get afterExtAuth() {
    return this._afterExtAuth;
  }
  public putAfterExtAuth(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedAfterExtAuth) {
    this._afterExtAuth.internalValue = value;
  }
  public resetAfterExtAuth() {
    this._afterExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get afterExtAuthInput() {
    return this._afterExtAuth.internalValue;
  }

  // before_ext_auth - computed: false, optional: true, required: false
  private _beforeExtAuth = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuthOutputReference(this, "before_ext_auth");
  public get beforeExtAuth() {
    return this._beforeExtAuth;
  }
  public putBeforeExtAuth(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsJwtStagedBeforeExtAuth) {
    this._beforeExtAuth.internalValue = value;
  }
  public resetBeforeExtAuth() {
    this._beforeExtAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get beforeExtAuthInput() {
    return this._beforeExtAuth.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#path DataK8SGatewaySoloIoRouteTableV1Manifest#path}
  */
  readonly path?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#ttl DataK8SGatewaySoloIoRouteTableV1Manifest#ttl}
  */
  readonly ttl?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookieToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    path: cdktf.stringToTerraform(struct!.path),
    ttl: cdktf.stringToTerraform(struct!.ttl),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookieToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookieOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._path = undefined;
      this._ttl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._path = value.path;
      this._ttl = value.ttl;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // ttl - computed: false, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#cookie DataK8SGatewaySoloIoRouteTableV1Manifest#cookie}
  */
  readonly cookie?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header DataK8SGatewaySoloIoRouteTableV1Manifest#header}
  */
  readonly header?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#source_ip DataK8SGatewaySoloIoRouteTableV1Manifest#source_ip}
  */
  readonly sourceIp?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#terminal DataK8SGatewaySoloIoRouteTableV1Manifest#terminal}
  */
  readonly terminal?: boolean | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cookie: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookieToTerraform(struct!.cookie),
    header: cdktf.stringToTerraform(struct!.header),
    source_ip: cdktf.booleanToTerraform(struct!.sourceIp),
    terminal: cdktf.booleanToTerraform(struct!.terminal),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cookie: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookieToHclTerraform(struct!.cookie),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie",
    },
    header: {
      value: cdktf.stringToHclTerraform(struct!.header),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source_ip: {
      value: cdktf.booleanToHclTerraform(struct!.sourceIp),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    terminal: {
      value: cdktf.booleanToHclTerraform(struct!.terminal),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cookie?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cookie = this._cookie?.internalValue;
    }
    if (this._header !== undefined) {
      hasAnyValues = true;
      internalValueResult.header = this._header;
    }
    if (this._sourceIp !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceIp = this._sourceIp;
    }
    if (this._terminal !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminal = this._terminal;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cookie.internalValue = undefined;
      this._header = undefined;
      this._sourceIp = undefined;
      this._terminal = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cookie.internalValue = value.cookie;
      this._header = value.header;
      this._sourceIp = value.sourceIp;
      this._terminal = value.terminal;
    }
  }

  // cookie - computed: false, optional: true, required: false
  private _cookie = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookieOutputReference(this, "cookie");
  public get cookie() {
    return this._cookie;
  }
  public putCookie(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesCookie) {
    this._cookie.internalValue = value;
  }
  public resetCookie() {
    this._cookie.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cookieInput() {
    return this._cookie.internalValue;
  }

  // header - computed: false, optional: true, required: false
  private _header?: string; 
  public get header() {
    return this.getStringAttribute('header');
  }
  public set header(value: string) {
    this._header = value;
  }
  public resetHeader() {
    this._header = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerInput() {
    return this._header;
  }

  // source_ip - computed: false, optional: true, required: false
  private _sourceIp?: boolean | cdktf.IResolvable; 
  public get sourceIp() {
    return this.getBooleanAttribute('source_ip');
  }
  public set sourceIp(value: boolean | cdktf.IResolvable) {
    this._sourceIp = value;
  }
  public resetSourceIp() {
    this._sourceIp = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceIpInput() {
    return this._sourceIp;
  }

  // terminal - computed: false, optional: true, required: false
  private _terminal?: boolean | cdktf.IResolvable; 
  public get terminal() {
    return this.getBooleanAttribute('terminal');
  }
  public set terminal(value: boolean | cdktf.IResolvable) {
    this._terminal = value;
  }
  public resetTerminal() {
    this._terminal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminalInput() {
    return this._terminal;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHash {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#hash_policies DataK8SGatewaySoloIoRouteTableV1Manifest#hash_policies}
  */
  readonly hashPolicies?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hash_policies: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesToTerraform, false)(struct!.hashPolicies),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHash | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hash_policies: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesToHclTerraform, false)(struct!.hashPolicies),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHash | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hashPolicies?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hashPolicies = this._hashPolicies?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHash | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hashPolicies.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hashPolicies.internalValue = value.hashPolicies;
    }
  }

  // hash_policies - computed: false, optional: true, required: false
  private _hashPolicies = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPoliciesList(this, "hash_policies", false);
  public get hashPolicies() {
    return this._hashPolicies;
  }
  public putHashPolicies(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsLbHashHashPolicies[] | cdktf.IResolvable) {
    this._hashPolicies.internalValue = value;
  }
  public resetHashPolicies() {
    this._hashPolicies.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hashPoliciesInput() {
    return this._hashPolicies.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDuration {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#grpc_timeout_header_max DataK8SGatewaySoloIoRouteTableV1Manifest#grpc_timeout_header_max}
  */
  readonly grpcTimeoutHeaderMax?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#grpc_timeout_header_offset DataK8SGatewaySoloIoRouteTableV1Manifest#grpc_timeout_header_offset}
  */
  readonly grpcTimeoutHeaderOffset?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_stream_duration DataK8SGatewaySoloIoRouteTableV1Manifest#max_stream_duration}
  */
  readonly maxStreamDuration?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDurationToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    grpc_timeout_header_max: cdktf.stringToTerraform(struct!.grpcTimeoutHeaderMax),
    grpc_timeout_header_offset: cdktf.stringToTerraform(struct!.grpcTimeoutHeaderOffset),
    max_stream_duration: cdktf.stringToTerraform(struct!.maxStreamDuration),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDurationToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDuration | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    grpc_timeout_header_max: {
      value: cdktf.stringToHclTerraform(struct!.grpcTimeoutHeaderMax),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    grpc_timeout_header_offset: {
      value: cdktf.stringToHclTerraform(struct!.grpcTimeoutHeaderOffset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_stream_duration: {
      value: cdktf.stringToHclTerraform(struct!.maxStreamDuration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDurationOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDuration | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._grpcTimeoutHeaderMax !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcTimeoutHeaderMax = this._grpcTimeoutHeaderMax;
    }
    if (this._grpcTimeoutHeaderOffset !== undefined) {
      hasAnyValues = true;
      internalValueResult.grpcTimeoutHeaderOffset = this._grpcTimeoutHeaderOffset;
    }
    if (this._maxStreamDuration !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxStreamDuration = this._maxStreamDuration;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsMaxStreamDuration | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._grpcTimeoutHeaderMax = undefined;
      this._grpcTimeoutHeaderOffset = undefined;
      this._maxStreamDuration = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._grpcTimeoutHeaderMax = value.grpcTimeoutHeaderMax;
      this._grpcTimeoutHeaderOffset = value.grpcTimeoutHeaderOffset;
      this._maxStreamDuration = value.maxStreamDuration;
    }
  }

  // grpc_timeout_header_max - computed: false, optional: true, required: false
  private _grpcTimeoutHeaderMax?: string; 
  public get grpcTimeoutHeaderMax() {
    return this.getStringAttribute('grpc_timeout_header_max');
  }
  public set grpcTimeoutHeaderMax(value: string) {
    this._grpcTimeoutHeaderMax = value;
  }
  public resetGrpcTimeoutHeaderMax() {
    this._grpcTimeoutHeaderMax = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcTimeoutHeaderMaxInput() {
    return this._grpcTimeoutHeaderMax;
  }

  // grpc_timeout_header_offset - computed: false, optional: true, required: false
  private _grpcTimeoutHeaderOffset?: string; 
  public get grpcTimeoutHeaderOffset() {
    return this.getStringAttribute('grpc_timeout_header_offset');
  }
  public set grpcTimeoutHeaderOffset(value: string) {
    this._grpcTimeoutHeaderOffset = value;
  }
  public resetGrpcTimeoutHeaderOffset() {
    this._grpcTimeoutHeaderOffset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get grpcTimeoutHeaderOffsetInput() {
    return this._grpcTimeoutHeaderOffset;
  }

  // max_stream_duration - computed: false, optional: true, required: false
  private _maxStreamDuration?: string; 
  public get maxStreamDuration() {
    return this.getStringAttribute('max_stream_duration');
  }
  public set maxStreamDuration(value: string) {
    this._maxStreamDuration = value;
  }
  public resetMaxStreamDuration() {
    this._maxStreamDuration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxStreamDurationInput() {
    return this._maxStreamDuration;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#refs DataK8SGatewaySoloIoRouteTableV1Manifest#refs}
  */
  readonly refs?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    refs: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsToTerraform, false)(struct!.refs),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    refs: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsToHclTerraform, false)(struct!.refs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._refs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.refs = this._refs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._refs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._refs.internalValue = value.refs;
    }
  }

  // refs - computed: false, optional: true, required: false
  private _refs = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefsList(this, "refs", false);
  public get refs() {
    return this._refs;
  }
  public putRefs(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitConfigsRefs[] | cdktf.IResolvable) {
    this._refs.internalValue = value;
  }
  public resetRefs() {
    this._refs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refsInput() {
    return this._refs.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#refs DataK8SGatewaySoloIoRouteTableV1Manifest#refs}
  */
  readonly refs?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    refs: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsToTerraform, false)(struct!.refs),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    refs: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsToHclTerraform, false)(struct!.refs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._refs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.refs = this._refs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._refs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._refs.internalValue = value.refs;
    }
  }

  // refs - computed: false, optional: true, required: false
  private _refs = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefsList(this, "refs", false);
  public get refs() {
    return this._refs;
  }
  public putRefs(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitEarlyConfigsRefs[] | cdktf.IResolvable) {
    this._refs.internalValue = value;
  }
  public resetRefs() {
    this._refs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refsInput() {
    return this._refs.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#namespace DataK8SGatewaySoloIoRouteTableV1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigs {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#refs DataK8SGatewaySoloIoRouteTableV1Manifest#refs}
  */
  readonly refs?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    refs: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsToTerraform, false)(struct!.refs),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    refs: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsToHclTerraform, false)(struct!.refs),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._refs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.refs = this._refs?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._refs.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._refs.internalValue = value.refs;
    }
  }

  // refs - computed: false, optional: true, required: false
  private _refs = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefsList(this, "refs", false);
  public get refs() {
    return this._refs;
  }
  public putRefs(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRateLimitRegularConfigsRefs[] | cdktf.IResolvable) {
    this._refs.internalValue = value;
  }
  public resetRefs() {
    this._refs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refsInput() {
    return this._refs.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#fill_interval DataK8SGatewaySoloIoRouteTableV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_tokens DataK8SGatewaySoloIoRouteTableV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoRouteTableV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#end DataK8SGatewaySoloIoRouteTableV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#start DataK8SGatewaySoloIoRouteTableV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#exact_match DataK8SGatewaySoloIoRouteTableV1Manifest#exact_match}
  */
  readonly exactMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#invert_match DataK8SGatewaySoloIoRouteTableV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prefix_match DataK8SGatewaySoloIoRouteTableV1Manifest#prefix_match}
  */
  readonly prefixMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#present_match DataK8SGatewaySoloIoRouteTableV1Manifest#present_match}
  */
  readonly presentMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#range_match DataK8SGatewaySoloIoRouteTableV1Manifest#range_match}
  */
  readonly rangeMatch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex_match DataK8SGatewaySoloIoRouteTableV1Manifest#regex_match}
  */
  readonly regexMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#suffix_match DataK8SGatewaySoloIoRouteTableV1Manifest#suffix_match}
  */
  readonly suffixMatch?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact_match: cdktf.stringToTerraform(struct!.exactMatch),
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    prefix_match: cdktf.stringToTerraform(struct!.prefixMatch),
    present_match: cdktf.booleanToTerraform(struct!.presentMatch),
    range_match: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct!.rangeMatch),
    regex_match: cdktf.stringToTerraform(struct!.regexMatch),
    suffix_match: cdktf.stringToTerraform(struct!.suffixMatch),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact_match: {
      value: cdktf.stringToHclTerraform(struct!.exactMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_match: {
      value: cdktf.stringToHclTerraform(struct!.prefixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present_match: {
      value: cdktf.booleanToHclTerraform(struct!.presentMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    range_match: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct!.rangeMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch",
    },
    regex_match: {
      value: cdktf.stringToHclTerraform(struct!.regexMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix_match: {
      value: cdktf.stringToHclTerraform(struct!.suffixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exactMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactMatch = this._exactMatch;
    }
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixMatch = this._prefixMatch;
    }
    if (this._presentMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.presentMatch = this._presentMatch;
    }
    if (this._rangeMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rangeMatch = this._rangeMatch?.internalValue;
    }
    if (this._regexMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexMatch = this._regexMatch;
    }
    if (this._suffixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffixMatch = this._suffixMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exactMatch = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._prefixMatch = undefined;
      this._presentMatch = undefined;
      this._rangeMatch.internalValue = undefined;
      this._regexMatch = undefined;
      this._suffixMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exactMatch = value.exactMatch;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._prefixMatch = value.prefixMatch;
      this._presentMatch = value.presentMatch;
      this._rangeMatch.internalValue = value.rangeMatch;
      this._regexMatch = value.regexMatch;
      this._suffixMatch = value.suffixMatch;
    }
  }

  // exact_match - computed: false, optional: true, required: false
  private _exactMatch?: string; 
  public get exactMatch() {
    return this.getStringAttribute('exact_match');
  }
  public set exactMatch(value: string) {
    this._exactMatch = value;
  }
  public resetExactMatch() {
    this._exactMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactMatchInput() {
    return this._exactMatch;
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix_match - computed: false, optional: true, required: false
  private _prefixMatch?: string; 
  public get prefixMatch() {
    return this.getStringAttribute('prefix_match');
  }
  public set prefixMatch(value: string) {
    this._prefixMatch = value;
  }
  public resetPrefixMatch() {
    this._prefixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixMatchInput() {
    return this._prefixMatch;
  }

  // present_match - computed: false, optional: true, required: false
  private _presentMatch?: boolean | cdktf.IResolvable; 
  public get presentMatch() {
    return this.getBooleanAttribute('present_match');
  }
  public set presentMatch(value: boolean | cdktf.IResolvable) {
    this._presentMatch = value;
  }
  public resetPresentMatch() {
    this._presentMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentMatchInput() {
    return this._presentMatch;
  }

  // range_match - computed: false, optional: true, required: false
  private _rangeMatch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference(this, "range_match");
  public get rangeMatch() {
    return this._rangeMatch;
  }
  public putRangeMatch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersRangeMatch) {
    this._rangeMatch.internalValue = value;
  }
  public resetRangeMatch() {
    this._rangeMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeMatchInput() {
    return this._rangeMatch.internalValue;
  }

  // regex_match - computed: false, optional: true, required: false
  private _regexMatch?: string; 
  public get regexMatch() {
    return this.getStringAttribute('regex_match');
  }
  public set regexMatch(value: string) {
    this._regexMatch = value;
  }
  public resetRegexMatch() {
    this._regexMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexMatchInput() {
    return this._regexMatch;
  }

  // suffix_match - computed: false, optional: true, required: false
  private _suffixMatch?: string; 
  public get suffixMatch() {
    return this.getStringAttribute('suffix_match');
  }
  public set suffixMatch(value: string) {
    this._suffixMatch = value;
  }
  public resetSuffixMatch() {
    this._suffixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixMatchInput() {
    return this._suffixMatch;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#expect_match DataK8SGatewaySoloIoRouteTableV1Manifest#expect_match}
  */
  readonly expectMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
    expect_match: cdktf.booleanToTerraform(struct!.expectMatch),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToTerraform, false)(struct!.headers),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect_match: {
      value: cdktf.booleanToHclTerraform(struct!.expectMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    if (this._expectMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectMatch = this._expectMatch;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
      this._expectMatch = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
      this._expectMatch = value.expectMatch;
      this._headers.internalValue = value.headers;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }

  // expect_match - computed: false, optional: true, required: false
  private _expectMatch?: boolean | cdktf.IResolvable; 
  public get expectMatch() {
    return this.getBooleanAttribute('expect_match');
  }
  public set expectMatch(value: boolean | cdktf.IResolvable) {
    this._expectMatch = value;
  }
  public resetExpectMatch() {
    this._expectMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectMatchInput() {
    return this._expectMatch;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#path DataK8SGatewaySoloIoRouteTableV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#default_value DataK8SGatewaySoloIoRouteTableV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteTableV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#source DataK8SGatewaySoloIoRouteTableV1Manifest#source}
  */
  readonly source?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    metadata_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToTerraform(struct!.metadataKey),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._descriptorKey = undefined;
      this._metadataKey.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._descriptorKey = value.descriptorKey;
      this._metadataKey.internalValue = value.metadataKey;
      this._source = value.source;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header_name DataK8SGatewaySoloIoRouteTableV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorKey = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorKey = value.descriptorKey;
      this._headerName = value.headerName;
    }
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#destination_cluster DataK8SGatewaySoloIoRouteTableV1Manifest#destination_cluster}
  */
  readonly destinationCluster?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#generic_key DataK8SGatewaySoloIoRouteTableV1Manifest#generic_key}
  */
  readonly genericKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header_value_match DataK8SGatewaySoloIoRouteTableV1Manifest#header_value_match}
  */
  readonly headerValueMatch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata DataK8SGatewaySoloIoRouteTableV1Manifest#metadata}
  */
  readonly metadata?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#remote_address DataK8SGatewaySoloIoRouteTableV1Manifest#remote_address}
  */
  readonly remoteAddress?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_headers DataK8SGatewaySoloIoRouteTableV1Manifest#request_headers}
  */
  readonly requestHeaders?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#source_cluster DataK8SGatewaySoloIoRouteTableV1Manifest#source_cluster}
  */
  readonly sourceCluster?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.destinationCluster),
    generic_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKeyToTerraform(struct!.genericKey),
    header_value_match: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchToTerraform(struct!.headerValueMatch),
    metadata: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataToTerraform(struct!.metadata),
    remote_address: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remoteAddress),
    request_headers: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeadersToTerraform(struct!.requestHeaders),
    source_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.sourceCluster),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.destinationCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    generic_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKeyToHclTerraform(struct!.genericKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey",
    },
    header_value_match: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchToHclTerraform(struct!.headerValueMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch",
    },
    metadata: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata",
    },
    remote_address: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remoteAddress),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    request_headers: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeadersToHclTerraform(struct!.requestHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders",
    },
    source_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.sourceCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destinationCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationCluster = this._destinationCluster;
    }
    if (this._genericKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.genericKey = this._genericKey?.internalValue;
    }
    if (this._headerValueMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValueMatch = this._headerValueMatch?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._remoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteAddress = this._remoteAddress;
    }
    if (this._requestHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaders = this._requestHeaders?.internalValue;
    }
    if (this._sourceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceCluster = this._sourceCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destinationCluster = undefined;
      this._genericKey.internalValue = undefined;
      this._headerValueMatch.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._remoteAddress = undefined;
      this._requestHeaders.internalValue = undefined;
      this._sourceCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destinationCluster = value.destinationCluster;
      this._genericKey.internalValue = value.genericKey;
      this._headerValueMatch.internalValue = value.headerValueMatch;
      this._metadata.internalValue = value.metadata;
      this._remoteAddress = value.remoteAddress;
      this._requestHeaders.internalValue = value.requestHeaders;
      this._sourceCluster = value.sourceCluster;
    }
  }

  // destination_cluster - computed: false, optional: true, required: false
  private _destinationCluster?: { [key: string]: string }; 
  public get destinationCluster() {
    return this.getStringMapAttribute('destination_cluster');
  }
  public set destinationCluster(value: { [key: string]: string }) {
    this._destinationCluster = value;
  }
  public resetDestinationCluster() {
    this._destinationCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationClusterInput() {
    return this._destinationCluster;
  }

  // generic_key - computed: false, optional: true, required: false
  private _genericKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKeyOutputReference(this, "generic_key");
  public get genericKey() {
    return this._genericKey;
  }
  public putGenericKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsGenericKey) {
    this._genericKey.internalValue = value;
  }
  public resetGenericKey() {
    this._genericKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get genericKeyInput() {
    return this._genericKey.internalValue;
  }

  // header_value_match - computed: false, optional: true, required: false
  private _headerValueMatch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatchOutputReference(this, "header_value_match");
  public get headerValueMatch() {
    return this._headerValueMatch;
  }
  public putHeaderValueMatch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsHeaderValueMatch) {
    this._headerValueMatch.internalValue = value;
  }
  public resetHeaderValueMatch() {
    this._headerValueMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValueMatchInput() {
    return this._headerValueMatch.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // remote_address - computed: false, optional: true, required: false
  private _remoteAddress?: { [key: string]: string }; 
  public get remoteAddress() {
    return this.getStringMapAttribute('remote_address');
  }
  public set remoteAddress(value: { [key: string]: string }) {
    this._remoteAddress = value;
  }
  public resetRemoteAddress() {
    this._remoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteAddressInput() {
    return this._remoteAddress;
  }

  // request_headers - computed: false, optional: true, required: false
  private _requestHeaders = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeadersOutputReference(this, "request_headers");
  public get requestHeaders() {
    return this._requestHeaders;
  }
  public putRequestHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsRequestHeaders) {
    this._requestHeaders.internalValue = value;
  }
  public resetRequestHeaders() {
    this._requestHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersInput() {
    return this._requestHeaders.internalValue;
  }

  // source_cluster - computed: false, optional: true, required: false
  private _sourceCluster?: { [key: string]: string }; 
  public get sourceCluster() {
    return this.getStringMapAttribute('source_cluster');
  }
  public set sourceCluster(value: { [key: string]: string }) {
    this._sourceCluster = value;
  }
  public resetSourceCluster() {
    this._sourceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceClusterInput() {
    return this._sourceCluster;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#path DataK8SGatewaySoloIoRouteTableV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteTableV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct!.metadataKey),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = value.metadataKey;
    }
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#dynamic_metadata DataK8SGatewaySoloIoRouteTableV1Manifest#dynamic_metadata}
  */
  readonly dynamicMetadata?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    dynamic_metadata: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataToTerraform(struct!.dynamicMetadata),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    dynamic_metadata: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataToHclTerraform(struct!.dynamicMetadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dynamicMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicMetadata = this._dynamicMetadata?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dynamicMetadata.internalValue = value.dynamicMetadata;
    }
  }

  // dynamic_metadata - computed: false, optional: true, required: false
  private _dynamicMetadata = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadataOutputReference(this, "dynamic_metadata");
  public get dynamicMetadata() {
    return this._dynamicMetadata;
  }
  public putDynamicMetadata(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitDynamicMetadata) {
    this._dynamicMetadata.internalValue = value;
  }
  public resetDynamicMetadata() {
    this._dynamicMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicMetadataInput() {
    return this._dynamicMetadata.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#end DataK8SGatewaySoloIoRouteTableV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#start DataK8SGatewaySoloIoRouteTableV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#exact_match DataK8SGatewaySoloIoRouteTableV1Manifest#exact_match}
  */
  readonly exactMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#invert_match DataK8SGatewaySoloIoRouteTableV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prefix_match DataK8SGatewaySoloIoRouteTableV1Manifest#prefix_match}
  */
  readonly prefixMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#present_match DataK8SGatewaySoloIoRouteTableV1Manifest#present_match}
  */
  readonly presentMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#range_match DataK8SGatewaySoloIoRouteTableV1Manifest#range_match}
  */
  readonly rangeMatch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex_match DataK8SGatewaySoloIoRouteTableV1Manifest#regex_match}
  */
  readonly regexMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#suffix_match DataK8SGatewaySoloIoRouteTableV1Manifest#suffix_match}
  */
  readonly suffixMatch?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact_match: cdktf.stringToTerraform(struct!.exactMatch),
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    prefix_match: cdktf.stringToTerraform(struct!.prefixMatch),
    present_match: cdktf.booleanToTerraform(struct!.presentMatch),
    range_match: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct!.rangeMatch),
    regex_match: cdktf.stringToTerraform(struct!.regexMatch),
    suffix_match: cdktf.stringToTerraform(struct!.suffixMatch),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact_match: {
      value: cdktf.stringToHclTerraform(struct!.exactMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_match: {
      value: cdktf.stringToHclTerraform(struct!.prefixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present_match: {
      value: cdktf.booleanToHclTerraform(struct!.presentMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    range_match: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct!.rangeMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch",
    },
    regex_match: {
      value: cdktf.stringToHclTerraform(struct!.regexMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix_match: {
      value: cdktf.stringToHclTerraform(struct!.suffixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exactMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactMatch = this._exactMatch;
    }
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixMatch = this._prefixMatch;
    }
    if (this._presentMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.presentMatch = this._presentMatch;
    }
    if (this._rangeMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rangeMatch = this._rangeMatch?.internalValue;
    }
    if (this._regexMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexMatch = this._regexMatch;
    }
    if (this._suffixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffixMatch = this._suffixMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exactMatch = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._prefixMatch = undefined;
      this._presentMatch = undefined;
      this._rangeMatch.internalValue = undefined;
      this._regexMatch = undefined;
      this._suffixMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exactMatch = value.exactMatch;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._prefixMatch = value.prefixMatch;
      this._presentMatch = value.presentMatch;
      this._rangeMatch.internalValue = value.rangeMatch;
      this._regexMatch = value.regexMatch;
      this._suffixMatch = value.suffixMatch;
    }
  }

  // exact_match - computed: false, optional: true, required: false
  private _exactMatch?: string; 
  public get exactMatch() {
    return this.getStringAttribute('exact_match');
  }
  public set exactMatch(value: string) {
    this._exactMatch = value;
  }
  public resetExactMatch() {
    this._exactMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactMatchInput() {
    return this._exactMatch;
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix_match - computed: false, optional: true, required: false
  private _prefixMatch?: string; 
  public get prefixMatch() {
    return this.getStringAttribute('prefix_match');
  }
  public set prefixMatch(value: string) {
    this._prefixMatch = value;
  }
  public resetPrefixMatch() {
    this._prefixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixMatchInput() {
    return this._prefixMatch;
  }

  // present_match - computed: false, optional: true, required: false
  private _presentMatch?: boolean | cdktf.IResolvable; 
  public get presentMatch() {
    return this.getBooleanAttribute('present_match');
  }
  public set presentMatch(value: boolean | cdktf.IResolvable) {
    this._presentMatch = value;
  }
  public resetPresentMatch() {
    this._presentMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentMatchInput() {
    return this._presentMatch;
  }

  // range_match - computed: false, optional: true, required: false
  private _rangeMatch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatchOutputReference(this, "range_match");
  public get rangeMatch() {
    return this._rangeMatch;
  }
  public putRangeMatch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersRangeMatch) {
    this._rangeMatch.internalValue = value;
  }
  public resetRangeMatch() {
    this._rangeMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeMatchInput() {
    return this._rangeMatch.internalValue;
  }

  // regex_match - computed: false, optional: true, required: false
  private _regexMatch?: string; 
  public get regexMatch() {
    return this.getStringAttribute('regex_match');
  }
  public set regexMatch(value: string) {
    this._regexMatch = value;
  }
  public resetRegexMatch() {
    this._regexMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexMatchInput() {
    return this._regexMatch;
  }

  // suffix_match - computed: false, optional: true, required: false
  private _suffixMatch?: string; 
  public get suffixMatch() {
    return this.getStringAttribute('suffix_match');
  }
  public set suffixMatch(value: string) {
    this._suffixMatch = value;
  }
  public resetSuffixMatch() {
    this._suffixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixMatchInput() {
    return this._suffixMatch;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#expect_match DataK8SGatewaySoloIoRouteTableV1Manifest#expect_match}
  */
  readonly expectMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
    expect_match: cdktf.booleanToTerraform(struct!.expectMatch),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToTerraform, false)(struct!.headers),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect_match: {
      value: cdktf.booleanToHclTerraform(struct!.expectMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    if (this._expectMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectMatch = this._expectMatch;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
      this._expectMatch = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
      this._expectMatch = value.expectMatch;
      this._headers.internalValue = value.headers;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }

  // expect_match - computed: false, optional: true, required: false
  private _expectMatch?: boolean | cdktf.IResolvable; 
  public get expectMatch() {
    return this.getBooleanAttribute('expect_match');
  }
  public set expectMatch(value: boolean | cdktf.IResolvable) {
    this._expectMatch = value;
  }
  public resetExpectMatch() {
    this._expectMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectMatchInput() {
    return this._expectMatch;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#path DataK8SGatewaySoloIoRouteTableV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#default_value DataK8SGatewaySoloIoRouteTableV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteTableV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#source DataK8SGatewaySoloIoRouteTableV1Manifest#source}
  */
  readonly source?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    metadata_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToTerraform(struct!.metadataKey),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._descriptorKey = undefined;
      this._metadataKey.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._descriptorKey = value.descriptorKey;
      this._metadataKey.internalValue = value.metadataKey;
      this._source = value.source;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header_name DataK8SGatewaySoloIoRouteTableV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorKey = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorKey = value.descriptorKey;
      this._headerName = value.headerName;
    }
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#destination_cluster DataK8SGatewaySoloIoRouteTableV1Manifest#destination_cluster}
  */
  readonly destinationCluster?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#generic_key DataK8SGatewaySoloIoRouteTableV1Manifest#generic_key}
  */
  readonly genericKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header_value_match DataK8SGatewaySoloIoRouteTableV1Manifest#header_value_match}
  */
  readonly headerValueMatch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata DataK8SGatewaySoloIoRouteTableV1Manifest#metadata}
  */
  readonly metadata?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#remote_address DataK8SGatewaySoloIoRouteTableV1Manifest#remote_address}
  */
  readonly remoteAddress?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_headers DataK8SGatewaySoloIoRouteTableV1Manifest#request_headers}
  */
  readonly requestHeaders?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#source_cluster DataK8SGatewaySoloIoRouteTableV1Manifest#source_cluster}
  */
  readonly sourceCluster?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.destinationCluster),
    generic_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKeyToTerraform(struct!.genericKey),
    header_value_match: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToTerraform(struct!.headerValueMatch),
    metadata: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataToTerraform(struct!.metadata),
    remote_address: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remoteAddress),
    request_headers: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeadersToTerraform(struct!.requestHeaders),
    source_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.sourceCluster),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.destinationCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    generic_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKeyToHclTerraform(struct!.genericKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey",
    },
    header_value_match: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchToHclTerraform(struct!.headerValueMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch",
    },
    metadata: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata",
    },
    remote_address: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remoteAddress),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    request_headers: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeadersToHclTerraform(struct!.requestHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders",
    },
    source_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.sourceCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destinationCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationCluster = this._destinationCluster;
    }
    if (this._genericKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.genericKey = this._genericKey?.internalValue;
    }
    if (this._headerValueMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValueMatch = this._headerValueMatch?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._remoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteAddress = this._remoteAddress;
    }
    if (this._requestHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaders = this._requestHeaders?.internalValue;
    }
    if (this._sourceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceCluster = this._sourceCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destinationCluster = undefined;
      this._genericKey.internalValue = undefined;
      this._headerValueMatch.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._remoteAddress = undefined;
      this._requestHeaders.internalValue = undefined;
      this._sourceCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destinationCluster = value.destinationCluster;
      this._genericKey.internalValue = value.genericKey;
      this._headerValueMatch.internalValue = value.headerValueMatch;
      this._metadata.internalValue = value.metadata;
      this._remoteAddress = value.remoteAddress;
      this._requestHeaders.internalValue = value.requestHeaders;
      this._sourceCluster = value.sourceCluster;
    }
  }

  // destination_cluster - computed: false, optional: true, required: false
  private _destinationCluster?: { [key: string]: string }; 
  public get destinationCluster() {
    return this.getStringMapAttribute('destination_cluster');
  }
  public set destinationCluster(value: { [key: string]: string }) {
    this._destinationCluster = value;
  }
  public resetDestinationCluster() {
    this._destinationCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationClusterInput() {
    return this._destinationCluster;
  }

  // generic_key - computed: false, optional: true, required: false
  private _genericKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKeyOutputReference(this, "generic_key");
  public get genericKey() {
    return this._genericKey;
  }
  public putGenericKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsGenericKey) {
    this._genericKey.internalValue = value;
  }
  public resetGenericKey() {
    this._genericKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get genericKeyInput() {
    return this._genericKey.internalValue;
  }

  // header_value_match - computed: false, optional: true, required: false
  private _headerValueMatch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatchOutputReference(this, "header_value_match");
  public get headerValueMatch() {
    return this._headerValueMatch;
  }
  public putHeaderValueMatch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsHeaderValueMatch) {
    this._headerValueMatch.internalValue = value;
  }
  public resetHeaderValueMatch() {
    this._headerValueMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValueMatchInput() {
    return this._headerValueMatch.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // remote_address - computed: false, optional: true, required: false
  private _remoteAddress?: { [key: string]: string }; 
  public get remoteAddress() {
    return this.getStringMapAttribute('remote_address');
  }
  public set remoteAddress(value: { [key: string]: string }) {
    this._remoteAddress = value;
  }
  public resetRemoteAddress() {
    this._remoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteAddressInput() {
    return this._remoteAddress;
  }

  // request_headers - computed: false, optional: true, required: false
  private _requestHeaders = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeadersOutputReference(this, "request_headers");
  public get requestHeaders() {
    return this._requestHeaders;
  }
  public putRequestHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsRequestHeaders) {
    this._requestHeaders.internalValue = value;
  }
  public resetRequestHeaders() {
    this._requestHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersInput() {
    return this._requestHeaders.internalValue;
  }

  // source_cluster - computed: false, optional: true, required: false
  private _sourceCluster?: { [key: string]: string }; 
  public get sourceCluster() {
    return this.getStringMapAttribute('source_cluster');
  }
  public set sourceCluster(value: { [key: string]: string }) {
    this._sourceCluster = value;
  }
  public resetSourceCluster() {
    this._sourceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceClusterInput() {
    return this._sourceCluster;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#actions DataK8SGatewaySoloIoRouteTableV1Manifest#actions}
  */
  readonly actions?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#limit DataK8SGatewaySoloIoRouteTableV1Manifest#limit}
  */
  readonly limit?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#set_actions DataK8SGatewaySoloIoRouteTableV1Manifest#set_actions}
  */
  readonly setActions?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsToTerraform, false)(struct!.actions),
    limit: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitToTerraform(struct!.limit),
    set_actions: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsToTerraform, false)(struct!.setActions),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsToHclTerraform, false)(struct!.actions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsList",
    },
    limit: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitToHclTerraform(struct!.limit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit",
    },
    set_actions: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsToHclTerraform, false)(struct!.setActions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._actions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.actions = this._actions?.internalValue;
    }
    if (this._limit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit?.internalValue;
    }
    if (this._setActions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.setActions = this._setActions?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._actions.internalValue = undefined;
      this._limit.internalValue = undefined;
      this._setActions.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._actions.internalValue = value.actions;
      this._limit.internalValue = value.limit;
      this._setActions.internalValue = value.setActions;
    }
  }

  // actions - computed: false, optional: true, required: false
  private _actions = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActionsList(this, "actions", false);
  public get actions() {
    return this._actions;
  }
  public putActions(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsActions[] | cdktf.IResolvable) {
    this._actions.internalValue = value;
  }
  public resetActions() {
    this._actions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get actionsInput() {
    return this._actions.internalValue;
  }

  // limit - computed: false, optional: true, required: false
  private _limit = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimitOutputReference(this, "limit");
  public get limit() {
    return this._limit;
  }
  public putLimit(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsLimit) {
    this._limit.internalValue = value;
  }
  public resetLimit() {
    this._limit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit.internalValue;
  }

  // set_actions - computed: false, optional: true, required: false
  private _setActions = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActionsList(this, "set_actions", false);
  public get setActions() {
    return this._setActions;
  }
  public putSetActions(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsSetActions[] | cdktf.IResolvable) {
    this._setActions.internalValue = value;
  }
  public resetSetActions() {
    this._setActions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setActionsInput() {
    return this._setActions.internalValue;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#include_vh_rate_limits DataK8SGatewaySoloIoRouteTableV1Manifest#include_vh_rate_limits}
  */
  readonly includeVhRateLimits?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#local_ratelimit DataK8SGatewaySoloIoRouteTableV1Manifest#local_ratelimit}
  */
  readonly localRatelimit?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#rate_limits DataK8SGatewaySoloIoRouteTableV1Manifest#rate_limits}
  */
  readonly rateLimits?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    include_vh_rate_limits: cdktf.booleanToTerraform(struct!.includeVhRateLimits),
    local_ratelimit: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimitToTerraform(struct!.localRatelimit),
    rate_limits: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsToTerraform, false)(struct!.rateLimits),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    include_vh_rate_limits: {
      value: cdktf.booleanToHclTerraform(struct!.includeVhRateLimits),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    local_ratelimit: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimitToHclTerraform(struct!.localRatelimit),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit",
    },
    rate_limits: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsToHclTerraform, false)(struct!.rateLimits),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._includeVhRateLimits !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeVhRateLimits = this._includeVhRateLimits;
    }
    if (this._localRatelimit?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.localRatelimit = this._localRatelimit?.internalValue;
    }
    if (this._rateLimits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rateLimits = this._rateLimits?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._includeVhRateLimits = undefined;
      this._localRatelimit.internalValue = undefined;
      this._rateLimits.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._includeVhRateLimits = value.includeVhRateLimits;
      this._localRatelimit.internalValue = value.localRatelimit;
      this._rateLimits.internalValue = value.rateLimits;
    }
  }

  // include_vh_rate_limits - computed: false, optional: true, required: false
  private _includeVhRateLimits?: boolean | cdktf.IResolvable; 
  public get includeVhRateLimits() {
    return this.getBooleanAttribute('include_vh_rate_limits');
  }
  public set includeVhRateLimits(value: boolean | cdktf.IResolvable) {
    this._includeVhRateLimits = value;
  }
  public resetIncludeVhRateLimits() {
    this._includeVhRateLimits = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeVhRateLimitsInput() {
    return this._includeVhRateLimits;
  }

  // local_ratelimit - computed: false, optional: true, required: false
  private _localRatelimit = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimitOutputReference(this, "local_ratelimit");
  public get localRatelimit() {
    return this._localRatelimit;
  }
  public putLocalRatelimit(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitLocalRatelimit) {
    this._localRatelimit.internalValue = value;
  }
  public resetLocalRatelimit() {
    this._localRatelimit.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localRatelimitInput() {
    return this._localRatelimit.internalValue;
  }

  // rate_limits - computed: false, optional: true, required: false
  private _rateLimits = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimitsList(this, "rate_limits", false);
  public get rateLimits() {
    return this._rateLimits;
  }
  public putRateLimits(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitRateLimits[] | cdktf.IResolvable) {
    this._rateLimits.internalValue = value;
  }
  public resetRateLimits() {
    this._rateLimits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rateLimitsInput() {
    return this._rateLimits.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#requests_per_unit DataK8SGatewaySoloIoRouteTableV1Manifest#requests_per_unit}
  */
  readonly requestsPerUnit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#unit DataK8SGatewaySoloIoRouteTableV1Manifest#unit}
  */
  readonly unit?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimitsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    requests_per_unit: cdktf.numberToTerraform(struct!.requestsPerUnit),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimitsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    requests_per_unit: {
      value: cdktf.numberToHclTerraform(struct!.requestsPerUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestsPerUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestsPerUnit = this._requestsPerUnit;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestsPerUnit = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestsPerUnit = value.requestsPerUnit;
      this._unit = value.unit;
    }
  }

  // requests_per_unit - computed: false, optional: true, required: false
  private _requestsPerUnit?: number; 
  public get requestsPerUnit() {
    return this.getNumberAttribute('requests_per_unit');
  }
  public set requestsPerUnit(value: number) {
    this._requestsPerUnit = value;
  }
  public resetRequestsPerUnit() {
    this._requestsPerUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsPerUnitInput() {
    return this._requestsPerUnit;
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#requests_per_unit DataK8SGatewaySoloIoRouteTableV1Manifest#requests_per_unit}
  */
  readonly requestsPerUnit?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#unit DataK8SGatewaySoloIoRouteTableV1Manifest#unit}
  */
  readonly unit?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimitsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    requests_per_unit: cdktf.numberToTerraform(struct!.requestsPerUnit),
    unit: cdktf.stringToTerraform(struct!.unit),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimitsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    requests_per_unit: {
      value: cdktf.numberToHclTerraform(struct!.requestsPerUnit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    unit: {
      value: cdktf.stringToHclTerraform(struct!.unit),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimitsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._requestsPerUnit !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestsPerUnit = this._requestsPerUnit;
    }
    if (this._unit !== undefined) {
      hasAnyValues = true;
      internalValueResult.unit = this._unit;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._requestsPerUnit = undefined;
      this._unit = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._requestsPerUnit = value.requestsPerUnit;
      this._unit = value.unit;
    }
  }

  // requests_per_unit - computed: false, optional: true, required: false
  private _requestsPerUnit?: number; 
  public get requestsPerUnit() {
    return this.getNumberAttribute('requests_per_unit');
  }
  public set requestsPerUnit(value: number) {
    this._requestsPerUnit = value;
  }
  public resetRequestsPerUnit() {
    this._requestsPerUnit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestsPerUnitInput() {
    return this._requestsPerUnit;
  }

  // unit - computed: false, optional: true, required: false
  private _unit?: string; 
  public get unit() {
    return this.getStringAttribute('unit');
  }
  public set unit(value: string) {
    this._unit = value;
  }
  public resetUnit() {
    this._unit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get unitInput() {
    return this._unit;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#anonymous_limits DataK8SGatewaySoloIoRouteTableV1Manifest#anonymous_limits}
  */
  readonly anonymousLimits?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#authorized_limits DataK8SGatewaySoloIoRouteTableV1Manifest#authorized_limits}
  */
  readonly authorizedLimits?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    anonymous_limits: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimitsToTerraform(struct!.anonymousLimits),
    authorized_limits: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimitsToTerraform(struct!.authorizedLimits),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    anonymous_limits: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimitsToHclTerraform(struct!.anonymousLimits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits",
    },
    authorized_limits: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimitsToHclTerraform(struct!.authorizedLimits),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._anonymousLimits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.anonymousLimits = this._anonymousLimits?.internalValue;
    }
    if (this._authorizedLimits?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authorizedLimits = this._authorizedLimits?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._anonymousLimits.internalValue = undefined;
      this._authorizedLimits.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._anonymousLimits.internalValue = value.anonymousLimits;
      this._authorizedLimits.internalValue = value.authorizedLimits;
    }
  }

  // anonymous_limits - computed: false, optional: true, required: false
  private _anonymousLimits = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimitsOutputReference(this, "anonymous_limits");
  public get anonymousLimits() {
    return this._anonymousLimits;
  }
  public putAnonymousLimits(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAnonymousLimits) {
    this._anonymousLimits.internalValue = value;
  }
  public resetAnonymousLimits() {
    this._anonymousLimits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get anonymousLimitsInput() {
    return this._anonymousLimits.internalValue;
  }

  // authorized_limits - computed: false, optional: true, required: false
  private _authorizedLimits = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimitsOutputReference(this, "authorized_limits");
  public get authorizedLimits() {
    return this._authorizedLimits;
  }
  public putAuthorizedLimits(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitBasicAuthorizedLimits) {
    this._authorizedLimits.internalValue = value;
  }
  public resetAuthorizedLimits() {
    this._authorizedLimits.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authorizedLimitsInput() {
    return this._authorizedLimits.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimit {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#fill_interval DataK8SGatewaySoloIoRouteTableV1Manifest#fill_interval}
  */
  readonly fillInterval?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#max_tokens DataK8SGatewaySoloIoRouteTableV1Manifest#max_tokens}
  */
  readonly maxTokens?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#tokens_per_fill DataK8SGatewaySoloIoRouteTableV1Manifest#tokens_per_fill}
  */
  readonly tokensPerFill?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimitToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fill_interval: cdktf.stringToTerraform(struct!.fillInterval),
    max_tokens: cdktf.numberToTerraform(struct!.maxTokens),
    tokens_per_fill: cdktf.numberToTerraform(struct!.tokensPerFill),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimitToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fill_interval: {
      value: cdktf.stringToHclTerraform(struct!.fillInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_tokens: {
      value: cdktf.numberToHclTerraform(struct!.maxTokens),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tokens_per_fill: {
      value: cdktf.numberToHclTerraform(struct!.tokensPerFill),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimitOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fillInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.fillInterval = this._fillInterval;
    }
    if (this._maxTokens !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxTokens = this._maxTokens;
    }
    if (this._tokensPerFill !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokensPerFill = this._tokensPerFill;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyLocalRatelimit | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fillInterval = undefined;
      this._maxTokens = undefined;
      this._tokensPerFill = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fillInterval = value.fillInterval;
      this._maxTokens = value.maxTokens;
      this._tokensPerFill = value.tokensPerFill;
    }
  }

  // fill_interval - computed: false, optional: true, required: false
  private _fillInterval?: string; 
  public get fillInterval() {
    return this.getStringAttribute('fill_interval');
  }
  public set fillInterval(value: string) {
    this._fillInterval = value;
  }
  public resetFillInterval() {
    this._fillInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fillIntervalInput() {
    return this._fillInterval;
  }

  // max_tokens - computed: false, optional: true, required: false
  private _maxTokens?: number; 
  public get maxTokens() {
    return this.getNumberAttribute('max_tokens');
  }
  public set maxTokens(value: number) {
    this._maxTokens = value;
  }
  public resetMaxTokens() {
    this._maxTokens = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxTokensInput() {
    return this._maxTokens;
  }

  // tokens_per_fill - computed: false, optional: true, required: false
  private _tokensPerFill?: number; 
  public get tokensPerFill() {
    return this.getNumberAttribute('tokens_per_fill');
  }
  public set tokensPerFill(value: number) {
    this._tokensPerFill = value;
  }
  public resetTokensPerFill() {
    this._tokensPerFill = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokensPerFillInput() {
    return this._tokensPerFill;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#end DataK8SGatewaySoloIoRouteTableV1Manifest#end}
  */
  readonly end?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#start DataK8SGatewaySoloIoRouteTableV1Manifest#start}
  */
  readonly start?: number;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    end: cdktf.numberToTerraform(struct!.end),
    start: cdktf.numberToTerraform(struct!.start),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    end: {
      value: cdktf.numberToHclTerraform(struct!.end),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    start: {
      value: cdktf.numberToHclTerraform(struct!.start),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._end !== undefined) {
      hasAnyValues = true;
      internalValueResult.end = this._end;
    }
    if (this._start !== undefined) {
      hasAnyValues = true;
      internalValueResult.start = this._start;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._end = undefined;
      this._start = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._end = value.end;
      this._start = value.start;
    }
  }

  // end - computed: false, optional: true, required: false
  private _end?: number; 
  public get end() {
    return this.getNumberAttribute('end');
  }
  public set end(value: number) {
    this._end = value;
  }
  public resetEnd() {
    this._end = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endInput() {
    return this._end;
  }

  // start - computed: false, optional: true, required: false
  private _start?: number; 
  public get start() {
    return this.getNumberAttribute('start');
  }
  public set start(value: number) {
    this._start = value;
  }
  public resetStart() {
    this._start = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startInput() {
    return this._start;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#exact_match DataK8SGatewaySoloIoRouteTableV1Manifest#exact_match}
  */
  readonly exactMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#invert_match DataK8SGatewaySoloIoRouteTableV1Manifest#invert_match}
  */
  readonly invertMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#name DataK8SGatewaySoloIoRouteTableV1Manifest#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#prefix_match DataK8SGatewaySoloIoRouteTableV1Manifest#prefix_match}
  */
  readonly prefixMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#present_match DataK8SGatewaySoloIoRouteTableV1Manifest#present_match}
  */
  readonly presentMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#range_match DataK8SGatewaySoloIoRouteTableV1Manifest#range_match}
  */
  readonly rangeMatch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#regex_match DataK8SGatewaySoloIoRouteTableV1Manifest#regex_match}
  */
  readonly regexMatch?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#suffix_match DataK8SGatewaySoloIoRouteTableV1Manifest#suffix_match}
  */
  readonly suffixMatch?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exact_match: cdktf.stringToTerraform(struct!.exactMatch),
    invert_match: cdktf.booleanToTerraform(struct!.invertMatch),
    name: cdktf.stringToTerraform(struct!.name),
    prefix_match: cdktf.stringToTerraform(struct!.prefixMatch),
    present_match: cdktf.booleanToTerraform(struct!.presentMatch),
    range_match: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToTerraform(struct!.rangeMatch),
    regex_match: cdktf.stringToTerraform(struct!.regexMatch),
    suffix_match: cdktf.stringToTerraform(struct!.suffixMatch),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exact_match: {
      value: cdktf.stringToHclTerraform(struct!.exactMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    invert_match: {
      value: cdktf.booleanToHclTerraform(struct!.invertMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix_match: {
      value: cdktf.stringToHclTerraform(struct!.prefixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    present_match: {
      value: cdktf.booleanToHclTerraform(struct!.presentMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    range_match: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchToHclTerraform(struct!.rangeMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch",
    },
    regex_match: {
      value: cdktf.stringToHclTerraform(struct!.regexMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    suffix_match: {
      value: cdktf.stringToHclTerraform(struct!.suffixMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exactMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.exactMatch = this._exactMatch;
    }
    if (this._invertMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.invertMatch = this._invertMatch;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._prefixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefixMatch = this._prefixMatch;
    }
    if (this._presentMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.presentMatch = this._presentMatch;
    }
    if (this._rangeMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rangeMatch = this._rangeMatch?.internalValue;
    }
    if (this._regexMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.regexMatch = this._regexMatch;
    }
    if (this._suffixMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.suffixMatch = this._suffixMatch;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exactMatch = undefined;
      this._invertMatch = undefined;
      this._name = undefined;
      this._prefixMatch = undefined;
      this._presentMatch = undefined;
      this._rangeMatch.internalValue = undefined;
      this._regexMatch = undefined;
      this._suffixMatch = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exactMatch = value.exactMatch;
      this._invertMatch = value.invertMatch;
      this._name = value.name;
      this._prefixMatch = value.prefixMatch;
      this._presentMatch = value.presentMatch;
      this._rangeMatch.internalValue = value.rangeMatch;
      this._regexMatch = value.regexMatch;
      this._suffixMatch = value.suffixMatch;
    }
  }

  // exact_match - computed: false, optional: true, required: false
  private _exactMatch?: string; 
  public get exactMatch() {
    return this.getStringAttribute('exact_match');
  }
  public set exactMatch(value: string) {
    this._exactMatch = value;
  }
  public resetExactMatch() {
    this._exactMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get exactMatchInput() {
    return this._exactMatch;
  }

  // invert_match - computed: false, optional: true, required: false
  private _invertMatch?: boolean | cdktf.IResolvable; 
  public get invertMatch() {
    return this.getBooleanAttribute('invert_match');
  }
  public set invertMatch(value: boolean | cdktf.IResolvable) {
    this._invertMatch = value;
  }
  public resetInvertMatch() {
    this._invertMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get invertMatchInput() {
    return this._invertMatch;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // prefix_match - computed: false, optional: true, required: false
  private _prefixMatch?: string; 
  public get prefixMatch() {
    return this.getStringAttribute('prefix_match');
  }
  public set prefixMatch(value: string) {
    this._prefixMatch = value;
  }
  public resetPrefixMatch() {
    this._prefixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixMatchInput() {
    return this._prefixMatch;
  }

  // present_match - computed: false, optional: true, required: false
  private _presentMatch?: boolean | cdktf.IResolvable; 
  public get presentMatch() {
    return this.getBooleanAttribute('present_match');
  }
  public set presentMatch(value: boolean | cdktf.IResolvable) {
    this._presentMatch = value;
  }
  public resetPresentMatch() {
    this._presentMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get presentMatchInput() {
    return this._presentMatch;
  }

  // range_match - computed: false, optional: true, required: false
  private _rangeMatch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatchOutputReference(this, "range_match");
  public get rangeMatch() {
    return this._rangeMatch;
  }
  public putRangeMatch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersRangeMatch) {
    this._rangeMatch.internalValue = value;
  }
  public resetRangeMatch() {
    this._rangeMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rangeMatchInput() {
    return this._rangeMatch.internalValue;
  }

  // regex_match - computed: false, optional: true, required: false
  private _regexMatch?: string; 
  public get regexMatch() {
    return this.getStringAttribute('regex_match');
  }
  public set regexMatch(value: string) {
    this._regexMatch = value;
  }
  public resetRegexMatch() {
    this._regexMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regexMatchInput() {
    return this._regexMatch;
  }

  // suffix_match - computed: false, optional: true, required: false
  private _suffixMatch?: string; 
  public get suffixMatch() {
    return this.getStringAttribute('suffix_match');
  }
  public set suffixMatch(value: string) {
    this._suffixMatch = value;
  }
  public resetSuffixMatch() {
    this._suffixMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get suffixMatchInput() {
    return this._suffixMatch;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_value DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_value}
  */
  readonly descriptorValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#expect_match DataK8SGatewaySoloIoRouteTableV1Manifest#expect_match}
  */
  readonly expectMatch?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#headers DataK8SGatewaySoloIoRouteTableV1Manifest#headers}
  */
  readonly headers?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_value: cdktf.stringToTerraform(struct!.descriptorValue),
    expect_match: cdktf.booleanToTerraform(struct!.expectMatch),
    headers: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToTerraform, false)(struct!.headers),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_value: {
      value: cdktf.stringToHclTerraform(struct!.descriptorValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    expect_match: {
      value: cdktf.booleanToHclTerraform(struct!.expectMatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersToHclTerraform, false)(struct!.headers),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorValue = this._descriptorValue;
    }
    if (this._expectMatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.expectMatch = this._expectMatch;
    }
    if (this._headers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorValue = undefined;
      this._expectMatch = undefined;
      this._headers.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorValue = value.descriptorValue;
      this._expectMatch = value.expectMatch;
      this._headers.internalValue = value.headers;
    }
  }

  // descriptor_value - computed: false, optional: true, required: false
  private _descriptorValue?: string; 
  public get descriptorValue() {
    return this.getStringAttribute('descriptor_value');
  }
  public set descriptorValue(value: string) {
    this._descriptorValue = value;
  }
  public resetDescriptorValue() {
    this._descriptorValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorValueInput() {
    return this._descriptorValue;
  }

  // expect_match - computed: false, optional: true, required: false
  private _expectMatch?: boolean | cdktf.IResolvable; 
  public get expectMatch() {
    return this.getBooleanAttribute('expect_match');
  }
  public set expectMatch(value: boolean | cdktf.IResolvable) {
    this._expectMatch = value;
  }
  public resetExpectMatch() {
    this._expectMatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expectMatchInput() {
    return this._expectMatch;
  }

  // headers - computed: false, optional: true, required: false
  private _headers = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeadersList(this, "headers", false);
  public get headers() {
    return this._headers;
  }
  public putHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchHeaders[] | cdktf.IResolvable) {
    this._headers.internalValue = value;
  }
  public resetHeaders() {
    this._headers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#path DataK8SGatewaySoloIoRouteTableV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#default_value DataK8SGatewaySoloIoRouteTableV1Manifest#default_value}
  */
  readonly defaultValue?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteTableV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#source DataK8SGatewaySoloIoRouteTableV1Manifest#source}
  */
  readonly source?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_value: cdktf.stringToTerraform(struct!.defaultValue),
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    metadata_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToTerraform(struct!.metadataKey),
    source: cdktf.stringToTerraform(struct!.source),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_value: {
      value: cdktf.stringToHclTerraform(struct!.defaultValue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValue = this._defaultValue;
    }
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultValue = undefined;
      this._descriptorKey = undefined;
      this._metadataKey.internalValue = undefined;
      this._source = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultValue = value.defaultValue;
      this._descriptorKey = value.descriptorKey;
      this._metadataKey.internalValue = value.metadataKey;
      this._source = value.source;
    }
  }

  // default_value - computed: false, optional: true, required: false
  private _defaultValue?: string; 
  public get defaultValue() {
    return this.getStringAttribute('default_value');
  }
  public set defaultValue(value: string) {
    this._defaultValue = value;
  }
  public resetDefaultValue() {
    this._defaultValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueInput() {
    return this._defaultValue;
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#descriptor_key DataK8SGatewaySoloIoRouteTableV1Manifest#descriptor_key}
  */
  readonly descriptorKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header_name DataK8SGatewaySoloIoRouteTableV1Manifest#header_name}
  */
  readonly headerName?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    descriptor_key: cdktf.stringToTerraform(struct!.descriptorKey),
    header_name: cdktf.stringToTerraform(struct!.headerName),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    descriptor_key: {
      value: cdktf.stringToHclTerraform(struct!.descriptorKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_name: {
      value: cdktf.stringToHclTerraform(struct!.headerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._descriptorKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.descriptorKey = this._descriptorKey;
    }
    if (this._headerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerName = this._headerName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._descriptorKey = undefined;
      this._headerName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._descriptorKey = value.descriptorKey;
      this._headerName = value.headerName;
    }
  }

  // descriptor_key - computed: false, optional: true, required: false
  private _descriptorKey?: string; 
  public get descriptorKey() {
    return this.getStringAttribute('descriptor_key');
  }
  public set descriptorKey(value: string) {
    this._descriptorKey = value;
  }
  public resetDescriptorKey() {
    this._descriptorKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptorKeyInput() {
    return this._descriptorKey;
  }

  // header_name - computed: false, optional: true, required: false
  private _headerName?: string; 
  public get headerName() {
    return this.getStringAttribute('header_name');
  }
  public set headerName(value: string) {
    this._headerName = value;
  }
  public resetHeaderName() {
    this._headerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerNameInput() {
    return this._headerName;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActions {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#destination_cluster DataK8SGatewaySoloIoRouteTableV1Manifest#destination_cluster}
  */
  readonly destinationCluster?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#generic_key DataK8SGatewaySoloIoRouteTableV1Manifest#generic_key}
  */
  readonly genericKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#header_value_match DataK8SGatewaySoloIoRouteTableV1Manifest#header_value_match}
  */
  readonly headerValueMatch?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata DataK8SGatewaySoloIoRouteTableV1Manifest#metadata}
  */
  readonly metadata?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#remote_address DataK8SGatewaySoloIoRouteTableV1Manifest#remote_address}
  */
  readonly remoteAddress?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#request_headers DataK8SGatewaySoloIoRouteTableV1Manifest#request_headers}
  */
  readonly requestHeaders?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#source_cluster DataK8SGatewaySoloIoRouteTableV1Manifest#source_cluster}
  */
  readonly sourceCluster?: { [key: string]: string };
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    destination_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.destinationCluster),
    generic_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKeyToTerraform(struct!.genericKey),
    header_value_match: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToTerraform(struct!.headerValueMatch),
    metadata: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataToTerraform(struct!.metadata),
    remote_address: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.remoteAddress),
    request_headers: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToTerraform(struct!.requestHeaders),
    source_cluster: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.sourceCluster),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    destination_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.destinationCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    generic_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKeyToHclTerraform(struct!.genericKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey",
    },
    header_value_match: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchToHclTerraform(struct!.headerValueMatch),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch",
    },
    metadata: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata",
    },
    remote_address: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.remoteAddress),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    request_headers: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeadersToHclTerraform(struct!.requestHeaders),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders",
    },
    source_cluster: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.sourceCluster),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._destinationCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.destinationCluster = this._destinationCluster;
    }
    if (this._genericKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.genericKey = this._genericKey?.internalValue;
    }
    if (this._headerValueMatch?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerValueMatch = this._headerValueMatch?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._remoteAddress !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteAddress = this._remoteAddress;
    }
    if (this._requestHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestHeaders = this._requestHeaders?.internalValue;
    }
    if (this._sourceCluster !== undefined) {
      hasAnyValues = true;
      internalValueResult.sourceCluster = this._sourceCluster;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._destinationCluster = undefined;
      this._genericKey.internalValue = undefined;
      this._headerValueMatch.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._remoteAddress = undefined;
      this._requestHeaders.internalValue = undefined;
      this._sourceCluster = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._destinationCluster = value.destinationCluster;
      this._genericKey.internalValue = value.genericKey;
      this._headerValueMatch.internalValue = value.headerValueMatch;
      this._metadata.internalValue = value.metadata;
      this._remoteAddress = value.remoteAddress;
      this._requestHeaders.internalValue = value.requestHeaders;
      this._sourceCluster = value.sourceCluster;
    }
  }

  // destination_cluster - computed: false, optional: true, required: false
  private _destinationCluster?: { [key: string]: string }; 
  public get destinationCluster() {
    return this.getStringMapAttribute('destination_cluster');
  }
  public set destinationCluster(value: { [key: string]: string }) {
    this._destinationCluster = value;
  }
  public resetDestinationCluster() {
    this._destinationCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destinationClusterInput() {
    return this._destinationCluster;
  }

  // generic_key - computed: false, optional: true, required: false
  private _genericKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKeyOutputReference(this, "generic_key");
  public get genericKey() {
    return this._genericKey;
  }
  public putGenericKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsGenericKey) {
    this._genericKey.internalValue = value;
  }
  public resetGenericKey() {
    this._genericKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get genericKeyInput() {
    return this._genericKey.internalValue;
  }

  // header_value_match - computed: false, optional: true, required: false
  private _headerValueMatch = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatchOutputReference(this, "header_value_match");
  public get headerValueMatch() {
    return this._headerValueMatch;
  }
  public putHeaderValueMatch(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsHeaderValueMatch) {
    this._headerValueMatch.internalValue = value;
  }
  public resetHeaderValueMatch() {
    this._headerValueMatch.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerValueMatchInput() {
    return this._headerValueMatch.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // remote_address - computed: false, optional: true, required: false
  private _remoteAddress?: { [key: string]: string }; 
  public get remoteAddress() {
    return this.getStringMapAttribute('remote_address');
  }
  public set remoteAddress(value: { [key: string]: string }) {
    this._remoteAddress = value;
  }
  public resetRemoteAddress() {
    this._remoteAddress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteAddressInput() {
    return this._remoteAddress;
  }

  // request_headers - computed: false, optional: true, required: false
  private _requestHeaders = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeadersOutputReference(this, "request_headers");
  public get requestHeaders() {
    return this._requestHeaders;
  }
  public putRequestHeaders(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsRequestHeaders) {
    this._requestHeaders.internalValue = value;
  }
  public resetRequestHeaders() {
    this._requestHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestHeadersInput() {
    return this._requestHeaders.internalValue;
  }

  // source_cluster - computed: false, optional: true, required: false
  private _sourceCluster?: { [key: string]: string }; 
  public get sourceCluster() {
    return this.getStringMapAttribute('source_cluster');
  }
  public set sourceCluster(value: { [key: string]: string }) {
    this._sourceCluster = value;
  }
  public resetSourceCluster() {
    this._sourceCluster = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceClusterInput() {
    return this._sourceCluster;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsActionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathList extends cdktf.ComplexList {
  public internalValue? : DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference {
    return new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#key DataK8SGatewaySoloIoRouteTableV1Manifest#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#path DataK8SGatewaySoloIoRouteTableV1Manifest#path}
  */
  readonly path?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    path: cdktf.listMapper(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToTerraform, false)(struct!.path),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.listMapperHcl(dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathToHclTerraform, false)(struct!.path),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._path?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._path.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._path.internalValue = value.path;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // path - computed: false, optional: true, required: false
  private _path = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPathList(this, "path", false);
  public get path() {
    return this._path;
  }
  public putPath(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyPath[] | cdktf.IResolvable) {
    this._path.internalValue = value;
  }
  public resetPath() {
    this._path.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path.internalValue;
  }
}
export interface DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.1/docs/data-sources/gateway_solo_io_route_table_v1_manifest#metadata_key DataK8SGatewaySoloIoRouteTableV1Manifest#metadata_key}
  */
  readonly metadataKey?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey;
}

export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataToTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata_key: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToTerraform(struct!.metadataKey),
  }
}


export function dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataToHclTerraform(struct?: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata_key: {
      value: dataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyToHclTerraform(struct!.metadataKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadataKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadataKey = this._metadataKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadataKey.internalValue = value.metadataKey;
    }
  }

  // metadata_key - computed: false, optional: true, required: false
  private _metadataKey = new DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKeyOutputReference(this, "metadata_key");
  public get metadataKey() {
    return this._metadataKey;
  }
  public putMetadataKey(value: DataK8SGatewaySoloIoRouteTableV1ManifestSpecRoutesOptionsRatelimitEarlyRateLimitsLimitDynamicMetadataMetadataKey) {
    this._metadataKey.internalValue = value;
  }
  public resetMetadataKey() {
    this._metadataKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataKeyInput() {
    return this._metadataKey.internalValue;
  }
}
