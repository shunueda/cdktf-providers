import * as cdktf from 'cdktf';
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadata {
  /**
  * Keys and values that can be used by external tooling to store and retrieve arbitrary metadata about this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#annotations DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#annotations}
  */
  readonly annotations?: { [key: string]: string };
  /**
  * Keys and values that can be used to organize and categorize objects. See https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#labels DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#labels}
  */
  readonly labels?: { [key: string]: string };
  /**
  * Unique identifier for this object. See https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespaces provides a mechanism for isolating groups of resources within a single cluster. See https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/ for more details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadataToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    annotations: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.annotations),
    labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.labels),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadataToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    annotations: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.annotations),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.labels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._annotations !== undefined) {
      hasAnyValues = true;
      internalValueResult.annotations = this._annotations;
    }
    if (this._labels !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._annotations = undefined;
      this._labels = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._annotations = value.annotations;
      this._labels = value.labels;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // annotations - computed: false, optional: true, required: false
  private _annotations?: { [key: string]: string }; 
  public get annotations() {
    return this.getStringMapAttribute('annotations');
  }
  public set annotations(value: { [key: string]: string }) {
    this._annotations = value;
  }
  public resetAnnotations() {
    this._annotations = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get annotationsInput() {
    return this._annotations;
  }

  // labels - computed: false, optional: true, required: false
  private _labels?: { [key: string]: string }; 
  public get labels() {
    return this.getStringMapAttribute('labels');
  }
  public set labels(value: { [key: string]: string }) {
    this._labels = value;
  }
  public resetLabels() {
    this._labels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: false, required: true
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#operator DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#values DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsOutputReference {
    return new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#match_expressions DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#match_labels DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditions {
  /**
  * Choose namespaces by using regex matching
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace_regexes DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace_regexes}
  */
  readonly namespaceRegexes?: string[];
  /**
  * Choose namespace using a labelSelector
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace_selector DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace_selector}
  */
  readonly namespaceSelector?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector;
  /**
  * Choose namespaces by name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespaces DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespaces}
  */
  readonly namespaces?: string[];
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    namespace_regexes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaceRegexes),
    namespace_selector: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToTerraform(struct!.namespaceSelector),
    namespaces: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.namespaces),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    namespace_regexes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaceRegexes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    namespace_selector: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorToHclTerraform(struct!.namespaceSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector",
    },
    namespaces: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.namespaces),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._namespaceRegexes !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceRegexes = this._namespaceRegexes;
    }
    if (this._namespaceSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaceSelector = this._namespaceSelector?.internalValue;
    }
    if (this._namespaces !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespaces = this._namespaces;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._namespaceRegexes = undefined;
      this._namespaceSelector.internalValue = undefined;
      this._namespaces = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._namespaceRegexes = value.namespaceRegexes;
      this._namespaceSelector.internalValue = value.namespaceSelector;
      this._namespaces = value.namespaces;
    }
  }

  // namespace_regexes - computed: false, optional: true, required: false
  private _namespaceRegexes?: string[]; 
  public get namespaceRegexes() {
    return this.getListAttribute('namespace_regexes');
  }
  public set namespaceRegexes(value: string[]) {
    this._namespaceRegexes = value;
  }
  public resetNamespaceRegexes() {
    this._namespaceRegexes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceRegexesInput() {
    return this._namespaceRegexes;
  }

  // namespace_selector - computed: false, optional: true, required: false
  private _namespaceSelector = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelectorOutputReference(this, "namespace_selector");
  public get namespaceSelector() {
    return this._namespaceSelector;
  }
  public putNamespaceSelector(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsNamespaceSelector) {
    this._namespaceSelector.internalValue = value;
  }
  public resetNamespaceSelector() {
    this._namespaceSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceSelectorInput() {
    return this._namespaceSelector.internalValue;
  }

  // namespaces - computed: false, optional: true, required: false
  private _namespaces?: string[]; 
  public get namespaces() {
    return this.getListAttribute('namespaces');
  }
  public set namespaces(value: string[]) {
    this._namespaces = value;
  }
  public resetNamespaces() {
    this._namespaces = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespacesInput() {
    return this._namespaces;
  }
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsOutputReference {
    return new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecConditionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
  * the Akeyless Kubernetes auth-method access-id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_id}
  */
  readonly accessId: string;
  /**
  * Kubernetes-auth configuration name in Akeyless-Gateway
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#k8s_conf_name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#k8s_conf_name}
  */
  readonly k8SConfName: string;
  /**
  * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, 'token' is the default. If one is not specified, the one bound to the controller will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;
  /**
  * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_id: cdktf.stringToTerraform(struct!.accessId),
    k8s_conf_name: cdktf.stringToTerraform(struct!.k8SConfName),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToTerraform(struct!.secretRef),
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_id: {
      value: cdktf.stringToHclTerraform(struct!.accessId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    k8s_conf_name: {
      value: cdktf.stringToHclTerraform(struct!.k8SConfName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessId = this._accessId;
    }
    if (this._k8SConfName !== undefined) {
      hasAnyValues = true;
      internalValueResult.k8SConfName = this._k8SConfName;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessId = undefined;
      this._k8SConfName = undefined;
      this._secretRef.internalValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessId = value.accessId;
      this._k8SConfName = value.k8SConfName;
      this._secretRef.internalValue = value.secretRef;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // access_id - computed: false, optional: false, required: true
  private _accessId?: string; 
  public get accessId() {
    return this.getStringAttribute('access_id');
  }
  public set accessId(value: string) {
    this._accessId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessIdInput() {
    return this._accessId;
  }

  // k8s_conf_name - computed: false, optional: false, required: true
  private _k8SConfName?: string; 
  public get k8SConfName() {
    return this.getStringAttribute('k8s_conf_name');
  }
  public set k8SConfName(value: string) {
    this._k8SConfName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get k8SConfNameInput() {
    return this._k8SConfName;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef {
  /**
  * The SecretAccessID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_id}
  */
  readonly accessId?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_type}
  */
  readonly accessType?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_type_param DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_type_param}
  */
  readonly accessTypeParam?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_id: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToTerraform(struct!.accessId),
    access_type: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToTerraform(struct!.accessType),
    access_type_param: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToTerraform(struct!.accessTypeParam),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_id: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdToHclTerraform(struct!.accessId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId",
    },
    access_type: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeToHclTerraform(struct!.accessType),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType",
    },
    access_type_param: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamToHclTerraform(struct!.accessTypeParam),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessId = this._accessId?.internalValue;
    }
    if (this._accessType?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessType = this._accessType?.internalValue;
    }
    if (this._accessTypeParam?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessTypeParam = this._accessTypeParam?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessId.internalValue = undefined;
      this._accessType.internalValue = undefined;
      this._accessTypeParam.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessId.internalValue = value.accessId;
      this._accessType.internalValue = value.accessType;
      this._accessTypeParam.internalValue = value.accessTypeParam;
    }
  }

  // access_id - computed: false, optional: true, required: false
  private _accessId = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessIdOutputReference(this, "access_id");
  public get accessId() {
    return this._accessId;
  }
  public putAccessId(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessId) {
    this._accessId.internalValue = value;
  }
  public resetAccessId() {
    this._accessId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessIdInput() {
    return this._accessId.internalValue;
  }

  // access_type - computed: false, optional: true, required: false
  private _accessType = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeOutputReference(this, "access_type");
  public get accessType() {
    return this._accessType;
  }
  public putAccessType(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessType) {
    this._accessType.internalValue = value;
  }
  public resetAccessType() {
    this._accessType.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTypeInput() {
    return this._accessType.internalValue;
  }

  // access_type_param - computed: false, optional: true, required: false
  private _accessTypeParam = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParamOutputReference(this, "access_type_param");
  public get accessTypeParam() {
    return this._accessTypeParam;
  }
  public putAccessTypeParam(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam) {
    this._accessTypeParam.internalValue = value;
  }
  public resetAccessTypeParam() {
    this._accessTypeParam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTypeParamInput() {
    return this._accessTypeParam.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef {
  /**
  * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#kubernetes_auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#kubernetes_auth}
  */
  readonly kubernetesAuth?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth;
  /**
  * Reference to a Secret that contains the details to authenticate with Akeyless.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kubernetes_auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToTerraform(struct!.kubernetesAuth),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kubernetes_auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthToHclTerraform(struct!.kubernetesAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kubernetesAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesAuth = this._kubernetesAuth?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kubernetesAuth.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kubernetesAuth.internalValue = value.kubernetesAuth;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // kubernetes_auth - computed: false, optional: true, required: false
  private _kubernetesAuth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuthOutputReference(this, "kubernetes_auth");
  public get kubernetesAuth() {
    return this._kubernetesAuth;
  }
  public putKubernetesAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefKubernetesAuth) {
    this._kubernetesAuth.internalValue = value;
  }
  public resetKubernetesAuth() {
    this._kubernetesAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesAuthInput() {
    return this._kubernetesAuth.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeyless {
  /**
  * Akeyless GW API Url from which the secrets to be fetched from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#akeyless_gw_api_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#akeyless_gw_api_url}
  */
  readonly akeylessGwApiUrl: string;
  /**
  * Auth configures how the operator authenticates with Akeyless.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth_secret_ref}
  */
  readonly authSecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef;
  /**
  * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    akeyless_gw_api_url: cdktf.stringToTerraform(struct!.akeylessGwApiUrl),
    auth_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToTerraform(struct!.authSecretRef),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToTerraform(struct!.caProvider),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    akeyless_gw_api_url: {
      value: cdktf.stringToHclTerraform(struct!.akeylessGwApiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefToHclTerraform(struct!.authSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._akeylessGwApiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.akeylessGwApiUrl = this._akeylessGwApiUrl;
    }
    if (this._authSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authSecretRef = this._authSecretRef?.internalValue;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeyless | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._akeylessGwApiUrl = undefined;
      this._authSecretRef.internalValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._akeylessGwApiUrl = value.akeylessGwApiUrl;
      this._authSecretRef.internalValue = value.authSecretRef;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
    }
  }

  // akeyless_gw_api_url - computed: false, optional: false, required: true
  private _akeylessGwApiUrl?: string; 
  public get akeylessGwApiUrl() {
    return this.getStringAttribute('akeyless_gw_api_url');
  }
  public set akeylessGwApiUrl(value: string) {
    this._akeylessGwApiUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get akeylessGwApiUrlInput() {
    return this._akeylessGwApiUrl;
  }

  // auth_secret_ref - computed: false, optional: false, required: true
  private _authSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRefOutputReference(this, "auth_secret_ref");
  public get authSecretRef() {
    return this._authSecretRef;
  }
  public putAuthSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessAuthSecretRef) {
    this._authSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authSecretRefInput() {
    return this._authSecretRef.internalValue;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAkeylessCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#oidc_provider_arn DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#oidc_provider_arn}
  */
  readonly oidcProviderArn: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#oidc_token_file_path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#oidc_token_file_path}
  */
  readonly oidcTokenFilePath: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#role_arn DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#role_arn}
  */
  readonly roleArn: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#session_name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#session_name}
  */
  readonly sessionName: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    oidc_provider_arn: cdktf.stringToTerraform(struct!.oidcProviderArn),
    oidc_token_file_path: cdktf.stringToTerraform(struct!.oidcTokenFilePath),
    role_arn: cdktf.stringToTerraform(struct!.roleArn),
    session_name: cdktf.stringToTerraform(struct!.sessionName),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    oidc_provider_arn: {
      value: cdktf.stringToHclTerraform(struct!.oidcProviderArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oidc_token_file_path: {
      value: cdktf.stringToHclTerraform(struct!.oidcTokenFilePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_arn: {
      value: cdktf.stringToHclTerraform(struct!.roleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_name: {
      value: cdktf.stringToHclTerraform(struct!.sessionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._oidcProviderArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcProviderArn = this._oidcProviderArn;
    }
    if (this._oidcTokenFilePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.oidcTokenFilePath = this._oidcTokenFilePath;
    }
    if (this._roleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleArn = this._roleArn;
    }
    if (this._sessionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionName = this._sessionName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._oidcProviderArn = undefined;
      this._oidcTokenFilePath = undefined;
      this._roleArn = undefined;
      this._sessionName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._oidcProviderArn = value.oidcProviderArn;
      this._oidcTokenFilePath = value.oidcTokenFilePath;
      this._roleArn = value.roleArn;
      this._sessionName = value.sessionName;
    }
  }

  // oidc_provider_arn - computed: false, optional: false, required: true
  private _oidcProviderArn?: string; 
  public get oidcProviderArn() {
    return this.getStringAttribute('oidc_provider_arn');
  }
  public set oidcProviderArn(value: string) {
    this._oidcProviderArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcProviderArnInput() {
    return this._oidcProviderArn;
  }

  // oidc_token_file_path - computed: false, optional: false, required: true
  private _oidcTokenFilePath?: string; 
  public get oidcTokenFilePath() {
    return this.getStringAttribute('oidc_token_file_path');
  }
  public set oidcTokenFilePath(value: string) {
    this._oidcTokenFilePath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get oidcTokenFilePathInput() {
    return this._oidcTokenFilePath;
  }

  // role_arn - computed: false, optional: false, required: true
  private _roleArn?: string; 
  public get roleArn() {
    return this.getStringAttribute('role_arn');
  }
  public set roleArn(value: string) {
    this._roleArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get roleArnInput() {
    return this._roleArn;
  }

  // session_name - computed: false, optional: false, required: true
  private _sessionName?: string; 
  public get sessionName() {
    return this.getStringAttribute('session_name');
  }
  public set sessionName(value: string) {
    this._sessionName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionNameInput() {
    return this._sessionName;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef {
  /**
  * The AccessKeyID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_key_id_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_key_id_secret_ref}
  */
  readonly accessKeyIdSecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;
  /**
  * The AccessKeySecret is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_key_secret_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_key_secret_secret_ref}
  */
  readonly accessKeySecretSecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToTerraform(struct!.accessKeyIdSecretRef),
    access_key_secret_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToTerraform(struct!.accessKeySecretSecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct!.accessKeyIdSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef",
    },
    access_key_secret_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefToHclTerraform(struct!.accessKeySecretSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyIdSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyIdSecretRef = this._accessKeyIdSecretRef?.internalValue;
    }
    if (this._accessKeySecretSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeySecretSecretRef = this._accessKeySecretSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = undefined;
      this._accessKeySecretSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = value.accessKeyIdSecretRef;
      this._accessKeySecretSecretRef.internalValue = value.accessKeySecretSecretRef;
    }
  }

  // access_key_id_secret_ref - computed: false, optional: false, required: true
  private _accessKeyIdSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRefOutputReference(this, "access_key_id_secret_ref");
  public get accessKeyIdSecretRef() {
    return this._accessKeyIdSecretRef;
  }
  public putAccessKeyIdSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef) {
    this._accessKeyIdSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdSecretRefInput() {
    return this._accessKeyIdSecretRef.internalValue;
  }

  // access_key_secret_secret_ref - computed: false, optional: false, required: true
  private _accessKeySecretSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRefOutputReference(this, "access_key_secret_secret_ref");
  public get accessKeySecretSecretRef() {
    return this._accessKeySecretSecretRef;
  }
  public putAccessKeySecretSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef) {
    this._accessKeySecretSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeySecretSecretRefInput() {
    return this._accessKeySecretSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth {
  /**
  * Authenticate against Alibaba using RRSA.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#rrsa DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#rrsa}
  */
  readonly rrsa?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa;
  /**
  * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    rrsa: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToTerraform(struct!.rrsa),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    rrsa: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaToHclTerraform(struct!.rrsa),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._rrsa?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rrsa = this._rrsa?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._rrsa.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._rrsa.internalValue = value.rrsa;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // rrsa - computed: false, optional: true, required: false
  private _rrsa = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsaOutputReference(this, "rrsa");
  public get rrsa() {
    return this._rrsa;
  }
  public putRrsa(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthRrsa) {
    this._rrsa.internalValue = value;
  }
  public resetRrsa() {
    this._rrsa.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rrsaInput() {
    return this._rrsa.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibaba {
  /**
  * AlibabaAuth contains a secretRef for credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth;
  /**
  * Alibaba Region to be used for the provider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#region_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#region_id}
  */
  readonly regionId: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToTerraform(struct!.auth),
    region_id: cdktf.stringToTerraform(struct!.regionId),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth",
    },
    region_id: {
      value: cdktf.stringToHclTerraform(struct!.regionId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._regionId !== undefined) {
      hasAnyValues = true;
      internalValueResult.regionId = this._regionId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibaba | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._regionId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._regionId = value.regionId;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAlibabaAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // region_id - computed: false, optional: false, required: true
  private _regionId?: string; 
  public get regionId() {
    return this.getStringAttribute('region_id');
  }
  public set regionId(value: string) {
    this._regionId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionIdInput() {
    return this._regionId;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt {
  /**
  * A reference to a ServiceAccount resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef {
  /**
  * The AccessKeyID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_key_id_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_key_id_secret_ref}
  */
  readonly accessKeyIdSecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_access_key_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_access_key_secret_ref}
  */
  readonly secretAccessKeySecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;
  /**
  * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#session_token_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#session_token_secret_ref}
  */
  readonly sessionTokenSecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToTerraform(struct!.accessKeyIdSecretRef),
    secret_access_key_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToTerraform(struct!.secretAccessKeySecretRef),
    session_token_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToTerraform(struct!.sessionTokenSecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefToHclTerraform(struct!.accessKeyIdSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef",
    },
    secret_access_key_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct!.secretAccessKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef",
    },
    session_token_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefToHclTerraform(struct!.sessionTokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyIdSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyIdSecretRef = this._accessKeyIdSecretRef?.internalValue;
    }
    if (this._secretAccessKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKeySecretRef = this._secretAccessKeySecretRef?.internalValue;
    }
    if (this._sessionTokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTokenSecretRef = this._sessionTokenSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = undefined;
      this._secretAccessKeySecretRef.internalValue = undefined;
      this._sessionTokenSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = value.accessKeyIdSecretRef;
      this._secretAccessKeySecretRef.internalValue = value.secretAccessKeySecretRef;
      this._sessionTokenSecretRef.internalValue = value.sessionTokenSecretRef;
    }
  }

  // access_key_id_secret_ref - computed: false, optional: true, required: false
  private _accessKeyIdSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRefOutputReference(this, "access_key_id_secret_ref");
  public get accessKeyIdSecretRef() {
    return this._accessKeyIdSecretRef;
  }
  public putAccessKeyIdSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef) {
    this._accessKeyIdSecretRef.internalValue = value;
  }
  public resetAccessKeyIdSecretRef() {
    this._accessKeyIdSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdSecretRefInput() {
    return this._accessKeyIdSecretRef.internalValue;
  }

  // secret_access_key_secret_ref - computed: false, optional: true, required: false
  private _secretAccessKeySecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRefOutputReference(this, "secret_access_key_secret_ref");
  public get secretAccessKeySecretRef() {
    return this._secretAccessKeySecretRef;
  }
  public putSecretAccessKeySecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef) {
    this._secretAccessKeySecretRef.internalValue = value;
  }
  public resetSecretAccessKeySecretRef() {
    this._secretAccessKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeySecretRefInput() {
    return this._secretAccessKeySecretRef.internalValue;
  }

  // session_token_secret_ref - computed: false, optional: true, required: false
  private _sessionTokenSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRefOutputReference(this, "session_token_secret_ref");
  public get sessionTokenSecretRef() {
    return this._sessionTokenSecretRef;
  }
  public putSessionTokenSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefSessionTokenSecretRef) {
    this._sessionTokenSecretRef.internalValue = value;
  }
  public resetSessionTokenSecretRef() {
    this._sessionTokenSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTokenSecretRefInput() {
    return this._sessionTokenSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth {
  /**
  * Authenticate against AWS using service account tokens.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt;
  /**
  * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    jwt: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToTerraform(struct!.jwt),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    jwt: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jwt.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jwt.internalValue = value.jwt;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager {
  /**
  * Specifies whether to delete the secret without any recovery window. You can't use both this parameter and RecoveryWindowInDays in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#force_delete_without_recovery DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#force_delete_without_recovery}
  */
  readonly forceDeleteWithoutRecovery?: boolean | cdktf.IResolvable;
  /**
  * The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret. You can't use both this parameter and ForceDeleteWithoutRecovery in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#recovery_window_in_days DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#recovery_window_in_days}
  */
  readonly recoveryWindowInDays?: number;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    force_delete_without_recovery: cdktf.booleanToTerraform(struct!.forceDeleteWithoutRecovery),
    recovery_window_in_days: cdktf.numberToTerraform(struct!.recoveryWindowInDays),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    force_delete_without_recovery: {
      value: cdktf.booleanToHclTerraform(struct!.forceDeleteWithoutRecovery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    recovery_window_in_days: {
      value: cdktf.numberToHclTerraform(struct!.recoveryWindowInDays),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._forceDeleteWithoutRecovery !== undefined) {
      hasAnyValues = true;
      internalValueResult.forceDeleteWithoutRecovery = this._forceDeleteWithoutRecovery;
    }
    if (this._recoveryWindowInDays !== undefined) {
      hasAnyValues = true;
      internalValueResult.recoveryWindowInDays = this._recoveryWindowInDays;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._forceDeleteWithoutRecovery = undefined;
      this._recoveryWindowInDays = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._forceDeleteWithoutRecovery = value.forceDeleteWithoutRecovery;
      this._recoveryWindowInDays = value.recoveryWindowInDays;
    }
  }

  // force_delete_without_recovery - computed: false, optional: true, required: false
  private _forceDeleteWithoutRecovery?: boolean | cdktf.IResolvable; 
  public get forceDeleteWithoutRecovery() {
    return this.getBooleanAttribute('force_delete_without_recovery');
  }
  public set forceDeleteWithoutRecovery(value: boolean | cdktf.IResolvable) {
    this._forceDeleteWithoutRecovery = value;
  }
  public resetForceDeleteWithoutRecovery() {
    this._forceDeleteWithoutRecovery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forceDeleteWithoutRecoveryInput() {
    return this._forceDeleteWithoutRecovery;
  }

  // recovery_window_in_days - computed: false, optional: true, required: false
  private _recoveryWindowInDays?: number; 
  public get recoveryWindowInDays() {
    return this.getNumberAttribute('recovery_window_in_days');
  }
  public set recoveryWindowInDays(value: number) {
    this._recoveryWindowInDays = value;
  }
  public resetRecoveryWindowInDays() {
    this._recoveryWindowInDays = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recoveryWindowInDaysInput() {
    return this._recoveryWindowInDays;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsOutputReference {
    return new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAws {
  /**
  * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#additional_roles DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#additional_roles}
  */
  readonly additionalRoles?: string[];
  /**
  * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth;
  /**
  * AWS External ID set on assumed IAM roles
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#external_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#external_id}
  */
  readonly externalId?: string;
  /**
  * Prefix adds a prefix to all retrieved values.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#prefix DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#prefix}
  */
  readonly prefix?: string;
  /**
  * AWS Region to be used for the provider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#region}
  */
  readonly region: string;
  /**
  * Role is a Role ARN which the provider will assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secrets_manager DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secrets_manager}
  */
  readonly secretsManager?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager;
  /**
  * Service defines which service should be used to fetch the secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service}
  */
  readonly service: string;
  /**
  * AWS STS assume role session tags
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#session_tags DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#session_tags}
  */
  readonly sessionTags?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags[] | cdktf.IResolvable;
  /**
  * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#transitive_tag_keys DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#transitive_tag_keys}
  */
  readonly transitiveTagKeys?: string[];
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    additional_roles: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.additionalRoles),
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthToTerraform(struct!.auth),
    external_id: cdktf.stringToTerraform(struct!.externalId),
    prefix: cdktf.stringToTerraform(struct!.prefix),
    region: cdktf.stringToTerraform(struct!.region),
    role: cdktf.stringToTerraform(struct!.role),
    secrets_manager: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToTerraform(struct!.secretsManager),
    service: cdktf.stringToTerraform(struct!.service),
    session_tags: cdktf.listMapper(dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToTerraform, false)(struct!.sessionTags),
    transitive_tag_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.transitiveTagKeys),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    additional_roles: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.additionalRoles),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth",
    },
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets_manager: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerToHclTerraform(struct!.secretsManager),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    session_tags: {
      value: cdktf.listMapperHcl(dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsToHclTerraform, false)(struct!.sessionTags),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsList",
    },
    transitive_tag_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.transitiveTagKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._additionalRoles !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalRoles = this._additionalRoles;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretsManager?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsManager = this._secretsManager?.internalValue;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._sessionTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTags = this._sessionTags?.internalValue;
    }
    if (this._transitiveTagKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.transitiveTagKeys = this._transitiveTagKeys;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAws | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._additionalRoles = undefined;
      this._auth.internalValue = undefined;
      this._externalId = undefined;
      this._prefix = undefined;
      this._region = undefined;
      this._role = undefined;
      this._secretsManager.internalValue = undefined;
      this._service = undefined;
      this._sessionTags.internalValue = undefined;
      this._transitiveTagKeys = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._additionalRoles = value.additionalRoles;
      this._auth.internalValue = value.auth;
      this._externalId = value.externalId;
      this._prefix = value.prefix;
      this._region = value.region;
      this._role = value.role;
      this._secretsManager.internalValue = value.secretsManager;
      this._service = value.service;
      this._sessionTags.internalValue = value.sessionTags;
      this._transitiveTagKeys = value.transitiveTagKeys;
    }
  }

  // additional_roles - computed: false, optional: true, required: false
  private _additionalRoles?: string[]; 
  public get additionalRoles() {
    return this.getListAttribute('additional_roles');
  }
  public set additionalRoles(value: string[]) {
    this._additionalRoles = value;
  }
  public resetAdditionalRoles() {
    this._additionalRoles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalRolesInput() {
    return this._additionalRoles;
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secrets_manager - computed: false, optional: true, required: false
  private _secretsManager = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManagerOutputReference(this, "secrets_manager");
  public get secretsManager() {
    return this._secretsManager;
  }
  public putSecretsManager(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSecretsManager) {
    this._secretsManager.internalValue = value;
  }
  public resetSecretsManager() {
    this._secretsManager.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsManagerInput() {
    return this._secretsManager.internalValue;
  }

  // service - computed: false, optional: false, required: true
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // session_tags - computed: false, optional: true, required: false
  private _sessionTags = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTagsList(this, "session_tags", false);
  public get sessionTags() {
    return this._sessionTags;
  }
  public putSessionTags(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAwsSessionTags[] | cdktf.IResolvable) {
    this._sessionTags.internalValue = value;
  }
  public resetSessionTags() {
    this._sessionTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTagsInput() {
    return this._sessionTags.internalValue;
  }

  // transitive_tag_keys - computed: false, optional: true, required: false
  private _transitiveTagKeys?: string[]; 
  public get transitiveTagKeys() {
    return this.getListAttribute('transitive_tag_keys');
  }
  public set transitiveTagKeys(value: string[]) {
    this._transitiveTagKeys = value;
  }
  public resetTransitiveTagKeys() {
    this._transitiveTagKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get transitiveTagKeysInput() {
    return this._transitiveTagKeys;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef {
  /**
  * The Azure ClientCertificate of the service principle used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_certificate DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_certificate}
  */
  readonly clientCertificate?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate;
  /**
  * The Azure clientId of the service principle or managed identity used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId;
  /**
  * The Azure ClientSecret of the service principle used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret;
  /**
  * The Azure tenantId of the managed identity used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#tenant_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#tenant_id}
  */
  readonly tenantId?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_certificate: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToTerraform(struct!.clientCertificate),
    client_id: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToTerraform(struct!.clientSecret),
    tenant_id: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToTerraform(struct!.tenantId),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_certificate: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateToHclTerraform(struct!.clientCertificate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate",
    },
    client_id: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret",
    },
    tenant_id: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdToHclTerraform(struct!.tenantId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCertificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCertificate = this._clientCertificate?.internalValue;
    }
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    if (this._tenantId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCertificate.internalValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
      this._tenantId.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCertificate.internalValue = value.clientCertificate;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
      this._tenantId.internalValue = value.tenantId;
    }
  }

  // client_certificate - computed: false, optional: true, required: false
  private _clientCertificate = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificateOutputReference(this, "client_certificate");
  public get clientCertificate() {
    return this._clientCertificate;
  }
  public putClientCertificate(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientCertificate) {
    this._clientCertificate.internalValue = value;
  }
  public resetClientCertificate() {
    this._clientCertificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertificateInput() {
    return this._clientCertificate.internalValue;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientId) {
    this._clientId.internalValue = value;
  }
  public resetClientId() {
    this._clientId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefClientSecret) {
    this._clientSecret.internalValue = value;
  }
  public resetClientSecret() {
    this._clientSecret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantIdOutputReference(this, "tenant_id");
  public get tenantId() {
    return this._tenantId;
  }
  public putTenantId(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefTenantId) {
    this._tenantId.internalValue = value;
  }
  public resetTenantId() {
    this._tenantId.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekv {
  /**
  * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth_secret_ref}
  */
  readonly authSecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef;
  /**
  * Auth type defines how to authenticate to the keyvault service. Valid values are: - 'ServicePrincipal' (default): Using a service principal (tenantId, clientId, clientSecret) - 'ManagedIdentity': Using Managed Identity assigned to the pod (see aad-pod-identity)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth_type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth_type}
  */
  readonly authType?: string;
  /**
  * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#environment_type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#environment_type}
  */
  readonly environmentType?: string;
  /**
  * If multiple Managed Identity is assigned to the pod, you can select the one to be used
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#identity_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#identity_id}
  */
  readonly identityId?: string;
  /**
  * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef;
  /**
  * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type. Optional for WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#tenant_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Vault Url from which the secrets to be fetched from.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#vault_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#vault_url}
  */
  readonly vaultUrl: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToTerraform(struct!.authSecretRef),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    environment_type: cdktf.stringToTerraform(struct!.environmentType),
    identity_id: cdktf.stringToTerraform(struct!.identityId),
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToTerraform(struct!.serviceAccountRef),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    vault_url: cdktf.stringToTerraform(struct!.vaultUrl),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefToHclTerraform(struct!.authSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment_type: {
      value: cdktf.stringToHclTerraform(struct!.environmentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    identity_id: {
      value: cdktf.stringToHclTerraform(struct!.identityId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vault_url: {
      value: cdktf.stringToHclTerraform(struct!.vaultUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authSecretRef = this._authSecretRef?.internalValue;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._environmentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentType = this._environmentType;
    }
    if (this._identityId !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityId = this._identityId;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._vaultUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaultUrl = this._vaultUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekv | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authSecretRef.internalValue = undefined;
      this._authType = undefined;
      this._environmentType = undefined;
      this._identityId = undefined;
      this._serviceAccountRef.internalValue = undefined;
      this._tenantId = undefined;
      this._vaultUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authSecretRef.internalValue = value.authSecretRef;
      this._authType = value.authType;
      this._environmentType = value.environmentType;
      this._identityId = value.identityId;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
      this._tenantId = value.tenantId;
      this._vaultUrl = value.vaultUrl;
    }
  }

  // auth_secret_ref - computed: false, optional: true, required: false
  private _authSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRefOutputReference(this, "auth_secret_ref");
  public get authSecretRef() {
    return this._authSecretRef;
  }
  public putAuthSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvAuthSecretRef) {
    this._authSecretRef.internalValue = value;
  }
  public resetAuthSecretRef() {
    this._authSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authSecretRefInput() {
    return this._authSecretRef.internalValue;
  }

  // auth_type - computed: false, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // environment_type - computed: false, optional: true, required: false
  private _environmentType?: string; 
  public get environmentType() {
    return this.getStringAttribute('environment_type');
  }
  public set environmentType(value: string) {
    this._environmentType = value;
  }
  public resetEnvironmentType() {
    this._environmentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentTypeInput() {
    return this._environmentType;
  }

  // identity_id - computed: false, optional: true, required: false
  private _identityId?: string; 
  public get identityId() {
    return this.getStringAttribute('identity_id');
  }
  public set identityId(value: string) {
    this._identityId = value;
  }
  public resetIdentityId() {
    this._identityId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityIdInput() {
    return this._identityId;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderAzurekvServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // vault_url - computed: false, optional: false, required: true
  private _vaultUrl?: string; 
  public get vaultUrl() {
    return this.getStringAttribute('vault_url');
  }
  public set vaultUrl(value: string) {
    this._vaultUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultUrlInput() {
    return this._vaultUrl;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth {
  /**
  * Content of the certificate (cert.pem) for use when authenticating with an OAuth client Id using a Client Certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#certificate DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#certificate}
  */
  readonly certificate?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate;
  /**
  * Certificate private key (key.pem). For use when authenticating with an OAuth client Id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#certificate_key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#certificate_key}
  */
  readonly certificateKey?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificate: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToTerraform(struct!.certificate),
    certificate_key: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToTerraform(struct!.certificateKey),
    client_id: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToTerraform(struct!.clientSecret),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificate: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateToHclTerraform(struct!.certificate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate",
    },
    certificate_key: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyToHclTerraform(struct!.certificateKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey",
    },
    client_id: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificate = this._certificate?.internalValue;
    }
    if (this._certificateKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateKey = this._certificateKey?.internalValue;
    }
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificate.internalValue = undefined;
      this._certificateKey.internalValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificate.internalValue = value.certificate;
      this._certificateKey.internalValue = value.certificateKey;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
    }
  }

  // certificate - computed: false, optional: true, required: false
  private _certificate = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateOutputReference(this, "certificate");
  public get certificate() {
    return this._certificate;
  }
  public putCertificate(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificate) {
    this._certificate.internalValue = value;
  }
  public resetCertificate() {
    this._certificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateInput() {
    return this._certificate.internalValue;
  }

  // certificate_key - computed: false, optional: true, required: false
  private _certificateKey = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKeyOutputReference(this, "certificate_key");
  public get certificateKey() {
    return this._certificateKey;
  }
  public putCertificateKey(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthCertificateKey) {
    this._certificateKey.internalValue = value;
  }
  public resetCertificateKey() {
    this._certificateKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateKeyInput() {
    return this._certificateKey.internalValue;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientId) {
    this._clientId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: false, required: true
  private _clientSecret = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthClientSecret) {
    this._clientSecret.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl: string;
  /**
  * Timeout specifies a time limit for requests made by this Client. The timeout includes connection time, any redirects, and reading the response body. Defaults to 45 seconds.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_time_out_seconds DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_time_out_seconds}
  */
  readonly clientTimeOutSeconds?: number;
  /**
  * The secret retrieval type. SECRET = Secrets Safe (credential, text, file). MANAGED_ACCOUNT = Password Safe account associated with a system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#retrieval_type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#retrieval_type}
  */
  readonly retrievalType?: string;
  /**
  * A character that separates the folder names.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#separator DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#separator}
  */
  readonly separator?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#verify_ca DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#verify_ca}
  */
  readonly verifyCa: boolean | cdktf.IResolvable;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    client_time_out_seconds: cdktf.numberToTerraform(struct!.clientTimeOutSeconds),
    retrieval_type: cdktf.stringToTerraform(struct!.retrievalType),
    separator: cdktf.stringToTerraform(struct!.separator),
    verify_ca: cdktf.booleanToTerraform(struct!.verifyCa),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_time_out_seconds: {
      value: cdktf.numberToHclTerraform(struct!.clientTimeOutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retrieval_type: {
      value: cdktf.stringToHclTerraform(struct!.retrievalType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    separator: {
      value: cdktf.stringToHclTerraform(struct!.separator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_ca: {
      value: cdktf.booleanToHclTerraform(struct!.verifyCa),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._clientTimeOutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientTimeOutSeconds = this._clientTimeOutSeconds;
    }
    if (this._retrievalType !== undefined) {
      hasAnyValues = true;
      internalValueResult.retrievalType = this._retrievalType;
    }
    if (this._separator !== undefined) {
      hasAnyValues = true;
      internalValueResult.separator = this._separator;
    }
    if (this._verifyCa !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyCa = this._verifyCa;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._clientTimeOutSeconds = undefined;
      this._retrievalType = undefined;
      this._separator = undefined;
      this._verifyCa = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._clientTimeOutSeconds = value.clientTimeOutSeconds;
      this._retrievalType = value.retrievalType;
      this._separator = value.separator;
      this._verifyCa = value.verifyCa;
    }
  }

  // api_url - computed: false, optional: false, required: true
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // client_time_out_seconds - computed: false, optional: true, required: false
  private _clientTimeOutSeconds?: number; 
  public get clientTimeOutSeconds() {
    return this.getNumberAttribute('client_time_out_seconds');
  }
  public set clientTimeOutSeconds(value: number) {
    this._clientTimeOutSeconds = value;
  }
  public resetClientTimeOutSeconds() {
    this._clientTimeOutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientTimeOutSecondsInput() {
    return this._clientTimeOutSeconds;
  }

  // retrieval_type - computed: false, optional: true, required: false
  private _retrievalType?: string; 
  public get retrievalType() {
    return this.getStringAttribute('retrieval_type');
  }
  public set retrievalType(value: string) {
    this._retrievalType = value;
  }
  public resetRetrievalType() {
    this._retrievalType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retrievalTypeInput() {
    return this._retrievalType;
  }

  // separator - computed: false, optional: true, required: false
  private _separator?: string; 
  public get separator() {
    return this.getStringAttribute('separator');
  }
  public set separator(value: string) {
    this._separator = value;
  }
  public resetSeparator() {
    this._separator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get separatorInput() {
    return this._separator;
  }

  // verify_ca - computed: false, optional: false, required: true
  private _verifyCa?: boolean | cdktf.IResolvable; 
  public get verifyCa() {
    return this.getBooleanAttribute('verify_ca');
  }
  public set verifyCa(value: boolean | cdktf.IResolvable) {
    this._verifyCa = value;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyCaInput() {
    return this._verifyCa;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrust {
  /**
  * Auth configures how the operator authenticates with Beyondtrust.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth;
  /**
  * Auth configures how API server works.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#server DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#server}
  */
  readonly server: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToTerraform(struct!.auth),
    server: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToTerraform(struct!.server),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth",
    },
    server: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerToHclTerraform(struct!.server),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._server?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrust | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._server.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._server.internalValue = value.server;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // server - computed: false, optional: false, required: true
  private _server = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServerOutputReference(this, "server");
  public get server() {
    return this._server;
  }
  public putServer(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBeyondtrustServer) {
    this._server.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef {
  /**
  * AccessToken used for the bitwarden instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#credentials DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#credentials}
  */
  readonly credentials: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToTerraform(struct!.credentials),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
    }
  }

  // credentials - computed: false, optional: false, required: true
  private _credentials = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefCredentials) {
    this._credentials.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth {
  /**
  * BitwardenSecretsManagerSecretRef contains the credential ref to the bitwarden instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Auth configures how secret-manager authenticates with a bitwarden machine account instance. Make sure that the token being used has permissions on the given secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#bitwarden_server_sdk_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#bitwarden_server_sdk_url}
  */
  readonly bitwardenServerSdkUrl?: string;
  /**
  * Base64 encoded certificate for the bitwarden server sdk. The sdk MUST run with HTTPS to make sure no MITM attack can be performed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * see: https://external-secrets.io/latest/spec/#external-secrets.io/v1alpha1.CAProvider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#identity_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#identity_url}
  */
  readonly identityUrl?: string;
  /**
  * OrganizationID determines which organization this secret store manages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#organization_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#organization_id}
  */
  readonly organizationId: string;
  /**
  * ProjectID determines which project this secret store manages.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToTerraform(struct!.auth),
    bitwarden_server_sdk_url: cdktf.stringToTerraform(struct!.bitwardenServerSdkUrl),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToTerraform(struct!.caProvider),
    identity_url: cdktf.stringToTerraform(struct!.identityUrl),
    organization_id: cdktf.stringToTerraform(struct!.organizationId),
    project_id: cdktf.stringToTerraform(struct!.projectId),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth",
    },
    bitwarden_server_sdk_url: {
      value: cdktf.stringToHclTerraform(struct!.bitwardenServerSdkUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider",
    },
    identity_url: {
      value: cdktf.stringToHclTerraform(struct!.identityUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    organization_id: {
      value: cdktf.stringToHclTerraform(struct!.organizationId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._bitwardenServerSdkUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.bitwardenServerSdkUrl = this._bitwardenServerSdkUrl;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._identityUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.identityUrl = this._identityUrl;
    }
    if (this._organizationId !== undefined) {
      hasAnyValues = true;
      internalValueResult.organizationId = this._organizationId;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanager | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._auth.internalValue = undefined;
      this._bitwardenServerSdkUrl = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._identityUrl = undefined;
      this._organizationId = undefined;
      this._projectId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._auth.internalValue = value.auth;
      this._bitwardenServerSdkUrl = value.bitwardenServerSdkUrl;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._identityUrl = value.identityUrl;
      this._organizationId = value.organizationId;
      this._projectId = value.projectId;
    }
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // bitwarden_server_sdk_url - computed: false, optional: true, required: false
  private _bitwardenServerSdkUrl?: string; 
  public get bitwardenServerSdkUrl() {
    return this.getStringAttribute('bitwarden_server_sdk_url');
  }
  public set bitwardenServerSdkUrl(value: string) {
    this._bitwardenServerSdkUrl = value;
  }
  public resetBitwardenServerSdkUrl() {
    this._bitwardenServerSdkUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bitwardenServerSdkUrlInput() {
    return this._bitwardenServerSdkUrl;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderBitwardensecretsmanagerCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // identity_url - computed: false, optional: true, required: false
  private _identityUrl?: string; 
  public get identityUrl() {
    return this.getStringAttribute('identity_url');
  }
  public set identityUrl(value: string) {
    this._identityUrl = value;
  }
  public resetIdentityUrl() {
    this._identityUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get identityUrlInput() {
    return this._identityUrl;
  }

  // organization_id - computed: false, optional: false, required: true
  private _organizationId?: string; 
  public get organizationId() {
    return this.getStringAttribute('organization_id');
  }
  public set organizationId(value: string) {
    this._organizationId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get organizationIdInput() {
    return this._organizationId;
  }

  // project_id - computed: false, optional: false, required: true
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef {
  /**
  * SecretKey is the Signing Key in PEM format, used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#private_key_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#private_key_secret_ref}
  */
  readonly privateKeySecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    private_key_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToTerraform(struct!.privateKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    private_key_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefToHclTerraform(struct!.privateKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._privateKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKeySecretRef = this._privateKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._privateKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._privateKeySecretRef.internalValue = value.privateKeySecretRef;
    }
  }

  // private_key_secret_ref - computed: false, optional: false, required: true
  private _privateKeySecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRefOutputReference(this, "private_key_secret_ref");
  public get privateKeySecretRef() {
    return this._privateKeySecretRef;
  }
  public putPrivateKeySecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefPrivateKeySecretRef) {
    this._privateKeySecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeySecretRefInput() {
    return this._privateKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth {
  /**
  * ChefAuthSecretRef holds secret references for chef server login credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChef {
  /**
  * Auth defines the information necessary to authenticate against chef Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth;
  /**
  * ServerURL is the chef server URL used to connect to. If using orgs you should include your org in the url and terminate the url with a '/'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#server_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#server_url}
  */
  readonly serverUrl: string;
  /**
  * UserName should be the user ID on the chef server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#username}
  */
  readonly username: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthToTerraform(struct!.auth),
    server_url: cdktf.stringToTerraform(struct!.serverUrl),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth",
    },
    server_url: {
      value: cdktf.stringToHclTerraform(struct!.serverUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._serverUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverUrl = this._serverUrl;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._serverUrl = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._serverUrl = value.serverUrl;
      this._username = value.username;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderChefAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // server_url - computed: false, optional: false, required: true
  private _serverUrl?: string; 
  public get serverUrl() {
    return this.getStringAttribute('server_url');
  }
  public set serverUrl(value: string) {
    this._serverUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverUrlInput() {
    return this._serverUrl;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#account DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#account}
  */
  readonly account: string;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_key_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_key_ref}
  */
  readonly apiKeyRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#user_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#user_ref}
  */
  readonly userRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account: cdktf.stringToTerraform(struct!.account),
    api_key_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToTerraform(struct!.apiKeyRef),
    user_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToTerraform(struct!.userRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account: {
      value: cdktf.stringToHclTerraform(struct!.account),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_key_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefToHclTerraform(struct!.apiKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef",
    },
    user_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefToHclTerraform(struct!.userRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._account !== undefined) {
      hasAnyValues = true;
      internalValueResult.account = this._account;
    }
    if (this._apiKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKeyRef = this._apiKeyRef?.internalValue;
    }
    if (this._userRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.userRef = this._userRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._account = undefined;
      this._apiKeyRef.internalValue = undefined;
      this._userRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._account = value.account;
      this._apiKeyRef.internalValue = value.apiKeyRef;
      this._userRef.internalValue = value.userRef;
    }
  }

  // account - computed: false, optional: false, required: true
  private _account?: string; 
  public get account() {
    return this.getStringAttribute('account');
  }
  public set account(value: string) {
    this._account = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountInput() {
    return this._account;
  }

  // api_key_ref - computed: false, optional: false, required: true
  private _apiKeyRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRefOutputReference(this, "api_key_ref");
  public get apiKeyRef() {
    return this._apiKeyRef;
  }
  public putApiKeyRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyApiKeyRef) {
    this._apiKeyRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyRefInput() {
    return this._apiKeyRef.internalValue;
  }

  // user_ref - computed: false, optional: false, required: true
  private _userRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRefOutputReference(this, "user_ref");
  public get userRef() {
    return this._userRef;
  }
  public putUserRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyUserRef) {
    this._userRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userRefInput() {
    return this._userRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#account DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#account}
  */
  readonly account: string;
  /**
  * Optional HostID for JWT authentication. This may be used depending on how the Conjur JWT authenticator policy is configured.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#host_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#host_id}
  */
  readonly hostId?: string;
  /**
  * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef;
  /**
  * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the 'TokenRequest' API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef;
  /**
  * The conjur authn jwt webservice id
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_id}
  */
  readonly serviceId: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account: cdktf.stringToTerraform(struct!.account),
    host_id: cdktf.stringToTerraform(struct!.hostId),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToTerraform(struct!.secretRef),
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToTerraform(struct!.serviceAccountRef),
    service_id: cdktf.stringToTerraform(struct!.serviceId),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account: {
      value: cdktf.stringToHclTerraform(struct!.account),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host_id: {
      value: cdktf.stringToHclTerraform(struct!.hostId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef",
    },
    service_id: {
      value: cdktf.stringToHclTerraform(struct!.serviceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._account !== undefined) {
      hasAnyValues = true;
      internalValueResult.account = this._account;
    }
    if (this._hostId !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostId = this._hostId;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    if (this._serviceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceId = this._serviceId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._account = undefined;
      this._hostId = undefined;
      this._secretRef.internalValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
      this._serviceId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._account = value.account;
      this._hostId = value.hostId;
      this._secretRef.internalValue = value.secretRef;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
      this._serviceId = value.serviceId;
    }
  }

  // account - computed: false, optional: false, required: true
  private _account?: string; 
  public get account() {
    return this.getStringAttribute('account');
  }
  public set account(value: string) {
    this._account = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountInput() {
    return this._account;
  }

  // host_id - computed: false, optional: true, required: false
  private _hostId?: string; 
  public get hostId() {
    return this.getStringAttribute('host_id');
  }
  public set hostId(value: string) {
    this._hostId = value;
  }
  public resetHostId() {
    this._hostId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostIdInput() {
    return this._hostId;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }

  // service_id - computed: false, optional: false, required: true
  private _serviceId?: string; 
  public get serviceId() {
    return this.getStringAttribute('service_id');
  }
  public set serviceId(value: string) {
    this._serviceId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceIdInput() {
    return this._serviceId;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#apikey DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#apikey}
  */
  readonly apikey?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    apikey: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToTerraform(struct!.apikey),
    jwt: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToTerraform(struct!.jwt),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    apikey: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyToHclTerraform(struct!.apikey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey",
    },
    jwt: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apikey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apikey = this._apikey?.internalValue;
    }
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apikey.internalValue = undefined;
      this._jwt.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apikey.internalValue = value.apikey;
      this._jwt.internalValue = value.jwt;
    }
  }

  // apikey - computed: false, optional: true, required: false
  private _apikey = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikeyOutputReference(this, "apikey");
  public get apikey() {
    return this._apikey;
  }
  public putApikey(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthApikey) {
    this._apikey.internalValue = value;
  }
  public resetApikey() {
    this._apikey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apikeyInput() {
    return this._apikey.internalValue;
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjur {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthToTerraform(struct!.auth),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToTerraform(struct!.caProvider),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjur | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderConjurCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelinea {
  /**
  * ClientID is the non-secret part of the credential.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId;
  /**
  * ClientSecret is the secret part of the credential.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret;
  /**
  * Tenant is the chosen hostname / site name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#tenant DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#tenant}
  */
  readonly tenant: string;
  /**
  * TLD is based on the server location that was chosen during provisioning. If unset, defaults to 'com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#tld DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#tld}
  */
  readonly tld?: string;
  /**
  * URLTemplate If unset, defaults to 'https://%s.secretsvaultcloud.%s/v1/%s%s'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#url_template DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#url_template}
  */
  readonly urlTemplate?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToTerraform(struct!.clientSecret),
    tenant: cdktf.stringToTerraform(struct!.tenant),
    tld: cdktf.stringToTerraform(struct!.tld),
    url_template: cdktf.stringToTerraform(struct!.urlTemplate),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret",
    },
    tenant: {
      value: cdktf.stringToHclTerraform(struct!.tenant),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tld: {
      value: cdktf.stringToHclTerraform(struct!.tld),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url_template: {
      value: cdktf.stringToHclTerraform(struct!.urlTemplate),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    if (this._tenant !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenant = this._tenant;
    }
    if (this._tld !== undefined) {
      hasAnyValues = true;
      internalValueResult.tld = this._tld;
    }
    if (this._urlTemplate !== undefined) {
      hasAnyValues = true;
      internalValueResult.urlTemplate = this._urlTemplate;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelinea | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
      this._tenant = undefined;
      this._tld = undefined;
      this._urlTemplate = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
      this._tenant = value.tenant;
      this._tld = value.tld;
      this._urlTemplate = value.urlTemplate;
    }
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientId) {
    this._clientId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: false, required: true
  private _clientSecret = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDelineaClientSecret) {
    this._clientSecret.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }

  // tenant - computed: false, optional: false, required: true
  private _tenant?: string; 
  public get tenant() {
    return this.getStringAttribute('tenant');
  }
  public set tenant(value: string) {
    this._tenant = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantInput() {
    return this._tenant;
  }

  // tld - computed: false, optional: true, required: false
  private _tld?: string; 
  public get tld() {
    return this.getStringAttribute('tld');
  }
  public set tld(value: string) {
    this._tld = value;
  }
  public resetTld() {
    this._tld = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tldInput() {
    return this._tld;
  }

  // url_template - computed: false, optional: true, required: false
  private _urlTemplate?: string; 
  public get urlTemplate() {
    return this.getStringAttribute('url_template');
  }
  public set urlTemplate(value: string) {
    this._urlTemplate = value;
  }
  public resetUrlTemplate() {
    this._urlTemplate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlTemplateInput() {
    return this._urlTemplate;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef {
  /**
  * Username / Password is used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#credentials DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#credentials}
  */
  readonly credentials?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToTerraform(struct!.credentials),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42 {
  /**
  * Auth configures how secret-manager authenticates with a Device42 instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth;
  /**
  * URL configures the Device42 instance URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#host DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#host}
  */
  readonly host: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42ToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToTerraform(struct!.auth),
    host: cdktf.stringToTerraform(struct!.host),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42ToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._host = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._host = value.host;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42AuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDevice42Auth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef {
  /**
  * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#doppler_token DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#doppler_token}
  */
  readonly dopplerToken: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    doppler_token: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToTerraform(struct!.dopplerToken),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    doppler_token: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenToHclTerraform(struct!.dopplerToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dopplerToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dopplerToken = this._dopplerToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dopplerToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dopplerToken.internalValue = value.dopplerToken;
    }
  }

  // doppler_token - computed: false, optional: false, required: true
  private _dopplerToken = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerTokenOutputReference(this, "doppler_token");
  public get dopplerToken() {
    return this._dopplerToken;
  }
  public putDopplerToken(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefDopplerToken) {
    this._dopplerToken.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dopplerTokenInput() {
    return this._dopplerToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDoppler {
  /**
  * Auth configures how the Operator authenticates with the Doppler API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth;
  /**
  * Doppler config (required if not using a Service Token)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#config DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#config}
  */
  readonly config?: string;
  /**
  * Format enables the downloading of secrets as a file (string)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#format DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#format}
  */
  readonly format?: string;
  /**
  * Environment variable compatible name transforms that change secret names to a different format
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name_transformer DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name_transformer}
  */
  readonly nameTransformer?: string;
  /**
  * Doppler project (required if not using a Service Token)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project}
  */
  readonly project?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToTerraform(struct!.auth),
    config: cdktf.stringToTerraform(struct!.config),
    format: cdktf.stringToTerraform(struct!.format),
    name_transformer: cdktf.stringToTerraform(struct!.nameTransformer),
    project: cdktf.stringToTerraform(struct!.project),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth",
    },
    config: {
      value: cdktf.stringToHclTerraform(struct!.config),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name_transformer: {
      value: cdktf.stringToHclTerraform(struct!.nameTransformer),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._config !== undefined) {
      hasAnyValues = true;
      internalValueResult.config = this._config;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._nameTransformer !== undefined) {
      hasAnyValues = true;
      internalValueResult.nameTransformer = this._nameTransformer;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDoppler | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._config = undefined;
      this._format = undefined;
      this._nameTransformer = undefined;
      this._project = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._config = value.config;
      this._format = value.format;
      this._nameTransformer = value.nameTransformer;
      this._project = value.project;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderDopplerAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // config - computed: false, optional: true, required: false
  private _config?: string; 
  public get config() {
    return this.getStringAttribute('config');
  }
  public set config(value: string) {
    this._config = value;
  }
  public resetConfig() {
    this._config = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configInput() {
    return this._config;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // name_transformer - computed: false, optional: true, required: false
  private _nameTransformer?: string; 
  public get nameTransformer() {
    return this.getStringAttribute('name_transformer');
  }
  public set nameTransformer(value: string) {
    this._nameTransformer = value;
  }
  public resetNameTransformer() {
    this._nameTransformer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameTransformerInput() {
    return this._nameTransformer;
  }

  // project - computed: false, optional: true, required: false
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  public resetProject() {
    this._project = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
  /**
  * Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the 'value' field instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value_map DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value_map}
  */
  readonly valueMap?: { [key: string]: string };
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#version DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
    value_map: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.valueMap),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_map: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.valueMap),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    if (this._valueMap !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueMap = this._valueMap;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
      this._valueMap = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
      this._valueMap = value.valueMap;
      this._version = value.version;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }

  // value_map - computed: false, optional: true, required: false
  private _valueMap?: { [key: string]: string }; 
  public get valueMap() {
    return this.getStringMapAttribute('value_map');
  }
  public set valueMap(value: { [key: string]: string }) {
    this._valueMap = value;
  }
  public resetValueMap() {
    this._valueMap = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueMapInput() {
    return this._valueMap;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataOutputReference {
    return new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFake {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#data DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#data}
  */
  readonly data: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData[] | cdktf.IResolvable;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data: cdktf.listMapper(dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataToTerraform, false)(struct!.data),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data: {
      value: cdktf.listMapperHcl(dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataToHclTerraform, false)(struct!.data),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._data?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.data = this._data?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._data.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._data.internalValue = value.data;
    }
  }

  // data - computed: false, optional: false, required: true
  private _data = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeDataList(this, "data", false);
  public get data() {
    return this._data;
  }
  public putData(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFakeData[] | cdktf.IResolvable) {
    this._data.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get dataInput() {
    return this._data.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey {
  /**
  * SecretRef is a reference to a secret containing the SDKMS API Key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanix {
  /**
  * APIKey is the API token to access SDKMS Applications.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_key}
  */
  readonly apiKey?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey;
  /**
  * APIURL is the URL of SDKMS API. Defaults to 'sdkms.fortanix.com'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToTerraform(struct!.apiKey),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyToHclTerraform(struct!.apiKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey?.internalValue;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanix | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey.internalValue = undefined;
      this._apiUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey.internalValue = value.apiKey;
      this._apiUrl = value.apiUrl;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKeyOutputReference(this, "api_key");
  public get apiKey() {
    return this._apiKey;
  }
  public putApiKey(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderFortanixApiKey) {
    this._apiKey.internalValue = value;
  }
  public resetApiKey() {
    this._apiKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey.internalValue;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef {
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_access_key_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_access_key_secret_ref}
  */
  readonly secretAccessKeySecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_access_key_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToTerraform(struct!.secretAccessKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_access_key_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefToHclTerraform(struct!.secretAccessKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretAccessKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKeySecretRef = this._secretAccessKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretAccessKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretAccessKeySecretRef.internalValue = value.secretAccessKeySecretRef;
    }
  }

  // secret_access_key_secret_ref - computed: false, optional: true, required: false
  private _secretAccessKeySecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRefOutputReference(this, "secret_access_key_secret_ref");
  public get secretAccessKeySecretRef() {
    return this._secretAccessKeySecretRef;
  }
  public putSecretAccessKeySecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef) {
    this._secretAccessKeySecretRef.internalValue = value;
  }
  public resetSecretAccessKeySecretRef() {
    this._secretAccessKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeySecretRefInput() {
    return this._secretAccessKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#cluster_location DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#cluster_location}
  */
  readonly clusterLocation: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#cluster_name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#cluster_name}
  */
  readonly clusterName: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#cluster_project_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#cluster_project_id}
  */
  readonly clusterProjectId?: string;
  /**
  * A reference to a ServiceAccount resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cluster_location: cdktf.stringToTerraform(struct!.clusterLocation),
    cluster_name: cdktf.stringToTerraform(struct!.clusterName),
    cluster_project_id: cdktf.stringToTerraform(struct!.clusterProjectId),
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cluster_location: {
      value: cdktf.stringToHclTerraform(struct!.clusterLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_name: {
      value: cdktf.stringToHclTerraform(struct!.clusterName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_project_id: {
      value: cdktf.stringToHclTerraform(struct!.clusterProjectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clusterLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterLocation = this._clusterLocation;
    }
    if (this._clusterName !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterName = this._clusterName;
    }
    if (this._clusterProjectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterProjectId = this._clusterProjectId;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clusterLocation = undefined;
      this._clusterName = undefined;
      this._clusterProjectId = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clusterLocation = value.clusterLocation;
      this._clusterName = value.clusterName;
      this._clusterProjectId = value.clusterProjectId;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // cluster_location - computed: false, optional: false, required: true
  private _clusterLocation?: string; 
  public get clusterLocation() {
    return this.getStringAttribute('cluster_location');
  }
  public set clusterLocation(value: string) {
    this._clusterLocation = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterLocationInput() {
    return this._clusterLocation;
  }

  // cluster_name - computed: false, optional: false, required: true
  private _clusterName?: string; 
  public get clusterName() {
    return this.getStringAttribute('cluster_name');
  }
  public set clusterName(value: string) {
    this._clusterName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterNameInput() {
    return this._clusterName;
  }

  // cluster_project_id - computed: false, optional: true, required: false
  private _clusterProjectId?: string; 
  public get clusterProjectId() {
    return this.getStringAttribute('cluster_project_id');
  }
  public set clusterProjectId(value: string) {
    this._clusterProjectId = value;
  }
  public resetClusterProjectId() {
    this._clusterProjectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterProjectIdInput() {
    return this._clusterProjectId;
  }

  // service_account_ref - computed: false, optional: false, required: true
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#workload_identity DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#workload_identity}
  */
  readonly workloadIdentity?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToTerraform(struct!.secretRef),
    workload_identity: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToTerraform(struct!.workloadIdentity),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef",
    },
    workload_identity: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityToHclTerraform(struct!.workloadIdentity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._workloadIdentity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.workloadIdentity = this._workloadIdentity?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._workloadIdentity.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._workloadIdentity.internalValue = value.workloadIdentity;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // workload_identity - computed: false, optional: true, required: false
  private _workloadIdentity = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentityOutputReference(this, "workload_identity");
  public get workloadIdentity() {
    return this._workloadIdentity;
  }
  public putWorkloadIdentity(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthWorkloadIdentity) {
    this._workloadIdentity.internalValue = value;
  }
  public resetWorkloadIdentity() {
    this._workloadIdentity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workloadIdentityInput() {
    return this._workloadIdentity.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsm {
  /**
  * Auth defines the information necessary to authenticate against GCP
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth;
  /**
  * Location optionally defines a location for a secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#location DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#location}
  */
  readonly location?: string;
  /**
  * ProjectID project where secret is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToTerraform(struct!.auth),
    location: cdktf.stringToTerraform(struct!.location),
    project_id: cdktf.stringToTerraform(struct!.projectId),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth",
    },
    location: {
      value: cdktf.stringToHclTerraform(struct!.location),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._location !== undefined) {
      hasAnyValues = true;
      internalValueResult.location = this._location;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._location = undefined;
      this._projectId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._location = value.location;
      this._projectId = value.projectId;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGcpsmAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // location - computed: false, optional: true, required: false
  private _location?: string; 
  public get location() {
    return this.getStringAttribute('location');
  }
  public set location(value: string) {
    this._location = value;
  }
  public resetLocation() {
    this._location = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get locationInput() {
    return this._location;
  }

  // project_id - computed: false, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef {
  /**
  * AccessToken is used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_token DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_token}
  */
  readonly accessToken?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToTerraform(struct!.accessToken),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenToHclTerraform(struct!.accessToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = value.accessToken;
    }
  }

  // access_token - computed: false, optional: true, required: false
  private _accessToken = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessTokenOutputReference(this, "access_token");
  public get accessToken() {
    return this._accessToken;
  }
  public putAccessToken(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefAccessToken) {
    this._accessToken.internalValue = value;
  }
  public resetAccessToken() {
    this._accessToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlab {
  /**
  * Auth configures how secret-manager authenticates with a GitLab instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth;
  /**
  * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#environment DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#environment}
  */
  readonly environment?: string;
  /**
  * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#group_i_ds DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#group_i_ds}
  */
  readonly groupIDs?: string[];
  /**
  * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#inherit_from_groups DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#inherit_from_groups}
  */
  readonly inheritFromGroups?: boolean | cdktf.IResolvable;
  /**
  * ProjectID specifies a project where secrets are located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId?: string;
  /**
  * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToTerraform(struct!.auth),
    environment: cdktf.stringToTerraform(struct!.environment),
    group_i_ds: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.groupIDs),
    inherit_from_groups: cdktf.booleanToTerraform(struct!.inheritFromGroups),
    project_id: cdktf.stringToTerraform(struct!.projectId),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    group_i_ds: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.groupIDs),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    inherit_from_groups: {
      value: cdktf.booleanToHclTerraform(struct!.inheritFromGroups),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._groupIDs !== undefined) {
      hasAnyValues = true;
      internalValueResult.groupIDs = this._groupIDs;
    }
    if (this._inheritFromGroups !== undefined) {
      hasAnyValues = true;
      internalValueResult.inheritFromGroups = this._inheritFromGroups;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlab | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._environment = undefined;
      this._groupIDs = undefined;
      this._inheritFromGroups = undefined;
      this._projectId = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._environment = value.environment;
      this._groupIDs = value.groupIDs;
      this._inheritFromGroups = value.inheritFromGroups;
      this._projectId = value.projectId;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderGitlabAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // group_i_ds - computed: false, optional: true, required: false
  private _groupIDs?: string[]; 
  public get groupIDs() {
    return this.getListAttribute('group_i_ds');
  }
  public set groupIDs(value: string[]) {
    this._groupIDs = value;
  }
  public resetGroupIDs() {
    this._groupIDs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get groupIDsInput() {
    return this._groupIDs;
  }

  // inherit_from_groups - computed: false, optional: true, required: false
  private _inheritFromGroups?: boolean | cdktf.IResolvable; 
  public get inheritFromGroups() {
    return this.getBooleanAttribute('inherit_from_groups');
  }
  public set inheritFromGroups(value: boolean | cdktf.IResolvable) {
    this._inheritFromGroups = value;
  }
  public resetInheritFromGroups() {
    this._inheritFromGroups = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inheritFromGroupsInput() {
    return this._inheritFromGroups;
  }

  // project_id - computed: false, optional: true, required: false
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  public resetProjectId() {
    this._projectId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#iam_endpoint DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#iam_endpoint}
  */
  readonly iamEndpoint?: string;
  /**
  * the IBM Trusted Profile
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#profile DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#profile}
  */
  readonly profile: string;
  /**
  * Location the token is mounted on the pod
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#token_location DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#token_location}
  */
  readonly tokenLocation?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    iam_endpoint: cdktf.stringToTerraform(struct!.iamEndpoint),
    profile: cdktf.stringToTerraform(struct!.profile),
    token_location: cdktf.stringToTerraform(struct!.tokenLocation),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    iam_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.iamEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    profile: {
      value: cdktf.stringToHclTerraform(struct!.profile),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_location: {
      value: cdktf.stringToHclTerraform(struct!.tokenLocation),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._iamEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.iamEndpoint = this._iamEndpoint;
    }
    if (this._profile !== undefined) {
      hasAnyValues = true;
      internalValueResult.profile = this._profile;
    }
    if (this._tokenLocation !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenLocation = this._tokenLocation;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._iamEndpoint = undefined;
      this._profile = undefined;
      this._tokenLocation = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._iamEndpoint = value.iamEndpoint;
      this._profile = value.profile;
      this._tokenLocation = value.tokenLocation;
    }
  }

  // iam_endpoint - computed: false, optional: true, required: false
  private _iamEndpoint?: string; 
  public get iamEndpoint() {
    return this.getStringAttribute('iam_endpoint');
  }
  public set iamEndpoint(value: string) {
    this._iamEndpoint = value;
  }
  public resetIamEndpoint() {
    this._iamEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iamEndpointInput() {
    return this._iamEndpoint;
  }

  // profile - computed: false, optional: false, required: true
  private _profile?: string; 
  public get profile() {
    return this.getStringAttribute('profile');
  }
  public set profile(value: string) {
    this._profile = value;
  }
  // Temporarily expose input value. Use with caution.
  public get profileInput() {
    return this._profile;
  }

  // token_location - computed: false, optional: true, required: false
  private _tokenLocation?: string; 
  public get tokenLocation() {
    return this.getStringAttribute('token_location');
  }
  public set tokenLocation(value: string) {
    this._tokenLocation = value;
  }
  public resetTokenLocation() {
    this._tokenLocation = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenLocationInput() {
    return this._tokenLocation;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef {
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_api_key_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_api_key_secret_ref}
  */
  readonly secretApiKeySecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_api_key_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToTerraform(struct!.secretApiKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_api_key_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefToHclTerraform(struct!.secretApiKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretApiKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretApiKeySecretRef = this._secretApiKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretApiKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretApiKeySecretRef.internalValue = value.secretApiKeySecretRef;
    }
  }

  // secret_api_key_secret_ref - computed: false, optional: true, required: false
  private _secretApiKeySecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRefOutputReference(this, "secret_api_key_secret_ref");
  public get secretApiKeySecretRef() {
    return this._secretApiKeySecretRef;
  }
  public putSecretApiKeySecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefSecretApiKeySecretRef) {
    this._secretApiKeySecretRef.internalValue = value;
  }
  public resetSecretApiKeySecretRef() {
    this._secretApiKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretApiKeySecretRefInput() {
    return this._secretApiKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth {
  /**
  * IBM Container-based auth with IAM Trusted Profile.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#container_auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#container_auth}
  */
  readonly containerAuth?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToTerraform(struct!.containerAuth),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthToHclTerraform(struct!.containerAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerAuth = this._containerAuth?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerAuth.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerAuth.internalValue = value.containerAuth;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // container_auth - computed: false, optional: true, required: false
  private _containerAuth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuthOutputReference(this, "container_auth");
  public get containerAuth() {
    return this._containerAuth;
  }
  public putContainerAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthContainerAuth) {
    this._containerAuth.internalValue = value;
  }
  public resetContainerAuth() {
    this._containerAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerAuthInput() {
    return this._containerAuth.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbm {
  /**
  * Auth configures how secret-manager authenticates with the IBM secrets manager.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth;
  /**
  * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_url}
  */
  readonly serviceUrl?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthToTerraform(struct!.auth),
    service_url: cdktf.stringToTerraform(struct!.serviceUrl),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth",
    },
    service_url: {
      value: cdktf.stringToHclTerraform(struct!.serviceUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._serviceUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceUrl = this._serviceUrl;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbm | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._serviceUrl = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._serviceUrl = value.serviceUrl;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderIbmAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // service_url - computed: false, optional: true, required: false
  private _serviceUrl?: string; 
  public get serviceUrl() {
    return this.getStringAttribute('service_url');
  }
  public set serviceUrl(value: string) {
    this._serviceUrl = value;
  }
  public resetServiceUrl() {
    this._serviceUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceUrlInput() {
    return this._serviceUrl;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_secret DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_secret}
  */
  readonly clientSecret: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToTerraform(struct!.clientId),
    client_secret: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToTerraform(struct!.clientSecret),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdToHclTerraform(struct!.clientId),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId",
    },
    client_secret: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretToHclTerraform(struct!.clientSecret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId?.internalValue;
    }
    if (this._clientSecret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId.internalValue = undefined;
      this._clientSecret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId.internalValue = value.clientId;
      this._clientSecret.internalValue = value.clientSecret;
    }
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientIdOutputReference(this, "client_id");
  public get clientId() {
    return this._clientId;
  }
  public putClientId(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientId) {
    this._clientId.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId.internalValue;
  }

  // client_secret - computed: false, optional: false, required: true
  private _clientSecret = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecretOutputReference(this, "client_secret");
  public get clientSecret() {
    return this._clientSecret;
  }
  public putClientSecret(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsClientSecret) {
    this._clientSecret.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#universal_auth_credentials DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#universal_auth_credentials}
  */
  readonly universalAuthCredentials?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    universal_auth_credentials: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToTerraform(struct!.universalAuthCredentials),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    universal_auth_credentials: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsToHclTerraform(struct!.universalAuthCredentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._universalAuthCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.universalAuthCredentials = this._universalAuthCredentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._universalAuthCredentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._universalAuthCredentials.internalValue = value.universalAuthCredentials;
    }
  }

  // universal_auth_credentials - computed: false, optional: true, required: false
  private _universalAuthCredentials = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentialsOutputReference(this, "universal_auth_credentials");
  public get universalAuthCredentials() {
    return this._universalAuthCredentials;
  }
  public putUniversalAuthCredentials(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthUniversalAuthCredentials) {
    this._universalAuthCredentials.internalValue = value;
  }
  public resetUniversalAuthCredentials() {
    this._universalAuthCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get universalAuthCredentialsInput() {
    return this._universalAuthCredentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#environment_slug DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#environment_slug}
  */
  readonly environmentSlug: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project_slug DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project_slug}
  */
  readonly projectSlug: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#recursive DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#recursive}
  */
  readonly recursive?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secrets_path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secrets_path}
  */
  readonly secretsPath?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    environment_slug: cdktf.stringToTerraform(struct!.environmentSlug),
    project_slug: cdktf.stringToTerraform(struct!.projectSlug),
    recursive: cdktf.booleanToTerraform(struct!.recursive),
    secrets_path: cdktf.stringToTerraform(struct!.secretsPath),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    environment_slug: {
      value: cdktf.stringToHclTerraform(struct!.environmentSlug),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_slug: {
      value: cdktf.stringToHclTerraform(struct!.projectSlug),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    recursive: {
      value: cdktf.booleanToHclTerraform(struct!.recursive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secrets_path: {
      value: cdktf.stringToHclTerraform(struct!.secretsPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._environmentSlug !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentSlug = this._environmentSlug;
    }
    if (this._projectSlug !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectSlug = this._projectSlug;
    }
    if (this._recursive !== undefined) {
      hasAnyValues = true;
      internalValueResult.recursive = this._recursive;
    }
    if (this._secretsPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsPath = this._secretsPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._environmentSlug = undefined;
      this._projectSlug = undefined;
      this._recursive = undefined;
      this._secretsPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._environmentSlug = value.environmentSlug;
      this._projectSlug = value.projectSlug;
      this._recursive = value.recursive;
      this._secretsPath = value.secretsPath;
    }
  }

  // environment_slug - computed: false, optional: false, required: true
  private _environmentSlug?: string; 
  public get environmentSlug() {
    return this.getStringAttribute('environment_slug');
  }
  public set environmentSlug(value: string) {
    this._environmentSlug = value;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentSlugInput() {
    return this._environmentSlug;
  }

  // project_slug - computed: false, optional: false, required: true
  private _projectSlug?: string; 
  public get projectSlug() {
    return this.getStringAttribute('project_slug');
  }
  public set projectSlug(value: string) {
    this._projectSlug = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectSlugInput() {
    return this._projectSlug;
  }

  // recursive - computed: false, optional: true, required: false
  private _recursive?: boolean | cdktf.IResolvable; 
  public get recursive() {
    return this.getBooleanAttribute('recursive');
  }
  public set recursive(value: boolean | cdktf.IResolvable) {
    this._recursive = value;
  }
  public resetRecursive() {
    this._recursive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get recursiveInput() {
    return this._recursive;
  }

  // secrets_path - computed: false, optional: true, required: false
  private _secretsPath?: string; 
  public get secretsPath() {
    return this.getStringAttribute('secrets_path');
  }
  public set secretsPath(value: string) {
    this._secretsPath = value;
  }
  public resetSecretsPath() {
    this._secretsPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsPathInput() {
    return this._secretsPath;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisical {
  /**
  * Auth configures how the Operator authenticates with the Infisical API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#host_api DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#host_api}
  */
  readonly hostApi?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secrets_scope DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secrets_scope}
  */
  readonly secretsScope: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToTerraform(struct!.auth),
    host_api: cdktf.stringToTerraform(struct!.hostApi),
    secrets_scope: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToTerraform(struct!.secretsScope),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth",
    },
    host_api: {
      value: cdktf.stringToHclTerraform(struct!.hostApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secrets_scope: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeToHclTerraform(struct!.secretsScope),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._hostApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostApi = this._hostApi;
    }
    if (this._secretsScope?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretsScope = this._secretsScope?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisical | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._hostApi = undefined;
      this._secretsScope.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._hostApi = value.hostApi;
      this._secretsScope.internalValue = value.secretsScope;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // host_api - computed: false, optional: true, required: false
  private _hostApi?: string; 
  public get hostApi() {
    return this.getStringAttribute('host_api');
  }
  public set hostApi(value: string) {
    this._hostApi = value;
  }
  public resetHostApi() {
    this._hostApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostApiInput() {
    return this._hostApi;
  }

  // secrets_scope - computed: false, optional: false, required: true
  private _secretsScope = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScopeOutputReference(this, "secrets_scope");
  public get secretsScope() {
    return this._secretsScope;
  }
  public putSecretsScope(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderInfisicalSecretsScope) {
    this._secretsScope.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretsScopeInput() {
    return this._secretsScope.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurity {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth_ref}
  */
  readonly authRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#folder_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#folder_id}
  */
  readonly folderId: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToTerraform(struct!.authRef),
    folder_id: cdktf.stringToTerraform(struct!.folderId),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefToHclTerraform(struct!.authRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef",
    },
    folder_id: {
      value: cdktf.stringToHclTerraform(struct!.folderId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authRef = this._authRef?.internalValue;
    }
    if (this._folderId !== undefined) {
      hasAnyValues = true;
      internalValueResult.folderId = this._folderId;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurity | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authRef.internalValue = undefined;
      this._folderId = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authRef.internalValue = value.authRef;
      this._folderId = value.folderId;
    }
  }

  // auth_ref - computed: false, optional: false, required: true
  private _authRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRefOutputReference(this, "auth_ref");
  public get authRef() {
    return this._authRef;
  }
  public putAuthRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKeepersecurityAuthRef) {
    this._authRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authRefInput() {
    return this._authRef.internalValue;
  }

  // folder_id - computed: false, optional: false, required: true
  private _folderId?: string; 
  public get folderId() {
    return this.getStringAttribute('folder_id');
  }
  public set folderId(value: string) {
    this._folderId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get folderIdInput() {
    return this._folderId;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_cert DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_cert}
  */
  readonly clientCert?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_key}
  */
  readonly clientKey?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_cert: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToTerraform(struct!.clientCert),
    client_key: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToTerraform(struct!.clientKey),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_cert: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertToHclTerraform(struct!.clientCert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert",
    },
    client_key: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyToHclTerraform(struct!.clientKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCert = this._clientCert?.internalValue;
    }
    if (this._clientKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientKey = this._clientKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = undefined;
      this._clientKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = value.clientCert;
      this._clientKey.internalValue = value.clientKey;
    }
  }

  // client_cert - computed: false, optional: true, required: false
  private _clientCert = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCertOutputReference(this, "client_cert");
  public get clientCert() {
    return this._clientCert;
  }
  public putClientCert(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientCert) {
    this._clientCert.internalValue = value;
  }
  public resetClientCert() {
    this._clientCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertInput() {
    return this._clientCert.internalValue;
  }

  // client_key - computed: false, optional: true, required: false
  private _clientKey = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKeyOutputReference(this, "client_key");
  public get clientKey() {
    return this._clientKey;
  }
  public putClientKey(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertClientKey) {
    this._clientKey.internalValue = value;
  }
  public resetClientKey() {
    this._clientKey.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientKeyInput() {
    return this._clientKey.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#bearer_token DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#bearer_token}
  */
  readonly bearerToken?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    bearer_token: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToTerraform(struct!.bearerToken),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    bearer_token: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenToHclTerraform(struct!.bearerToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._bearerToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.bearerToken = this._bearerToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._bearerToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._bearerToken.internalValue = value.bearerToken;
    }
  }

  // bearer_token - computed: false, optional: true, required: false
  private _bearerToken = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerTokenOutputReference(this, "bearer_token");
  public get bearerToken() {
    return this._bearerToken;
  }
  public putBearerToken(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenBearerToken) {
    this._bearerToken.internalValue = value;
  }
  public resetBearerToken() {
    this._bearerToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bearerTokenInput() {
    return this._bearerToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth {
  /**
  * has both clientCert and clientKey as secretKeySelector
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#cert DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#cert}
  */
  readonly cert?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert;
  /**
  * points to a service account that should be used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount;
  /**
  * use static token to authenticate with
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#token DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#token}
  */
  readonly token?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToTerraform(struct!.cert),
    service_account: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToTerraform(struct!.serviceAccount),
    token: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToTerraform(struct!.token),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertToHclTerraform(struct!.cert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert",
    },
    service_account: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount",
    },
    token: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenToHclTerraform(struct!.token),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    if (this._token?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cert.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
      this._token.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cert.internalValue = value.cert;
      this._serviceAccount.internalValue = value.serviceAccount;
      this._token.internalValue = value.token;
    }
  }

  // cert - computed: false, optional: true, required: false
  private _cert = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCertOutputReference(this, "cert");
  public get cert() {
    return this._cert;
  }
  public putCert(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthCert) {
    this._cert.internalValue = value;
  }
  public resetCert() {
    this._cert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthTokenOutputReference(this, "token");
  public get token() {
    return this._token;
  }
  public putToken(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToken) {
    this._token.internalValue = value;
  }
  public resetToken() {
    this._token.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer {
  /**
  * CABundle is a base64-encoded CA certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider;
  /**
  * configures the Kubernetes server Address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#url}
  */
  readonly url?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToTerraform(struct!.caProvider),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._url = value.url;
    }
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetes {
  /**
  * Auth configures how secret-manager authenticates with a Kubernetes instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth;
  /**
  * A reference to a secret that contains the auth information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth_ref}
  */
  readonly authRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef;
  /**
  * Remote namespace to fetch the secrets from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#remote_namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#remote_namespace}
  */
  readonly remoteNamespace?: string;
  /**
  * configures the Kubernetes server Address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#server DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#server}
  */
  readonly server?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToTerraform(struct!.auth),
    auth_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToTerraform(struct!.authRef),
    remote_namespace: cdktf.stringToTerraform(struct!.remoteNamespace),
    server: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToTerraform(struct!.server),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth",
    },
    auth_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefToHclTerraform(struct!.authRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef",
    },
    remote_namespace: {
      value: cdktf.stringToHclTerraform(struct!.remoteNamespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerToHclTerraform(struct!.server),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._authRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authRef = this._authRef?.internalValue;
    }
    if (this._remoteNamespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteNamespace = this._remoteNamespace;
    }
    if (this._server?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._authRef.internalValue = undefined;
      this._remoteNamespace = undefined;
      this._server.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._authRef.internalValue = value.authRef;
      this._remoteNamespace = value.remoteNamespace;
      this._server.internalValue = value.server;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // auth_ref - computed: false, optional: true, required: false
  private _authRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRefOutputReference(this, "auth_ref");
  public get authRef() {
    return this._authRef;
  }
  public putAuthRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesAuthRef) {
    this._authRef.internalValue = value;
  }
  public resetAuthRef() {
    this._authRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authRefInput() {
    return this._authRef.internalValue;
  }

  // remote_namespace - computed: false, optional: true, required: false
  private _remoteNamespace?: string; 
  public get remoteNamespace() {
    return this.getStringAttribute('remote_namespace');
  }
  public set remoteNamespace(value: string) {
    this._remoteNamespace = value;
  }
  public resetRemoteNamespace() {
    this._remoteNamespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteNamespaceInput() {
    return this._remoteNamespace;
  }

  // server - computed: false, optional: true, required: false
  private _server = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServerOutputReference(this, "server");
  public get server() {
    return this._server;
  }
  public putServer(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderKubernetesServer) {
    this._server.internalValue = value;
  }
  public resetServer() {
    this._server.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth {
  /**
  * OnboardbaseAPIKey is the APIKey generated by an admin account. It is used to recognize and authorize access to a project and environment within onboardbase
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_key_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_key_ref}
  */
  readonly apiKeyRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef;
  /**
  * OnboardbasePasscode is the passcode attached to the API Key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#passcode_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#passcode_ref}
  */
  readonly passcodeRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToTerraform(struct!.apiKeyRef),
    passcode_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToTerraform(struct!.passcodeRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefToHclTerraform(struct!.apiKeyRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef",
    },
    passcode_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefToHclTerraform(struct!.passcodeRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKeyRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKeyRef = this._apiKeyRef?.internalValue;
    }
    if (this._passcodeRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passcodeRef = this._passcodeRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKeyRef.internalValue = undefined;
      this._passcodeRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKeyRef.internalValue = value.apiKeyRef;
      this._passcodeRef.internalValue = value.passcodeRef;
    }
  }

  // api_key_ref - computed: false, optional: false, required: true
  private _apiKeyRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRefOutputReference(this, "api_key_ref");
  public get apiKeyRef() {
    return this._apiKeyRef;
  }
  public putApiKeyRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthApiKeyRef) {
    this._apiKeyRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyRefInput() {
    return this._apiKeyRef.internalValue;
  }

  // passcode_ref - computed: false, optional: false, required: true
  private _passcodeRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRefOutputReference(this, "passcode_ref");
  public get passcodeRef() {
    return this._passcodeRef;
  }
  public putPasscodeRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthPasscodeRef) {
    this._passcodeRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passcodeRefInput() {
    return this._passcodeRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbase {
  /**
  * APIHost use this to configure the host url for the API for selfhosted installation, default is https://public.onboardbase.com/api/v1/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_host DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_host}
  */
  readonly apiHost: string;
  /**
  * Auth configures how the Operator authenticates with the Onboardbase API
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth;
  /**
  * Environment is the name of an environmnent within a project to pull the secrets from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#environment DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#environment}
  */
  readonly environment: string;
  /**
  * Project is an onboardbase project that the secrets should be pulled from
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project}
  */
  readonly project: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_host: cdktf.stringToTerraform(struct!.apiHost),
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToTerraform(struct!.auth),
    environment: cdktf.stringToTerraform(struct!.environment),
    project: cdktf.stringToTerraform(struct!.project),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_host: {
      value: cdktf.stringToHclTerraform(struct!.apiHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiHost = this._apiHost;
    }
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbase | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiHost = undefined;
      this._auth.internalValue = undefined;
      this._environment = undefined;
      this._project = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiHost = value.apiHost;
      this._auth.internalValue = value.auth;
      this._environment = value.environment;
      this._project = value.project;
    }
  }

  // api_host - computed: false, optional: false, required: true
  private _apiHost?: string; 
  public get apiHost() {
    return this.getStringAttribute('api_host');
  }
  public set apiHost(value: string) {
    this._apiHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get apiHostInput() {
    return this._apiHost;
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnboardbaseAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // environment - computed: false, optional: false, required: true
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // project - computed: false, optional: false, required: true
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef {
  /**
  * The ConnectToken is used for authentication to a 1Password Connect Server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#connect_token_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#connect_token_secret_ref}
  */
  readonly connectTokenSecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connect_token_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToTerraform(struct!.connectTokenSecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connect_token_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefToHclTerraform(struct!.connectTokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectTokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectTokenSecretRef = this._connectTokenSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectTokenSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectTokenSecretRef.internalValue = value.connectTokenSecretRef;
    }
  }

  // connect_token_secret_ref - computed: false, optional: false, required: true
  private _connectTokenSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRefOutputReference(this, "connect_token_secret_ref");
  public get connectTokenSecretRef() {
    return this._connectTokenSecretRef;
  }
  public putConnectTokenSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef) {
    this._connectTokenSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectTokenSecretRefInput() {
    return this._connectTokenSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth {
  /**
  * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepassword {
  /**
  * Auth defines the information necessary to authenticate against OnePassword Connect Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth;
  /**
  * ConnectHost defines the OnePassword Connect Server to connect to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#connect_host DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#connect_host}
  */
  readonly connectHost: string;
  /**
  * Vaults defines which OnePassword vaults to search in which order
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#vaults DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#vaults}
  */
  readonly vaults: { [key: string]: string };
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToTerraform(struct!.auth),
    connect_host: cdktf.stringToTerraform(struct!.connectHost),
    vaults: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.vaults),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth",
    },
    connect_host: {
      value: cdktf.stringToHclTerraform(struct!.connectHost),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vaults: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.vaults),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectHost !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectHost = this._connectHost;
    }
    if (this._vaults !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaults = this._vaults;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectHost = undefined;
      this._vaults = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectHost = value.connectHost;
      this._vaults = value.vaults;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOnepasswordAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connect_host - computed: false, optional: false, required: true
  private _connectHost?: string; 
  public get connectHost() {
    return this.getStringAttribute('connect_host');
  }
  public set connectHost(value: string) {
    this._connectHost = value;
  }
  // Temporarily expose input value. Use with caution.
  public get connectHostInput() {
    return this._connectHost;
  }

  // vaults - computed: false, optional: false, required: true
  private _vaults?: { [key: string]: string }; 
  public get vaults() {
    return this.getStringMapAttribute('vaults');
  }
  public set vaults(value: { [key: string]: string }) {
    this._vaults = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultsInput() {
    return this._vaults;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef {
  /**
  * Fingerprint is the fingerprint of the API private key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#fingerprint DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#fingerprint}
  */
  readonly fingerprint: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint;
  /**
  * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#privatekey DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#privatekey}
  */
  readonly privatekey: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fingerprint: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToTerraform(struct!.fingerprint),
    privatekey: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToTerraform(struct!.privatekey),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fingerprint: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintToHclTerraform(struct!.fingerprint),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint",
    },
    privatekey: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyToHclTerraform(struct!.privatekey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fingerprint?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fingerprint = this._fingerprint?.internalValue;
    }
    if (this._privatekey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privatekey = this._privatekey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fingerprint.internalValue = undefined;
      this._privatekey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fingerprint.internalValue = value.fingerprint;
      this._privatekey.internalValue = value.privatekey;
    }
  }

  // fingerprint - computed: false, optional: false, required: true
  private _fingerprint = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprintOutputReference(this, "fingerprint");
  public get fingerprint() {
    return this._fingerprint;
  }
  public putFingerprint(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefFingerprint) {
    this._fingerprint.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fingerprintInput() {
    return this._fingerprint.internalValue;
  }

  // privatekey - computed: false, optional: false, required: true
  private _privatekey = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekeyOutputReference(this, "privatekey");
  public get privatekey() {
    return this._privatekey;
  }
  public putPrivatekey(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefPrivatekey) {
    this._privatekey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privatekeyInput() {
    return this._privatekey.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth {
  /**
  * SecretRef to pass through sensitive information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef;
  /**
  * Tenancy is the tenancy OCID where user is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#tenancy DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#tenancy}
  */
  readonly tenancy: string;
  /**
  * User is an access OCID specific to the account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#user DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#user}
  */
  readonly user: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToTerraform(struct!.secretRef),
    tenancy: cdktf.stringToTerraform(struct!.tenancy),
    user: cdktf.stringToTerraform(struct!.user),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef",
    },
    tenancy: {
      value: cdktf.stringToHclTerraform(struct!.tenancy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user: {
      value: cdktf.stringToHclTerraform(struct!.user),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._tenancy !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenancy = this._tenancy;
    }
    if (this._user !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._tenancy = undefined;
      this._user = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._tenancy = value.tenancy;
      this._user = value.user;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // tenancy - computed: false, optional: false, required: true
  private _tenancy?: string; 
  public get tenancy() {
    return this.getStringAttribute('tenancy');
  }
  public set tenancy(value: string) {
    this._tenancy = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenancyInput() {
    return this._tenancy;
  }

  // user - computed: false, optional: false, required: true
  private _user?: string; 
  public get user() {
    return this.getStringAttribute('user');
  }
  public set user(value: string) {
    this._user = value;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracle {
  /**
  * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth;
  /**
  * Compartment is the vault compartment OCID. Required for PushSecret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#compartment DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#compartment}
  */
  readonly compartment?: string;
  /**
  * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#encryption_key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#encryption_key}
  */
  readonly encryptionKey?: string;
  /**
  * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#principal_type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#principal_type}
  */
  readonly principalType?: string;
  /**
  * Region is the region where vault is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#region}
  */
  readonly region: string;
  /**
  * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef;
  /**
  * Vault is the vault's OCID of the specific vault where secret is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#vault DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#vault}
  */
  readonly vault: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthToTerraform(struct!.auth),
    compartment: cdktf.stringToTerraform(struct!.compartment),
    encryption_key: cdktf.stringToTerraform(struct!.encryptionKey),
    principal_type: cdktf.stringToTerraform(struct!.principalType),
    region: cdktf.stringToTerraform(struct!.region),
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToTerraform(struct!.serviceAccountRef),
    vault: cdktf.stringToTerraform(struct!.vault),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth",
    },
    compartment: {
      value: cdktf.stringToHclTerraform(struct!.compartment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encryption_key: {
      value: cdktf.stringToHclTerraform(struct!.encryptionKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    principal_type: {
      value: cdktf.stringToHclTerraform(struct!.principalType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef",
    },
    vault: {
      value: cdktf.stringToHclTerraform(struct!.vault),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._compartment !== undefined) {
      hasAnyValues = true;
      internalValueResult.compartment = this._compartment;
    }
    if (this._encryptionKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.encryptionKey = this._encryptionKey;
    }
    if (this._principalType !== undefined) {
      hasAnyValues = true;
      internalValueResult.principalType = this._principalType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    if (this._vault !== undefined) {
      hasAnyValues = true;
      internalValueResult.vault = this._vault;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracle | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._compartment = undefined;
      this._encryptionKey = undefined;
      this._principalType = undefined;
      this._region = undefined;
      this._serviceAccountRef.internalValue = undefined;
      this._vault = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._compartment = value.compartment;
      this._encryptionKey = value.encryptionKey;
      this._principalType = value.principalType;
      this._region = value.region;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
      this._vault = value.vault;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // compartment - computed: false, optional: true, required: false
  private _compartment?: string; 
  public get compartment() {
    return this.getStringAttribute('compartment');
  }
  public set compartment(value: string) {
    this._compartment = value;
  }
  public resetCompartment() {
    this._compartment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compartmentInput() {
    return this._compartment;
  }

  // encryption_key - computed: false, optional: true, required: false
  private _encryptionKey?: string; 
  public get encryptionKey() {
    return this.getStringAttribute('encryption_key');
  }
  public set encryptionKey(value: string) {
    this._encryptionKey = value;
  }
  public resetEncryptionKey() {
    this._encryptionKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encryptionKeyInput() {
    return this._encryptionKey;
  }

  // principal_type - computed: false, optional: true, required: false
  private _principalType?: string; 
  public get principalType() {
    return this.getStringAttribute('principal_type');
  }
  public set principalType(value: string) {
    this._principalType = value;
  }
  public resetPrincipalType() {
    this._principalType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get principalTypeInput() {
    return this._principalType;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderOracleServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }

  // vault - computed: false, optional: false, required: true
  private _vault?: string; 
  public get vault() {
    return this.getStringAttribute('vault');
  }
  public set vault(value: string) {
    this._vault = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultInput() {
    return this._vault;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth {
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#password_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#password_secret_ref}
  */
  readonly passwordSecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#private_key_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#private_key_secret_ref}
  */
  readonly privateKeySecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToTerraform(struct!.passwordSecretRef),
    private_key_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToTerraform(struct!.privateKeySecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefToHclTerraform(struct!.passwordSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef",
    },
    private_key_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefToHclTerraform(struct!.privateKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._passwordSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.passwordSecretRef = this._passwordSecretRef?.internalValue;
    }
    if (this._privateKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.privateKeySecretRef = this._privateKeySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._passwordSecretRef.internalValue = undefined;
      this._privateKeySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._passwordSecretRef.internalValue = value.passwordSecretRef;
      this._privateKeySecretRef.internalValue = value.privateKeySecretRef;
    }
  }

  // password_secret_ref - computed: false, optional: false, required: true
  private _passwordSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRefOutputReference(this, "password_secret_ref");
  public get passwordSecretRef() {
    return this._passwordSecretRef;
  }
  public putPasswordSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPasswordSecretRef) {
    this._passwordSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordSecretRefInput() {
    return this._passwordSecretRef.internalValue;
  }

  // private_key_secret_ref - computed: false, optional: false, required: true
  private _privateKeySecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRefOutputReference(this, "private_key_secret_ref");
  public get privateKeySecretRef() {
    return this._privateKeySecretRef;
  }
  public putPrivateKeySecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthPrivateKeySecretRef) {
    this._privateKeySecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privateKeySecretRefInput() {
    return this._privateKeySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassbolt {
  /**
  * Auth defines the information necessary to authenticate against Passbolt Server
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth;
  /**
  * Host defines the Passbolt Server to connect to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#host DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#host}
  */
  readonly host: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToTerraform(struct!.auth),
    host: cdktf.stringToTerraform(struct!.host),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassbolt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._host = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._host = value.host;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassboltAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef {
  /**
  * Username / Password is used for authentication.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#credentials DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#credentials}
  */
  readonly credentials?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToTerraform(struct!.credentials),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsToHclTerraform(struct!.credentials),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentials = this._credentials?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentials.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentials.internalValue = value.credentials;
    }
  }

  // credentials - computed: false, optional: true, required: false
  private _credentials = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentialsOutputReference(this, "credentials");
  public get credentials() {
    return this._credentials;
  }
  public putCredentials(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefCredentials) {
    this._credentials.internalValue = value;
  }
  public resetCredentials() {
    this._credentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsInput() {
    return this._credentials.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepot {
  /**
  * Auth configures how secret-manager authenticates with a Password Depot instance.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth;
  /**
  * Database to use as source
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#database DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#database}
  */
  readonly database: string;
  /**
  * URL configures the Password Depot instance URL.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#host DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#host}
  */
  readonly host: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToTerraform(struct!.auth),
    database: cdktf.stringToTerraform(struct!.database),
    host: cdktf.stringToTerraform(struct!.host),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepot | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._database = undefined;
      this._host = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._database = value.database;
      this._host = value.host;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPassworddepotAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef {
  /**
  * The AccessToken is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_token DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_token}
  */
  readonly accessToken: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToTerraform(struct!.accessToken),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenToHclTerraform(struct!.accessToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = value.accessToken;
    }
  }

  // access_token - computed: false, optional: false, required: true
  private _accessToken = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessTokenOutputReference(this, "access_token");
  public get accessToken() {
    return this._accessToken;
  }
  public putAccessToken(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefAccessToken) {
    this._accessToken.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth {
  /**
  * PreviderAuthSecretRef holds secret references for Previder Vault credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPrevider {
  /**
  * PreviderAuth contains a secretRef for credentials.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#base_uri DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#base_uri}
  */
  readonly baseUri?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToTerraform(struct!.auth),
    base_uri: cdktf.stringToTerraform(struct!.baseUri),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth",
    },
    base_uri: {
      value: cdktf.stringToHclTerraform(struct!.baseUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._baseUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseUri = this._baseUri;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPrevider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._baseUri = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._baseUri = value.baseUri;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPreviderAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // base_uri - computed: false, optional: true, required: false
  private _baseUri?: string; 
  public get baseUri() {
    return this.getStringAttribute('base_uri');
  }
  public set baseUri(value: string) {
    this._baseUri = value;
  }
  public resetBaseUri() {
    this._baseUri = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseUriInput() {
    return this._baseUri;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken {
  /**
  * SecretRef is a reference to a secret containing the Pulumi API token.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumi {
  /**
  * AccessToken is the access tokens to sign in to the Pulumi Cloud Console.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_token DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_token}
  */
  readonly accessToken: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken;
  /**
  * APIURL is the URL of the Pulumi API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Environment are YAML documents composed of static key-value pairs, programmatic expressions, dynamically retrieved values from supported providers including all major clouds, and other Pulumi ESC environments. To create a new environment, visit https://www.pulumi.com/docs/esc/environments/ for more information.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#environment DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#environment}
  */
  readonly environment: string;
  /**
  * Organization are a space to collaborate on shared projects and stacks. To create a new organization, visit https://app.pulumi.com/ and click 'New Organization'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#organization DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#organization}
  */
  readonly organization: string;
  /**
  * Project is the name of the Pulumi ESC project the environment belongs to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project}
  */
  readonly project: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_token: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToTerraform(struct!.accessToken),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    environment: cdktf.stringToTerraform(struct!.environment),
    organization: cdktf.stringToTerraform(struct!.organization),
    project: cdktf.stringToTerraform(struct!.project),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_token: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenToHclTerraform(struct!.accessToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    organization: {
      value: cdktf.stringToHclTerraform(struct!.organization),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project: {
      value: cdktf.stringToHclTerraform(struct!.project),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessToken = this._accessToken?.internalValue;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._organization !== undefined) {
      hasAnyValues = true;
      internalValueResult.organization = this._organization;
    }
    if (this._project !== undefined) {
      hasAnyValues = true;
      internalValueResult.project = this._project;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = undefined;
      this._apiUrl = undefined;
      this._environment = undefined;
      this._organization = undefined;
      this._project = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessToken.internalValue = value.accessToken;
      this._apiUrl = value.apiUrl;
      this._environment = value.environment;
      this._organization = value.organization;
      this._project = value.project;
    }
  }

  // access_token - computed: false, optional: false, required: true
  private _accessToken = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessTokenOutputReference(this, "access_token");
  public get accessToken() {
    return this._accessToken;
  }
  public putAccessToken(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderPulumiAccessToken) {
    this._accessToken.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessTokenInput() {
    return this._accessToken.internalValue;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // environment - computed: false, optional: false, required: true
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // organization - computed: false, optional: false, required: true
  private _organization?: string; 
  public get organization() {
    return this.getStringAttribute('organization');
  }
  public set organization(value: string) {
    this._organization = value;
  }
  // Temporarily expose input value. Use with caution.
  public get organizationInput() {
    return this._organization;
  }

  // project - computed: false, optional: false, required: true
  private _project?: string; 
  public get project() {
    return this.getStringAttribute('project');
  }
  public set project(value: string) {
    this._project = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectInput() {
    return this._project;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeySecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScaleway {
  /**
  * AccessKey is the non-secret part of the api key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_key}
  */
  readonly accessKey: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey;
  /**
  * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#api_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#api_url}
  */
  readonly apiUrl?: string;
  /**
  * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#project_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#project_id}
  */
  readonly projectId: string;
  /**
  * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#region}
  */
  readonly region: string;
  /**
  * SecretKey is the non-secret part of the api key.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_key}
  */
  readonly secretKey: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToTerraform(struct!.accessKey),
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    project_id: cdktf.stringToTerraform(struct!.projectId),
    region: cdktf.stringToTerraform(struct!.region),
    secret_key: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToTerraform(struct!.secretKey),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyToHclTerraform(struct!.accessKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey",
    },
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    project_id: {
      value: cdktf.stringToHclTerraform(struct!.projectId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_key: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyToHclTerraform(struct!.secretKey),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKey = this._accessKey?.internalValue;
    }
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._projectId !== undefined) {
      hasAnyValues = true;
      internalValueResult.projectId = this._projectId;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secretKey?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretKey = this._secretKey?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScaleway | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKey.internalValue = undefined;
      this._apiUrl = undefined;
      this._projectId = undefined;
      this._region = undefined;
      this._secretKey.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKey.internalValue = value.accessKey;
      this._apiUrl = value.apiUrl;
      this._projectId = value.projectId;
      this._region = value.region;
      this._secretKey.internalValue = value.secretKey;
    }
  }

  // access_key - computed: false, optional: false, required: true
  private _accessKey = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKeyOutputReference(this, "access_key");
  public get accessKey() {
    return this._accessKey;
  }
  public putAccessKey(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewayAccessKey) {
    this._accessKey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyInput() {
    return this._accessKey.internalValue;
  }

  // api_url - computed: false, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // project_id - computed: false, optional: false, required: true
  private _projectId?: string; 
  public get projectId() {
    return this.getStringAttribute('project_id');
  }
  public set projectId(value: string) {
    this._projectId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get projectIdInput() {
    return this._projectId;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secret_key - computed: false, optional: false, required: true
  private _secretKey = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKeyOutputReference(this, "secret_key");
  public get secretKey() {
    return this._secretKey;
  }
  public putSecretKey(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderScalewaySecretKey) {
    this._secretKey.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretKeyInput() {
    return this._secretKey.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername {
  /**
  * SecretRef references a key in a secret that will be used as value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef;
  /**
  * Value can be specified directly to set a value without using a secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#value DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToTerraform(struct!.secretRef),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._secretRef.internalValue = value.secretRef;
      this._value = value.value;
    }
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserver {
  /**
  * Password is the secret server account password.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#password DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#password}
  */
  readonly password: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword;
  /**
  * ServerURL URL to your secret server installation
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#server_url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#server_url}
  */
  readonly serverUrl: string;
  /**
  * Username is the secret server account username.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#username}
  */
  readonly username: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    password: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToTerraform(struct!.password),
    server_url: cdktf.stringToTerraform(struct!.serverUrl),
    username: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    password: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordToHclTerraform(struct!.password),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword",
    },
    server_url: {
      value: cdktf.stringToHclTerraform(struct!.serverUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameToHclTerraform(struct!.username),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._password?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password?.internalValue;
    }
    if (this._serverUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverUrl = this._serverUrl;
    }
    if (this._username?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserver | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._password.internalValue = undefined;
      this._serverUrl = undefined;
      this._username.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._password.internalValue = value.password;
      this._serverUrl = value.serverUrl;
      this._username.internalValue = value.username;
    }
  }

  // password - computed: false, optional: false, required: true
  private _password = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPasswordOutputReference(this, "password");
  public get password() {
    return this._password;
  }
  public putPassword(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverPassword) {
    this._password.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password.internalValue;
  }

  // server_url - computed: false, optional: false, required: true
  private _serverUrl?: string; 
  public get serverUrl() {
    return this.getStringAttribute('server_url');
  }
  public set serverUrl(value: string) {
    this._serverUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverUrlInput() {
    return this._serverUrl;
  }

  // username - computed: false, optional: false, required: true
  private _username = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsernameOutputReference(this, "username");
  public get username() {
    return this._username;
  }
  public putUsername(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSecretserverUsername) {
    this._username.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_id}
  */
  readonly clientId: string;
  /**
  * A reference to a specific 'key' within a Secret resource, In some instances, 'key' is a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_secret_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_secret_secret_ref}
  */
  readonly clientSecretSecretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToTerraform(struct!.clientSecretSecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefToHclTerraform(struct!.clientSecretSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecretSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecretSecretRef = this._clientSecretSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientId = undefined;
      this._clientSecretSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientId = value.clientId;
      this._clientSecretSecretRef.internalValue = value.clientSecretSecretRef;
    }
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret_secret_ref - computed: false, optional: false, required: true
  private _clientSecretSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRefOutputReference(this, "client_secret_secret_ref");
  public get clientSecretSecretRef() {
    return this._clientSecretSecretRef;
  }
  public putClientSecretSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthClientSecretSecretRef) {
    this._clientSecretSecretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretSecretRefInput() {
    return this._clientSecretSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhasegura {
  /**
  * Auth defines parameters to authenticate in senhasegura
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth;
  /**
  * IgnoreSslCertificate defines if SSL certificate must be ignored
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ignore_ssl_certificate DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ignore_ssl_certificate}
  */
  readonly ignoreSslCertificate?: boolean | cdktf.IResolvable;
  /**
  * Module defines which senhasegura module should be used to get secrets
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#module DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#module}
  */
  readonly module: string;
  /**
  * URL of senhasegura
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#url DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#url}
  */
  readonly url: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToTerraform(struct!.auth),
    ignore_ssl_certificate: cdktf.booleanToTerraform(struct!.ignoreSslCertificate),
    module: cdktf.stringToTerraform(struct!.module),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth",
    },
    ignore_ssl_certificate: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreSslCertificate),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    module: {
      value: cdktf.stringToHclTerraform(struct!.module),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._ignoreSslCertificate !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreSslCertificate = this._ignoreSslCertificate;
    }
    if (this._module !== undefined) {
      hasAnyValues = true;
      internalValueResult.module = this._module;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhasegura | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._ignoreSslCertificate = undefined;
      this._module = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._ignoreSslCertificate = value.ignoreSslCertificate;
      this._module = value.module;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderSenhaseguraAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // ignore_ssl_certificate - computed: false, optional: true, required: false
  private _ignoreSslCertificate?: boolean | cdktf.IResolvable; 
  public get ignoreSslCertificate() {
    return this.getBooleanAttribute('ignore_ssl_certificate');
  }
  public set ignoreSslCertificate(value: boolean | cdktf.IResolvable) {
    this._ignoreSslCertificate = value;
  }
  public resetIgnoreSslCertificate() {
    this._ignoreSslCertificate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreSslCertificateInput() {
    return this._ignoreSslCertificate;
  }

  // module - computed: false, optional: false, required: true
  private _module?: string; 
  public get module() {
    return this.getStringAttribute('module');
  }
  public set module(value: string) {
    this._module = value;
  }
  // Temporarily expose input value. Use with caution.
  public get moduleInput() {
    return this._module;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole {
  /**
  * Path where the App Role authentication backend is mounted in Vault, e.g: 'approle'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#role_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#role_id}
  */
  readonly roleId?: string;
  /**
  * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The 'key' field must be specified and denotes which entry within the Secret resource is used as the app role id.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#role_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#role_ref}
  */
  readonly roleRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef;
  /**
  * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The 'key' field must be specified and denotes which entry within the Secret resource is used as the app role secret.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    role_id: cdktf.stringToTerraform(struct!.roleId),
    role_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToTerraform(struct!.roleRef),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_id: {
      value: cdktf.stringToHclTerraform(struct!.roleId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefToHclTerraform(struct!.roleRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._roleId !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleId = this._roleId;
    }
    if (this._roleRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.roleRef = this._roleRef?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._roleId = undefined;
      this._roleRef.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._roleId = value.roleId;
      this._roleRef.internalValue = value.roleRef;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // role_id - computed: false, optional: true, required: false
  private _roleId?: string; 
  public get roleId() {
    return this.getStringAttribute('role_id');
  }
  public set roleId(value: string) {
    this._roleId = value;
  }
  public resetRoleId() {
    this._roleId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleIdInput() {
    return this._roleId;
  }

  // role_ref - computed: false, optional: true, required: false
  private _roleRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRefOutputReference(this, "role_ref");
  public get roleRef() {
    return this._roleRef;
  }
  public putRoleRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleRoleRef) {
    this._roleRef.internalValue = value;
  }
  public resetRoleRef() {
    this._roleRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleRefInput() {
    return this._roleRef.internalValue;
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert {
  /**
  * ClientCert is a certificate to authenticate using the Cert Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#client_cert DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#client_cert}
  */
  readonly clientCert?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert;
  /**
  * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    client_cert: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToTerraform(struct!.clientCert),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    client_cert: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertToHclTerraform(struct!.clientCert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._clientCert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientCert = this._clientCert?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._clientCert.internalValue = value.clientCert;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // client_cert - computed: false, optional: true, required: false
  private _clientCert = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCertOutputReference(this, "client_cert");
  public get clientCert() {
    return this._clientCert;
  }
  public putClientCert(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertClientCert) {
    this._clientCert.internalValue = value;
  }
  public resetClientCert() {
    this._clientCert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientCertInput() {
    return this._clientCert.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt {
  /**
  * A reference to a ServiceAccount resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef {
  /**
  * The AccessKeyID is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#access_key_id_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#access_key_id_secret_ref}
  */
  readonly accessKeyIdSecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;
  /**
  * The SecretAccessKey is used for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_access_key_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_access_key_secret_ref}
  */
  readonly secretAccessKeySecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;
  /**
  * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#session_token_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#session_token_secret_ref}
  */
  readonly sessionTokenSecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_key_id_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToTerraform(struct!.accessKeyIdSecretRef),
    secret_access_key_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToTerraform(struct!.secretAccessKeySecretRef),
    session_token_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToTerraform(struct!.sessionTokenSecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_key_id_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefToHclTerraform(struct!.accessKeyIdSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef",
    },
    secret_access_key_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefToHclTerraform(struct!.secretAccessKeySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef",
    },
    session_token_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefToHclTerraform(struct!.sessionTokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessKeyIdSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessKeyIdSecretRef = this._accessKeyIdSecretRef?.internalValue;
    }
    if (this._secretAccessKeySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretAccessKeySecretRef = this._secretAccessKeySecretRef?.internalValue;
    }
    if (this._sessionTokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sessionTokenSecretRef = this._sessionTokenSecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = undefined;
      this._secretAccessKeySecretRef.internalValue = undefined;
      this._sessionTokenSecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessKeyIdSecretRef.internalValue = value.accessKeyIdSecretRef;
      this._secretAccessKeySecretRef.internalValue = value.secretAccessKeySecretRef;
      this._sessionTokenSecretRef.internalValue = value.sessionTokenSecretRef;
    }
  }

  // access_key_id_secret_ref - computed: false, optional: true, required: false
  private _accessKeyIdSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRefOutputReference(this, "access_key_id_secret_ref");
  public get accessKeyIdSecretRef() {
    return this._accessKeyIdSecretRef;
  }
  public putAccessKeyIdSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef) {
    this._accessKeyIdSecretRef.internalValue = value;
  }
  public resetAccessKeyIdSecretRef() {
    this._accessKeyIdSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessKeyIdSecretRefInput() {
    return this._accessKeyIdSecretRef.internalValue;
  }

  // secret_access_key_secret_ref - computed: false, optional: true, required: false
  private _secretAccessKeySecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRefOutputReference(this, "secret_access_key_secret_ref");
  public get secretAccessKeySecretRef() {
    return this._secretAccessKeySecretRef;
  }
  public putSecretAccessKeySecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef) {
    this._secretAccessKeySecretRef.internalValue = value;
  }
  public resetSecretAccessKeySecretRef() {
    this._secretAccessKeySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretAccessKeySecretRefInput() {
    return this._secretAccessKeySecretRef.internalValue;
  }

  // session_token_secret_ref - computed: false, optional: true, required: false
  private _sessionTokenSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRefOutputReference(this, "session_token_secret_ref");
  public get sessionTokenSecretRef() {
    return this._sessionTokenSecretRef;
  }
  public putSessionTokenSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefSessionTokenSecretRef) {
    this._sessionTokenSecretRef.internalValue = value;
  }
  public resetSessionTokenSecretRef() {
    this._sessionTokenSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sessionTokenSecretRefInput() {
    return this._sessionTokenSecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam {
  /**
  * AWS External ID set on assumed IAM roles
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#external_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#external_id}
  */
  readonly externalId?: string;
  /**
  * Specify a service account with IRSA enabled
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt;
  /**
  * Path where the AWS auth method is enabled in Vault, e.g: 'aws'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#path}
  */
  readonly path?: string;
  /**
  * AWS region
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#region DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#region}
  */
  readonly region?: string;
  /**
  * This is the AWS role to be assumed before talking to vault
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * Specify credentials in a Secret object
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef;
  /**
  * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#vault_aws_iam_server_id DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#vault_aws_iam_server_id}
  */
  readonly vaultAwsIamServerId?: string;
  /**
  * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#vault_role DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#vault_role}
  */
  readonly vaultRole: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    external_id: cdktf.stringToTerraform(struct!.externalId),
    jwt: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToTerraform(struct!.jwt),
    path: cdktf.stringToTerraform(struct!.path),
    region: cdktf.stringToTerraform(struct!.region),
    role: cdktf.stringToTerraform(struct!.role),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToTerraform(struct!.secretRef),
    vault_aws_iam_server_id: cdktf.stringToTerraform(struct!.vaultAwsIamServerId),
    vault_role: cdktf.stringToTerraform(struct!.vaultRole),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    external_id: {
      value: cdktf.stringToHclTerraform(struct!.externalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    jwt: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef",
    },
    vault_aws_iam_server_id: {
      value: cdktf.stringToHclTerraform(struct!.vaultAwsIamServerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    vault_role: {
      value: cdktf.stringToHclTerraform(struct!.vaultRole),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._externalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.externalId = this._externalId;
    }
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._vaultAwsIamServerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaultAwsIamServerId = this._vaultAwsIamServerId;
    }
    if (this._vaultRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.vaultRole = this._vaultRole;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._externalId = undefined;
      this._jwt.internalValue = undefined;
      this._path = undefined;
      this._region = undefined;
      this._role = undefined;
      this._secretRef.internalValue = undefined;
      this._vaultAwsIamServerId = undefined;
      this._vaultRole = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._externalId = value.externalId;
      this._jwt.internalValue = value.jwt;
      this._path = value.path;
      this._region = value.region;
      this._role = value.role;
      this._secretRef.internalValue = value.secretRef;
      this._vaultAwsIamServerId = value.vaultAwsIamServerId;
      this._vaultRole = value.vaultRole;
    }
  }

  // external_id - computed: false, optional: true, required: false
  private _externalId?: string; 
  public get externalId() {
    return this.getStringAttribute('external_id');
  }
  public set externalId(value: string) {
    this._externalId = value;
  }
  public resetExternalId() {
    this._externalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get externalIdInput() {
    return this._externalId;
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // vault_aws_iam_server_id - computed: false, optional: true, required: false
  private _vaultAwsIamServerId?: string; 
  public get vaultAwsIamServerId() {
    return this.getStringAttribute('vault_aws_iam_server_id');
  }
  public set vaultAwsIamServerId(value: string) {
    this._vaultAwsIamServerId = value;
  }
  public resetVaultAwsIamServerId() {
    this._vaultAwsIamServerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultAwsIamServerIdInput() {
    return this._vaultAwsIamServerId;
  }

  // vault_role - computed: false, optional: false, required: true
  private _vaultRole?: string; 
  public get vaultRole() {
    return this.getStringAttribute('vault_role');
  }
  public set vaultRole(value: string) {
    this._vaultRole = value;
  }
  // Temporarily expose input value. Use with caution.
  public get vaultRoleInput() {
    return this._vaultRole;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
  * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by 'serviceAccountRef'. Defaults to a single audience 'vault' it not specified. Deprecated: use serviceAccountRef.Audiences instead
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by 'serviceAccountRef'. Deprecated: this will be removed in the future. Defaults to 10 minutes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#expiration_seconds DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#expiration_seconds}
  */
  readonly expirationSeconds?: number;
  /**
  * Service account field containing the name of a kubernetes ServiceAccount.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    expiration_seconds: cdktf.numberToTerraform(struct!.expirationSeconds),
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    expiration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.expirationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._expirationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.expirationSeconds = this._expirationSeconds;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._expirationSeconds = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._expirationSeconds = value.expirationSeconds;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // expiration_seconds - computed: false, optional: true, required: false
  private _expirationSeconds?: number; 
  public get expirationSeconds() {
    return this.getNumberAttribute('expiration_seconds');
  }
  public set expirationSeconds(value: number) {
    this._expirationSeconds = value;
  }
  public resetExpirationSeconds() {
    this._expirationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get expirationSecondsInput() {
    return this._expirationSeconds;
  }

  // service_account_ref - computed: false, optional: false, required: true
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt {
  /**
  * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the 'TokenRequest' API.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#kubernetes_service_account_token DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#kubernetes_service_account_token}
  */
  readonly kubernetesServiceAccountToken?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken;
  /**
  * Path where the JWT authentication backend is mounted in Vault, e.g: 'jwt'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#role}
  */
  readonly role?: string;
  /**
  * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    kubernetes_service_account_token: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToTerraform(struct!.kubernetesServiceAccountToken),
    path: cdktf.stringToTerraform(struct!.path),
    role: cdktf.stringToTerraform(struct!.role),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    kubernetes_service_account_token: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenToHclTerraform(struct!.kubernetesServiceAccountToken),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._kubernetesServiceAccountToken?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetesServiceAccountToken = this._kubernetesServiceAccountToken?.internalValue;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._kubernetesServiceAccountToken.internalValue = undefined;
      this._path = undefined;
      this._role = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._kubernetesServiceAccountToken.internalValue = value.kubernetesServiceAccountToken;
      this._path = value.path;
      this._role = value.role;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // kubernetes_service_account_token - computed: false, optional: true, required: false
  private _kubernetesServiceAccountToken = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountTokenOutputReference(this, "kubernetes_service_account_token");
  public get kubernetesServiceAccountToken() {
    return this._kubernetesServiceAccountToken;
  }
  public putKubernetesServiceAccountToken(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtKubernetesServiceAccountToken) {
    this._kubernetesServiceAccountToken.internalValue = value;
  }
  public resetKubernetesServiceAccountToken() {
    this._kubernetesServiceAccountToken.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesServiceAccountTokenInput() {
    return this._kubernetesServiceAccountToken.internalValue;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // role - computed: false, optional: true, required: false
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  public resetRole() {
    this._role = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
  * Audience specifies the 'aud' claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#audiences DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#audiences}
  */
  readonly audiences?: string[];
  /**
  * The name of the ServiceAccount resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    audiences: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.audiences),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    audiences: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.audiences),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._audiences !== undefined) {
      hasAnyValues = true;
      internalValueResult.audiences = this._audiences;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._audiences = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._audiences = value.audiences;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // audiences - computed: false, optional: true, required: false
  private _audiences?: string[]; 
  public get audiences() {
    return this.getListAttribute('audiences');
  }
  public set audiences(value: string[]) {
    this._audiences = value;
  }
  public resetAudiences() {
    this._audiences = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get audiencesInput() {
    return this._audiences;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes {
  /**
  * Path where the Kubernetes authentication backend is mounted in Vault, e.g: 'kubernetes'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#mount_path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#mount_path}
  */
  readonly mountPath: string;
  /**
  * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#role DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#role}
  */
  readonly role: string;
  /**
  * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, 'token' is the default. If one is not specified, the one bound to the controller will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef;
  /**
  * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#service_account_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#service_account_ref}
  */
  readonly serviceAccountRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mount_path: cdktf.stringToTerraform(struct!.mountPath),
    role: cdktf.stringToTerraform(struct!.role),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToTerraform(struct!.secretRef),
    service_account_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToTerraform(struct!.serviceAccountRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mount_path: {
      value: cdktf.stringToHclTerraform(struct!.mountPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    role: {
      value: cdktf.stringToHclTerraform(struct!.role),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef",
    },
    service_account_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefToHclTerraform(struct!.serviceAccountRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mountPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountPath = this._mountPath;
    }
    if (this._role !== undefined) {
      hasAnyValues = true;
      internalValueResult.role = this._role;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._serviceAccountRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountRef = this._serviceAccountRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mountPath = undefined;
      this._role = undefined;
      this._secretRef.internalValue = undefined;
      this._serviceAccountRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mountPath = value.mountPath;
      this._role = value.role;
      this._secretRef.internalValue = value.secretRef;
      this._serviceAccountRef.internalValue = value.serviceAccountRef;
    }
  }

  // mount_path - computed: false, optional: false, required: true
  private _mountPath?: string; 
  public get mountPath() {
    return this.getStringAttribute('mount_path');
  }
  public set mountPath(value: string) {
    this._mountPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get mountPathInput() {
    return this._mountPath;
  }

  // role - computed: false, optional: false, required: true
  private _role?: string; 
  public get role() {
    return this.getStringAttribute('role');
  }
  public set role(value: string) {
    this._role = value;
  }
  // Temporarily expose input value. Use with caution.
  public get roleInput() {
    return this._role;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // service_account_ref - computed: false, optional: true, required: false
  private _serviceAccountRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRefOutputReference(this, "service_account_ref");
  public get serviceAccountRef() {
    return this._serviceAccountRef;
  }
  public putServiceAccountRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesServiceAccountRef) {
    this._serviceAccountRef.internalValue = value;
  }
  public resetServiceAccountRef() {
    this._serviceAccountRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountRefInput() {
    return this._serviceAccountRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap {
  /**
  * Path where the LDAP authentication backend is mounted in Vault, e.g: 'ldap'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef;
  /**
  * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#username}
  */
  readonly username: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToTerraform(struct!.secretRef),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secretRef.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secretRef.internalValue = value.secretRef;
      this._username = value.username;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass {
  /**
  * Path where the UserPassword authentication backend is mounted in Vault, e.g: 'user'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#path}
  */
  readonly path: string;
  /**
  * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef;
  /**
  * Username is a user name used to authenticate using the UserPass Vault authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#username DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#username}
  */
  readonly username: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    path: cdktf.stringToTerraform(struct!.path),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToTerraform(struct!.secretRef),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._path = undefined;
      this._secretRef.internalValue = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._path = value.path;
      this._secretRef.internalValue = value.secretRef;
      this._username = value.username;
    }
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // username - computed: false, optional: false, required: true
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth {
  /**
  * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#app_role DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#app_role}
  */
  readonly appRole?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole;
  /**
  * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#cert DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#cert}
  */
  readonly cert?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert;
  /**
  * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#iam DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#iam}
  */
  readonly iam?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam;
  /**
  * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#jwt DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#jwt}
  */
  readonly jwt?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt;
  /**
  * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#kubernetes DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#kubernetes}
  */
  readonly kubernetes?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes;
  /**
  * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ldap DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ldap}
  */
  readonly ldap?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap;
  /**
  * Name of the vault namespace to authenticate to. This can be different than the namespace your secret is in. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: 'ns1'. More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces This will default to Vault.Namespace field if set, or empty otherwise
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * TokenSecretRef authenticates with Vault by presenting a token.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#token_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#token_secret_ref}
  */
  readonly tokenSecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef;
  /**
  * UserPass authenticates with Vault by passing username/password pair
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#user_pass DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#user_pass}
  */
  readonly userPass?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_role: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToTerraform(struct!.appRole),
    cert: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToTerraform(struct!.cert),
    iam: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToTerraform(struct!.iam),
    jwt: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToTerraform(struct!.jwt),
    kubernetes: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToTerraform(struct!.kubernetes),
    ldap: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToTerraform(struct!.ldap),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    token_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToTerraform(struct!.tokenSecretRef),
    user_pass: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToTerraform(struct!.userPass),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_role: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleToHclTerraform(struct!.appRole),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole",
    },
    cert: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertToHclTerraform(struct!.cert),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert",
    },
    iam: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamToHclTerraform(struct!.iam),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam",
    },
    jwt: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtToHclTerraform(struct!.jwt),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt",
    },
    kubernetes: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesToHclTerraform(struct!.kubernetes),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes",
    },
    ldap: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapToHclTerraform(struct!.ldap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefToHclTerraform(struct!.tokenSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef",
    },
    user_pass: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassToHclTerraform(struct!.userPass),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appRole?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.appRole = this._appRole?.internalValue;
    }
    if (this._cert?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cert = this._cert?.internalValue;
    }
    if (this._iam?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.iam = this._iam?.internalValue;
    }
    if (this._jwt?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.jwt = this._jwt?.internalValue;
    }
    if (this._kubernetes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kubernetes = this._kubernetes?.internalValue;
    }
    if (this._ldap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ldap = this._ldap?.internalValue;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._tokenSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecretRef = this._tokenSecretRef?.internalValue;
    }
    if (this._userPass?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.userPass = this._userPass?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appRole.internalValue = undefined;
      this._cert.internalValue = undefined;
      this._iam.internalValue = undefined;
      this._jwt.internalValue = undefined;
      this._kubernetes.internalValue = undefined;
      this._ldap.internalValue = undefined;
      this._namespace = undefined;
      this._tokenSecretRef.internalValue = undefined;
      this._userPass.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appRole.internalValue = value.appRole;
      this._cert.internalValue = value.cert;
      this._iam.internalValue = value.iam;
      this._jwt.internalValue = value.jwt;
      this._kubernetes.internalValue = value.kubernetes;
      this._ldap.internalValue = value.ldap;
      this._namespace = value.namespace;
      this._tokenSecretRef.internalValue = value.tokenSecretRef;
      this._userPass.internalValue = value.userPass;
    }
  }

  // app_role - computed: false, optional: true, required: false
  private _appRole = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRoleOutputReference(this, "app_role");
  public get appRole() {
    return this._appRole;
  }
  public putAppRole(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthAppRole) {
    this._appRole.internalValue = value;
  }
  public resetAppRole() {
    this._appRole.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appRoleInput() {
    return this._appRole.internalValue;
  }

  // cert - computed: false, optional: true, required: false
  private _cert = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCertOutputReference(this, "cert");
  public get cert() {
    return this._cert;
  }
  public putCert(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthCert) {
    this._cert.internalValue = value;
  }
  public resetCert() {
    this._cert.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certInput() {
    return this._cert.internalValue;
  }

  // iam - computed: false, optional: true, required: false
  private _iam = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIamOutputReference(this, "iam");
  public get iam() {
    return this._iam;
  }
  public putIam(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthIam) {
    this._iam.internalValue = value;
  }
  public resetIam() {
    this._iam.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get iamInput() {
    return this._iam.internalValue;
  }

  // jwt - computed: false, optional: true, required: false
  private _jwt = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwtOutputReference(this, "jwt");
  public get jwt() {
    return this._jwt;
  }
  public putJwt(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthJwt) {
    this._jwt.internalValue = value;
  }
  public resetJwt() {
    this._jwt.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jwtInput() {
    return this._jwt.internalValue;
  }

  // kubernetes - computed: false, optional: true, required: false
  private _kubernetes = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetesOutputReference(this, "kubernetes");
  public get kubernetes() {
    return this._kubernetes;
  }
  public putKubernetes(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthKubernetes) {
    this._kubernetes.internalValue = value;
  }
  public resetKubernetes() {
    this._kubernetes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kubernetesInput() {
    return this._kubernetes.internalValue;
  }

  // ldap - computed: false, optional: true, required: false
  private _ldap = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdapOutputReference(this, "ldap");
  public get ldap() {
    return this._ldap;
  }
  public putLdap(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthLdap) {
    this._ldap.internalValue = value;
  }
  public resetLdap() {
    this._ldap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ldapInput() {
    return this._ldap.internalValue;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // token_secret_ref - computed: false, optional: true, required: false
  private _tokenSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRefOutputReference(this, "token_secret_ref");
  public get tokenSecretRef() {
    return this._tokenSecretRef;
  }
  public putTokenSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthTokenSecretRef) {
    this._tokenSecretRef.internalValue = value;
  }
  public resetTokenSecretRef() {
    this._tokenSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretRefInput() {
    return this._tokenSecretRef.internalValue;
  }

  // user_pass - computed: false, optional: true, required: false
  private _userPass = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPassOutputReference(this, "user_pass");
  public get userPass() {
    return this._userPass;
  }
  public putUserPass(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthUserPass) {
    this._userPass.internalValue = value;
  }
  public resetUserPass() {
    this._userPass.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userPassInput() {
    return this._userPass.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider {
  /**
  * The key where the CA certificate can be found in the Secret or ConfigMap.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls {
  /**
  * CertSecretRef is a certificate added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.crt'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#cert_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#cert_secret_ref}
  */
  readonly certSecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef;
  /**
  * KeySecretRef to a key in a Secret resource containing client private key added to the transport layer when communicating with the Vault server. If no key for the Secret is specified, external-secret will default to 'tls.key'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key_secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key_secret_ref}
  */
  readonly keySecretRef?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cert_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToTerraform(struct!.certSecretRef),
    key_secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToTerraform(struct!.keySecretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cert_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefToHclTerraform(struct!.certSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef",
    },
    key_secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefToHclTerraform(struct!.keySecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certSecretRef = this._certSecretRef?.internalValue;
    }
    if (this._keySecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keySecretRef = this._keySecretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certSecretRef.internalValue = undefined;
      this._keySecretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certSecretRef.internalValue = value.certSecretRef;
      this._keySecretRef.internalValue = value.keySecretRef;
    }
  }

  // cert_secret_ref - computed: false, optional: true, required: false
  private _certSecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRefOutputReference(this, "cert_secret_ref");
  public get certSecretRef() {
    return this._certSecretRef;
  }
  public putCertSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsCertSecretRef) {
    this._certSecretRef.internalValue = value;
  }
  public resetCertSecretRef() {
    this._certSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certSecretRefInput() {
    return this._certSecretRef.internalValue;
  }

  // key_secret_ref - computed: false, optional: true, required: false
  private _keySecretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRefOutputReference(this, "key_secret_ref");
  public get keySecretRef() {
    return this._keySecretRef;
  }
  public putKeySecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsKeySecretRef) {
    this._keySecretRef.internalValue = value;
  }
  public resetKeySecretRef() {
    this._keySecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keySecretRefInput() {
    return this._keySecretRef.internalValue;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVault {
  /**
  * Auth configures how secret-manager authenticates with the Vault server.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#auth DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#auth}
  */
  readonly auth: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth;
  /**
  * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_bundle DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_bundle}
  */
  readonly caBundle?: string;
  /**
  * The provider for the CA bundle to use to validate Vault server certificate.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#ca_provider DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#ca_provider}
  */
  readonly caProvider?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider;
  /**
  * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#forward_inconsistent DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#forward_inconsistent}
  */
  readonly forwardInconsistent?: boolean | cdktf.IResolvable;
  /**
  * Headers to be added in Vault request
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#headers DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#headers}
  */
  readonly headers?: { [key: string]: string };
  /**
  * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: 'ns1'. More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * Path is the mount path of the Vault KV backend endpoint, e.g: 'secret'. The v2 KV secret engine version specific '/data' path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#path}
  */
  readonly path?: string;
  /**
  * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#read_your_writes DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#read_your_writes}
  */
  readonly readYourWrites?: boolean | cdktf.IResolvable;
  /**
  * Server is the connection address for the Vault server, e.g: 'https://vault.example.com:8200'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#server DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#server}
  */
  readonly server: string;
  /**
  * The configuration used for client side related TLS communication, when the Vault server requires mutual authentication. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. It's worth noting this configuration is different from the 'TLS certificates auth method', which is available under the 'auth.cert' section.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#tls DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#tls}
  */
  readonly tls?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls;
  /**
  * Version is the Vault KV secret engine version. This can be either 'v1' or 'v2'. Version defaults to 'v2'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#version DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#version}
  */
  readonly version?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthToTerraform(struct!.auth),
    ca_bundle: cdktf.stringToTerraform(struct!.caBundle),
    ca_provider: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToTerraform(struct!.caProvider),
    forward_inconsistent: cdktf.booleanToTerraform(struct!.forwardInconsistent),
    headers: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.headers),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    path: cdktf.stringToTerraform(struct!.path),
    read_your_writes: cdktf.booleanToTerraform(struct!.readYourWrites),
    server: cdktf.stringToTerraform(struct!.server),
    tls: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsToTerraform(struct!.tls),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth",
    },
    ca_bundle: {
      value: cdktf.stringToHclTerraform(struct!.caBundle),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_provider: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderToHclTerraform(struct!.caProvider),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider",
    },
    forward_inconsistent: {
      value: cdktf.booleanToHclTerraform(struct!.forwardInconsistent),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    headers: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.headers),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_your_writes: {
      value: cdktf.booleanToHclTerraform(struct!.readYourWrites),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server: {
      value: cdktf.stringToHclTerraform(struct!.server),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._caBundle !== undefined) {
      hasAnyValues = true;
      internalValueResult.caBundle = this._caBundle;
    }
    if (this._caProvider?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.caProvider = this._caProvider?.internalValue;
    }
    if (this._forwardInconsistent !== undefined) {
      hasAnyValues = true;
      internalValueResult.forwardInconsistent = this._forwardInconsistent;
    }
    if (this._headers !== undefined) {
      hasAnyValues = true;
      internalValueResult.headers = this._headers;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._readYourWrites !== undefined) {
      hasAnyValues = true;
      internalValueResult.readYourWrites = this._readYourWrites;
    }
    if (this._server !== undefined) {
      hasAnyValues = true;
      internalValueResult.server = this._server;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVault | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._caBundle = undefined;
      this._caProvider.internalValue = undefined;
      this._forwardInconsistent = undefined;
      this._headers = undefined;
      this._namespace = undefined;
      this._path = undefined;
      this._readYourWrites = undefined;
      this._server = undefined;
      this._tls.internalValue = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._caBundle = value.caBundle;
      this._caProvider.internalValue = value.caProvider;
      this._forwardInconsistent = value.forwardInconsistent;
      this._headers = value.headers;
      this._namespace = value.namespace;
      this._path = value.path;
      this._readYourWrites = value.readYourWrites;
      this._server = value.server;
      this._tls.internalValue = value.tls;
      this._version = value.version;
    }
  }

  // auth - computed: false, optional: false, required: true
  private _auth = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultAuth) {
    this._auth.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // ca_bundle - computed: false, optional: true, required: false
  private _caBundle?: string; 
  public get caBundle() {
    return this.getStringAttribute('ca_bundle');
  }
  public set caBundle(value: string) {
    this._caBundle = value;
  }
  public resetCaBundle() {
    this._caBundle = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caBundleInput() {
    return this._caBundle;
  }

  // ca_provider - computed: false, optional: true, required: false
  private _caProvider = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProviderOutputReference(this, "ca_provider");
  public get caProvider() {
    return this._caProvider;
  }
  public putCaProvider(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultCaProvider) {
    this._caProvider.internalValue = value;
  }
  public resetCaProvider() {
    this._caProvider.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caProviderInput() {
    return this._caProvider.internalValue;
  }

  // forward_inconsistent - computed: false, optional: true, required: false
  private _forwardInconsistent?: boolean | cdktf.IResolvable; 
  public get forwardInconsistent() {
    return this.getBooleanAttribute('forward_inconsistent');
  }
  public set forwardInconsistent(value: boolean | cdktf.IResolvable) {
    this._forwardInconsistent = value;
  }
  public resetForwardInconsistent() {
    this._forwardInconsistent = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get forwardInconsistentInput() {
    return this._forwardInconsistent;
  }

  // headers - computed: false, optional: true, required: false
  private _headers?: { [key: string]: string }; 
  public get headers() {
    return this.getStringMapAttribute('headers');
  }
  public set headers(value: { [key: string]: string }) {
    this._headers = value;
  }
  public resetHeaders() {
    this._headers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headersInput() {
    return this._headers;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // read_your_writes - computed: false, optional: true, required: false
  private _readYourWrites?: boolean | cdktf.IResolvable; 
  public get readYourWrites() {
    return this.getBooleanAttribute('read_your_writes');
  }
  public set readYourWrites(value: boolean | cdktf.IResolvable) {
    this._readYourWrites = value;
  }
  public resetReadYourWrites() {
    this._readYourWrites = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readYourWritesInput() {
    return this._readYourWrites;
  }

  // server - computed: false, optional: false, required: true
  private _server?: string; 
  public get server() {
    return this.getStringAttribute('server');
  }
  public set server(value: string) {
    this._server = value;
  }
  // Temporarily expose input value. Use with caution.
  public get serverInput() {
    return this._server;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderVaultTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider {
  /**
  * The key the value inside of the provider type to use, only used with 'Secret' type
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the object located at the provider type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * The namespace the Provider type is in.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
  /**
  * The type of provider to use such as 'Secret', or 'ConfigMap'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#type DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProviderToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProviderToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProviderOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookCaProvider | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
      this._type = value.type;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResult {
  /**
  * Json path of return value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#json_path DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#json_path}
  */
  readonly jsonPath?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResultToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    json_path: cdktf.stringToTerraform(struct!.jsonPath),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResultToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    json_path: {
      value: cdktf.stringToHclTerraform(struct!.jsonPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._jsonPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.jsonPath = this._jsonPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookResult | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._jsonPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._jsonPath = value.jsonPath;
    }
  }

  // json_path - computed: false, optional: true, required: false
  private _jsonPath?: string; 
  public get jsonPath() {
    return this.getStringAttribute('json_path');
  }
  public set jsonPath(value: string) {
    this._jsonPath = value;
  }
  public resetJsonPath() {
    this._jsonPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jsonPathInput() {
    return this._jsonPath;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef {
  /**
  * The key of the entry in the Secret resource's 'data' field to be used. Some instances of this field may be defaulted, in others it may be required.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#key DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#key}
  */
  readonly key?: string;
  /**
  * The name of the Secret resource being referred to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name?: string;
  /**
  * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#namespace DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#namespace}
  */
  readonly namespace?: string;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    name: cdktf.stringToTerraform(struct!.name),
    namespace: cdktf.stringToTerraform(struct!.namespace),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._name = undefined;
      this._namespace = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._name = value.name;
      this._namespace = value.namespace;
    }
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }
}
export interface DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets {
  /**
  * Name of this secret in templates
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#name DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#name}
  */
  readonly name: string;
  /**
  * Secret ref to fill in credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/external_secrets_io_secret_store_v1beta1_manifest#secret_ref DataK8SExternalSecretsIoSecretStoreV1Beta1Manifest#secret_ref}
  */
  readonly secretRef: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef;
}

export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsToTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    secret_ref: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToTerraform(struct!.secretRef),
  }
}


export function dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsToHclTerraform(struct?: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_ref: {
      value: dataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._secretRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._secretRef.internalValue = value.secretRef;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // secret_ref - computed: false, optional: false, required: true
  private _secretRef = new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsSecretRef) {
    this._secretRef.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }
}

export class DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsList extends cdktf.ComplexList {
  public internalValue? : DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecrets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsOutputReference {
    return new DataK8SExternalSecretsIoSecretStoreV1Beta1ManifestSpecProviderWebhookSecretsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
