import * as cdktf from 'cdktf';
import { DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExec,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExecToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExecToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExecOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGet,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGetToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGetToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGetOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocket,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocketToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocketToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocketOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentials,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentialsToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentialsToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentialsList,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinity,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinityToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinityToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinityOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfig,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfigToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfigToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfigOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomain,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomainToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomainToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomainOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbe,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbeToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbeToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbeOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworks,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworksToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworksToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworksList,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplates,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplatesToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplatesToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplatesList,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetype,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetypeToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetypeToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetypeOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreference,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreferenceToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreferenceToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreferenceOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRef,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRefToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRefToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRefOutputReference,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheck,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheckToTerraform,
dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheckToHclTerraform,
DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheckOutputReference } from './structs0'
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe {
  /**
  * One and only one of the following should be specified. Exec specifies the action to take, it will be executed on the guest through the qemu-guest-agent. If the guest agent is not available, this probe will fail.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#exec DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#exec}
  */
  readonly exec?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExec;
  /**
  * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#failure_threshold DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#failure_threshold}
  */
  readonly failureThreshold?: number;
  /**
  * GuestAgentPing contacts the qemu-guest-agent for availability checks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#guest_agent_ping DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#guest_agent_ping}
  */
  readonly guestAgentPing?: { [key: string]: string };
  /**
  * HTTPGet specifies the http request to perform.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#http_get DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#http_get}
  */
  readonly httpGet?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGet;
  /**
  * Number of seconds after the VirtualMachineInstance has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#initial_delay_seconds DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#initial_delay_seconds}
  */
  readonly initialDelaySeconds?: number;
  /**
  * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#period_seconds DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#period_seconds}
  */
  readonly periodSeconds?: number;
  /**
  * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#success_threshold DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#success_threshold}
  */
  readonly successThreshold?: number;
  /**
  * TCPSocket specifies an action involving a TCP port. TCP hooks not yet supported TODO: implement a realistic TCP lifecycle hook
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#tcp_socket DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#tcp_socket}
  */
  readonly tcpSocket?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocket;
  /**
  * Number of seconds after which the probe times out. For exec probes the timeout fails the probe but does not terminate the command running on the guest. This means a blocking command can result in an increasing load on the guest. A small buffer will be added to the resulting workload exec probe to compensate for delays caused by the qemu guest exec mechanism. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#timeout_seconds DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#timeout_seconds}
  */
  readonly timeoutSeconds?: number;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    exec: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExecToTerraform(struct!.exec),
    failure_threshold: cdktf.numberToTerraform(struct!.failureThreshold),
    guest_agent_ping: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.guestAgentPing),
    http_get: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGetToTerraform(struct!.httpGet),
    initial_delay_seconds: cdktf.numberToTerraform(struct!.initialDelaySeconds),
    period_seconds: cdktf.numberToTerraform(struct!.periodSeconds),
    success_threshold: cdktf.numberToTerraform(struct!.successThreshold),
    tcp_socket: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocketToTerraform(struct!.tcpSocket),
    timeout_seconds: cdktf.numberToTerraform(struct!.timeoutSeconds),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    exec: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExecToHclTerraform(struct!.exec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExec",
    },
    failure_threshold: {
      value: cdktf.numberToHclTerraform(struct!.failureThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    guest_agent_ping: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.guestAgentPing),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    http_get: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGetToHclTerraform(struct!.httpGet),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGet",
    },
    initial_delay_seconds: {
      value: cdktf.numberToHclTerraform(struct!.initialDelaySeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.periodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    success_threshold: {
      value: cdktf.numberToHclTerraform(struct!.successThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tcp_socket: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocketToHclTerraform(struct!.tcpSocket),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocket",
    },
    timeout_seconds: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._exec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.exec = this._exec?.internalValue;
    }
    if (this._failureThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.failureThreshold = this._failureThreshold;
    }
    if (this._guestAgentPing !== undefined) {
      hasAnyValues = true;
      internalValueResult.guestAgentPing = this._guestAgentPing;
    }
    if (this._httpGet?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpGet = this._httpGet?.internalValue;
    }
    if (this._initialDelaySeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialDelaySeconds = this._initialDelaySeconds;
    }
    if (this._periodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.periodSeconds = this._periodSeconds;
    }
    if (this._successThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.successThreshold = this._successThreshold;
    }
    if (this._tcpSocket?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpSocket = this._tcpSocket?.internalValue;
    }
    if (this._timeoutSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSeconds = this._timeoutSeconds;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._exec.internalValue = undefined;
      this._failureThreshold = undefined;
      this._guestAgentPing = undefined;
      this._httpGet.internalValue = undefined;
      this._initialDelaySeconds = undefined;
      this._periodSeconds = undefined;
      this._successThreshold = undefined;
      this._tcpSocket.internalValue = undefined;
      this._timeoutSeconds = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._exec.internalValue = value.exec;
      this._failureThreshold = value.failureThreshold;
      this._guestAgentPing = value.guestAgentPing;
      this._httpGet.internalValue = value.httpGet;
      this._initialDelaySeconds = value.initialDelaySeconds;
      this._periodSeconds = value.periodSeconds;
      this._successThreshold = value.successThreshold;
      this._tcpSocket.internalValue = value.tcpSocket;
      this._timeoutSeconds = value.timeoutSeconds;
    }
  }

  // exec - computed: false, optional: true, required: false
  private _exec = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExecOutputReference(this, "exec");
  public get exec() {
    return this._exec;
  }
  public putExec(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeExec) {
    this._exec.internalValue = value;
  }
  public resetExec() {
    this._exec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get execInput() {
    return this._exec.internalValue;
  }

  // failure_threshold - computed: false, optional: true, required: false
  private _failureThreshold?: number; 
  public get failureThreshold() {
    return this.getNumberAttribute('failure_threshold');
  }
  public set failureThreshold(value: number) {
    this._failureThreshold = value;
  }
  public resetFailureThreshold() {
    this._failureThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failureThresholdInput() {
    return this._failureThreshold;
  }

  // guest_agent_ping - computed: false, optional: true, required: false
  private _guestAgentPing?: { [key: string]: string }; 
  public get guestAgentPing() {
    return this.getStringMapAttribute('guest_agent_ping');
  }
  public set guestAgentPing(value: { [key: string]: string }) {
    this._guestAgentPing = value;
  }
  public resetGuestAgentPing() {
    this._guestAgentPing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get guestAgentPingInput() {
    return this._guestAgentPing;
  }

  // http_get - computed: false, optional: true, required: false
  private _httpGet = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGetOutputReference(this, "http_get");
  public get httpGet() {
    return this._httpGet;
  }
  public putHttpGet(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeHttpGet) {
    this._httpGet.internalValue = value;
  }
  public resetHttpGet() {
    this._httpGet.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpGetInput() {
    return this._httpGet.internalValue;
  }

  // initial_delay_seconds - computed: false, optional: true, required: false
  private _initialDelaySeconds?: number; 
  public get initialDelaySeconds() {
    return this.getNumberAttribute('initial_delay_seconds');
  }
  public set initialDelaySeconds(value: number) {
    this._initialDelaySeconds = value;
  }
  public resetInitialDelaySeconds() {
    this._initialDelaySeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialDelaySecondsInput() {
    return this._initialDelaySeconds;
  }

  // period_seconds - computed: false, optional: true, required: false
  private _periodSeconds?: number; 
  public get periodSeconds() {
    return this.getNumberAttribute('period_seconds');
  }
  public set periodSeconds(value: number) {
    this._periodSeconds = value;
  }
  public resetPeriodSeconds() {
    this._periodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get periodSecondsInput() {
    return this._periodSeconds;
  }

  // success_threshold - computed: false, optional: true, required: false
  private _successThreshold?: number; 
  public get successThreshold() {
    return this.getNumberAttribute('success_threshold');
  }
  public set successThreshold(value: number) {
    this._successThreshold = value;
  }
  public resetSuccessThreshold() {
    this._successThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get successThresholdInput() {
    return this._successThreshold;
  }

  // tcp_socket - computed: false, optional: true, required: false
  private _tcpSocket = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocketOutputReference(this, "tcp_socket");
  public get tcpSocket() {
    return this._tcpSocket;
  }
  public putTcpSocket(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeTcpSocket) {
    this._tcpSocket.internalValue = value;
  }
  public resetTcpSocket() {
    this._tcpSocket.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpSocketInput() {
    return this._tcpSocket.internalValue;
  }

  // timeout_seconds - computed: false, optional: true, required: false
  private _timeoutSeconds?: number; 
  public get timeoutSeconds() {
    return this.getNumberAttribute('timeout_seconds');
  }
  public set timeoutSeconds(value: number) {
    this._timeoutSeconds = value;
  }
  public resetTimeoutSeconds() {
    this._timeoutSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecondsInput() {
    return this._timeoutSeconds;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations {
  /**
  * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#effect DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#effect}
  */
  readonly effect?: string;
  /**
  * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#key DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#key}
  */
  readonly key?: string;
  /**
  * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#operator DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#operator}
  */
  readonly operator?: string;
  /**
  * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#toleration_seconds DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#toleration_seconds}
  */
  readonly tolerationSeconds?: number;
  /**
  * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#value DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#value}
  */
  readonly value?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    effect: cdktf.stringToTerraform(struct!.effect),
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    toleration_seconds: cdktf.numberToTerraform(struct!.tolerationSeconds),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    effect: {
      value: cdktf.stringToHclTerraform(struct!.effect),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    toleration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.tolerationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._effect !== undefined) {
      hasAnyValues = true;
      internalValueResult.effect = this._effect;
    }
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._tolerationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerationSeconds = this._tolerationSeconds;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._effect = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._tolerationSeconds = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._effect = value.effect;
      this._key = value.key;
      this._operator = value.operator;
      this._tolerationSeconds = value.tolerationSeconds;
      this._value = value.value;
    }
  }

  // effect - computed: false, optional: true, required: false
  private _effect?: string; 
  public get effect() {
    return this.getStringAttribute('effect');
  }
  public set effect(value: string) {
    this._effect = value;
  }
  public resetEffect() {
    this._effect = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get effectInput() {
    return this._effect;
  }

  // key - computed: false, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: true, required: false
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  public resetOperator() {
    this._operator = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // toleration_seconds - computed: false, optional: true, required: false
  private _tolerationSeconds?: number; 
  public get tolerationSeconds() {
    return this.getNumberAttribute('toleration_seconds');
  }
  public set tolerationSeconds(value: number) {
    this._tolerationSeconds = value;
  }
  public resetTolerationSeconds() {
    this._tolerationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationSecondsInput() {
    return this._tolerationSeconds;
  }

  // value - computed: false, optional: true, required: false
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  public resetValue() {
    this._value = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsList extends cdktf.ComplexList {
  public internalValue? : DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsOutputReference {
    return new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions {
  /**
  * key is the label key that the selector applies to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#key DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#key}
  */
  readonly key: string;
  /**
  * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#operator DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#operator}
  */
  readonly operator: string;
  /**
  * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#values DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#values}
  */
  readonly values?: string[];
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    operator: cdktf.stringToTerraform(struct!.operator),
    values: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.values),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    operator: {
      value: cdktf.stringToHclTerraform(struct!.operator),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    values: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.values),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._operator !== undefined) {
      hasAnyValues = true;
      internalValueResult.operator = this._operator;
    }
    if (this._values !== undefined) {
      hasAnyValues = true;
      internalValueResult.values = this._values;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._operator = undefined;
      this._values = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._operator = value.operator;
      this._values = value.values;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // operator - computed: false, optional: false, required: true
  private _operator?: string; 
  public get operator() {
    return this.getStringAttribute('operator');
  }
  public set operator(value: string) {
    this._operator = value;
  }
  // Temporarily expose input value. Use with caution.
  public get operatorInput() {
    return this._operator;
  }

  // values - computed: false, optional: true, required: false
  private _values?: string[]; 
  public get values() {
    return this.getListAttribute('values');
  }
  public set values(value: string[]) {
    this._values = value;
  }
  public resetValues() {
    this._values = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valuesInput() {
    return this._values;
  }
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsList extends cdktf.ComplexList {
  public internalValue? : DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference {
    return new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector {
  /**
  * matchExpressions is a list of label selector requirements. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#match_expressions DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#match_expressions}
  */
  readonly matchExpressions?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable;
  /**
  * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is 'key', the operator is 'In', and the values array contains only 'value'. The requirements are ANDed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#match_labels DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#match_labels}
  */
  readonly matchLabels?: { [key: string]: string };
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    match_expressions: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsToTerraform, false)(struct!.matchExpressions),
    match_labels: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.matchLabels),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    match_expressions: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsToHclTerraform, false)(struct!.matchExpressions),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsList",
    },
    match_labels: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.matchLabels),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._matchExpressions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchExpressions = this._matchExpressions?.internalValue;
    }
    if (this._matchLabels !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabels = this._matchLabels;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = undefined;
      this._matchLabels = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._matchExpressions.internalValue = value.matchExpressions;
      this._matchLabels = value.matchLabels;
    }
  }

  // match_expressions - computed: false, optional: true, required: false
  private _matchExpressions = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressionsList(this, "match_expressions", false);
  public get matchExpressions() {
    return this._matchExpressions;
  }
  public putMatchExpressions(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorMatchExpressions[] | cdktf.IResolvable) {
    this._matchExpressions.internalValue = value;
  }
  public resetMatchExpressions() {
    this._matchExpressions.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchExpressionsInput() {
    return this._matchExpressions.internalValue;
  }

  // match_labels - computed: false, optional: true, required: false
  private _matchLabels?: { [key: string]: string }; 
  public get matchLabels() {
    return this.getStringMapAttribute('match_labels');
  }
  public set matchLabels(value: { [key: string]: string }) {
    this._matchLabels = value;
  }
  public resetMatchLabels() {
    this._matchLabels = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelsInput() {
    return this._matchLabels;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints {
  /**
  * LabelSelector is used to find matching pods. Pods that match this label selector are counted to determine the number of pods in their corresponding topology domain.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#label_selector DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#label_selector}
  */
  readonly labelSelector?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector;
  /**
  * MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector. This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#match_label_keys DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#match_label_keys}
  */
  readonly matchLabelKeys?: string[];
  /**
  * MaxSkew describes the degree to which pods may be unevenly distributed. When 'whenUnsatisfiable=DoNotSchedule', it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. | zone1 | zone2 | zone3 | | P P | P P | P | - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When 'whenUnsatisfiable=ScheduleAnyway', it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#max_skew DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#max_skew}
  */
  readonly maxSkew: number;
  /**
  * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats 'global minimum' as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule. For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | | P P | P P | P P | The number of domains is less than 5(MinDomains), so 'global minimum' is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#min_domains DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#min_domains}
  */
  readonly minDomains?: number;
  /**
  * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations. If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#node_affinity_policy DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#node_affinity_policy}
  */
  readonly nodeAffinityPolicy?: string;
  /**
  * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included. If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#node_taints_policy DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#node_taints_policy}
  */
  readonly nodeTaintsPolicy?: string;
  /**
  * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a 'bucket', and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is 'kubernetes.io/hostname', each Node is a domain of that topology. And, if TopologyKey is 'topology.kubernetes.io/zone', each zone is a domain of that topology. It's a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#topology_key DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#topology_key}
  */
  readonly topologyKey: string;
  /**
  * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location, but giving higher precedence to topologies that would help reduce the skew. A constraint is considered 'Unsatisfiable' for an incoming pod if and only if every possible node assignment for that pod would violate 'MaxSkew' on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P | P | P | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#when_unsatisfiable DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#when_unsatisfiable}
  */
  readonly whenUnsatisfiable: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label_selector: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorToTerraform(struct!.labelSelector),
    match_label_keys: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.matchLabelKeys),
    max_skew: cdktf.numberToTerraform(struct!.maxSkew),
    min_domains: cdktf.numberToTerraform(struct!.minDomains),
    node_affinity_policy: cdktf.stringToTerraform(struct!.nodeAffinityPolicy),
    node_taints_policy: cdktf.stringToTerraform(struct!.nodeTaintsPolicy),
    topology_key: cdktf.stringToTerraform(struct!.topologyKey),
    when_unsatisfiable: cdktf.stringToTerraform(struct!.whenUnsatisfiable),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label_selector: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorToHclTerraform(struct!.labelSelector),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector",
    },
    match_label_keys: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.matchLabelKeys),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_skew: {
      value: cdktf.numberToHclTerraform(struct!.maxSkew),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    min_domains: {
      value: cdktf.numberToHclTerraform(struct!.minDomains),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    node_affinity_policy: {
      value: cdktf.stringToHclTerraform(struct!.nodeAffinityPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    node_taints_policy: {
      value: cdktf.stringToHclTerraform(struct!.nodeTaintsPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    topology_key: {
      value: cdktf.stringToHclTerraform(struct!.topologyKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    when_unsatisfiable: {
      value: cdktf.stringToHclTerraform(struct!.whenUnsatisfiable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._labelSelector?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labelSelector = this._labelSelector?.internalValue;
    }
    if (this._matchLabelKeys !== undefined) {
      hasAnyValues = true;
      internalValueResult.matchLabelKeys = this._matchLabelKeys;
    }
    if (this._maxSkew !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSkew = this._maxSkew;
    }
    if (this._minDomains !== undefined) {
      hasAnyValues = true;
      internalValueResult.minDomains = this._minDomains;
    }
    if (this._nodeAffinityPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeAffinityPolicy = this._nodeAffinityPolicy;
    }
    if (this._nodeTaintsPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeTaintsPolicy = this._nodeTaintsPolicy;
    }
    if (this._topologyKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologyKey = this._topologyKey;
    }
    if (this._whenUnsatisfiable !== undefined) {
      hasAnyValues = true;
      internalValueResult.whenUnsatisfiable = this._whenUnsatisfiable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = undefined;
      this._matchLabelKeys = undefined;
      this._maxSkew = undefined;
      this._minDomains = undefined;
      this._nodeAffinityPolicy = undefined;
      this._nodeTaintsPolicy = undefined;
      this._topologyKey = undefined;
      this._whenUnsatisfiable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._labelSelector.internalValue = value.labelSelector;
      this._matchLabelKeys = value.matchLabelKeys;
      this._maxSkew = value.maxSkew;
      this._minDomains = value.minDomains;
      this._nodeAffinityPolicy = value.nodeAffinityPolicy;
      this._nodeTaintsPolicy = value.nodeTaintsPolicy;
      this._topologyKey = value.topologyKey;
      this._whenUnsatisfiable = value.whenUnsatisfiable;
    }
  }

  // label_selector - computed: false, optional: true, required: false
  private _labelSelector = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelectorOutputReference(this, "label_selector");
  public get labelSelector() {
    return this._labelSelector;
  }
  public putLabelSelector(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsLabelSelector) {
    this._labelSelector.internalValue = value;
  }
  public resetLabelSelector() {
    this._labelSelector.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelSelectorInput() {
    return this._labelSelector.internalValue;
  }

  // match_label_keys - computed: false, optional: true, required: false
  private _matchLabelKeys?: string[]; 
  public get matchLabelKeys() {
    return this.getListAttribute('match_label_keys');
  }
  public set matchLabelKeys(value: string[]) {
    this._matchLabelKeys = value;
  }
  public resetMatchLabelKeys() {
    this._matchLabelKeys = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get matchLabelKeysInput() {
    return this._matchLabelKeys;
  }

  // max_skew - computed: false, optional: false, required: true
  private _maxSkew?: number; 
  public get maxSkew() {
    return this.getNumberAttribute('max_skew');
  }
  public set maxSkew(value: number) {
    this._maxSkew = value;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSkewInput() {
    return this._maxSkew;
  }

  // min_domains - computed: false, optional: true, required: false
  private _minDomains?: number; 
  public get minDomains() {
    return this.getNumberAttribute('min_domains');
  }
  public set minDomains(value: number) {
    this._minDomains = value;
  }
  public resetMinDomains() {
    this._minDomains = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minDomainsInput() {
    return this._minDomains;
  }

  // node_affinity_policy - computed: false, optional: true, required: false
  private _nodeAffinityPolicy?: string; 
  public get nodeAffinityPolicy() {
    return this.getStringAttribute('node_affinity_policy');
  }
  public set nodeAffinityPolicy(value: string) {
    this._nodeAffinityPolicy = value;
  }
  public resetNodeAffinityPolicy() {
    this._nodeAffinityPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeAffinityPolicyInput() {
    return this._nodeAffinityPolicy;
  }

  // node_taints_policy - computed: false, optional: true, required: false
  private _nodeTaintsPolicy?: string; 
  public get nodeTaintsPolicy() {
    return this.getStringAttribute('node_taints_policy');
  }
  public set nodeTaintsPolicy(value: string) {
    this._nodeTaintsPolicy = value;
  }
  public resetNodeTaintsPolicy() {
    this._nodeTaintsPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeTaintsPolicyInput() {
    return this._nodeTaintsPolicy;
  }

  // topology_key - computed: false, optional: false, required: true
  private _topologyKey?: string; 
  public get topologyKey() {
    return this.getStringAttribute('topology_key');
  }
  public set topologyKey(value: string) {
    this._topologyKey = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topologyKeyInput() {
    return this._topologyKey;
  }

  // when_unsatisfiable - computed: false, optional: false, required: true
  private _whenUnsatisfiable?: string; 
  public get whenUnsatisfiable() {
    return this.getStringAttribute('when_unsatisfiable');
  }
  public set whenUnsatisfiable(value: string) {
    this._whenUnsatisfiable = value;
  }
  // Temporarily expose input value. Use with caution.
  public get whenUnsatisfiableInput() {
    return this._whenUnsatisfiable;
  }
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsList extends cdktf.ComplexList {
  public internalValue? : DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsOutputReference {
    return new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRefToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRefToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRefToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRefToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive {
  /**
  * NetworkData contains config drive inline cloud-init networkdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#network_data DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#network_data}
  */
  readonly networkData?: string;
  /**
  * NetworkDataBase64 contains config drive cloud-init networkdata as a base64 encoded string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#network_data_base64 DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#network_data_base64}
  */
  readonly networkDataBase64?: string;
  /**
  * NetworkDataSecretRef references a k8s secret that contains config drive networkdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#network_data_secret_ref DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#network_data_secret_ref}
  */
  readonly networkDataSecretRef?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef;
  /**
  * UserDataSecretRef references a k8s secret that contains config drive userdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#secret_ref DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef;
  /**
  * UserData contains config drive inline cloud-init userdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#user_data DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#user_data}
  */
  readonly userData?: string;
  /**
  * UserDataBase64 contains config drive cloud-init userdata as a base64 encoded string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#user_data_base64 DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#user_data_base64}
  */
  readonly userDataBase64?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    network_data: cdktf.stringToTerraform(struct!.networkData),
    network_data_base64: cdktf.stringToTerraform(struct!.networkDataBase64),
    network_data_secret_ref: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRefToTerraform(struct!.networkDataSecretRef),
    secret_ref: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRefToTerraform(struct!.secretRef),
    user_data: cdktf.stringToTerraform(struct!.userData),
    user_data_base64: cdktf.stringToTerraform(struct!.userDataBase64),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    network_data: {
      value: cdktf.stringToHclTerraform(struct!.networkData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_data_base64: {
      value: cdktf.stringToHclTerraform(struct!.networkDataBase64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_data_secret_ref: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRefToHclTerraform(struct!.networkDataSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef",
    },
    secret_ref: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef",
    },
    user_data: {
      value: cdktf.stringToHclTerraform(struct!.userData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_data_base64: {
      value: cdktf.stringToHclTerraform(struct!.userDataBase64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._networkData !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkData = this._networkData;
    }
    if (this._networkDataBase64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkDataBase64 = this._networkDataBase64;
    }
    if (this._networkDataSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkDataSecretRef = this._networkDataSecretRef?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._userData !== undefined) {
      hasAnyValues = true;
      internalValueResult.userData = this._userData;
    }
    if (this._userDataBase64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.userDataBase64 = this._userDataBase64;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._networkData = undefined;
      this._networkDataBase64 = undefined;
      this._networkDataSecretRef.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._userData = undefined;
      this._userDataBase64 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._networkData = value.networkData;
      this._networkDataBase64 = value.networkDataBase64;
      this._networkDataSecretRef.internalValue = value.networkDataSecretRef;
      this._secretRef.internalValue = value.secretRef;
      this._userData = value.userData;
      this._userDataBase64 = value.userDataBase64;
    }
  }

  // network_data - computed: false, optional: true, required: false
  private _networkData?: string; 
  public get networkData() {
    return this.getStringAttribute('network_data');
  }
  public set networkData(value: string) {
    this._networkData = value;
  }
  public resetNetworkData() {
    this._networkData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDataInput() {
    return this._networkData;
  }

  // network_data_base64 - computed: false, optional: true, required: false
  private _networkDataBase64?: string; 
  public get networkDataBase64() {
    return this.getStringAttribute('network_data_base64');
  }
  public set networkDataBase64(value: string) {
    this._networkDataBase64 = value;
  }
  public resetNetworkDataBase64() {
    this._networkDataBase64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDataBase64Input() {
    return this._networkDataBase64;
  }

  // network_data_secret_ref - computed: false, optional: true, required: false
  private _networkDataSecretRef = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRefOutputReference(this, "network_data_secret_ref");
  public get networkDataSecretRef() {
    return this._networkDataSecretRef;
  }
  public putNetworkDataSecretRef(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveNetworkDataSecretRef) {
    this._networkDataSecretRef.internalValue = value;
  }
  public resetNetworkDataSecretRef() {
    this._networkDataSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDataSecretRefInput() {
    return this._networkDataSecretRef.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // user_data - computed: false, optional: true, required: false
  private _userData?: string; 
  public get userData() {
    return this.getStringAttribute('user_data');
  }
  public set userData(value: string) {
    this._userData = value;
  }
  public resetUserData() {
    this._userData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userDataInput() {
    return this._userData;
  }

  // user_data_base64 - computed: false, optional: true, required: false
  private _userDataBase64?: string; 
  public get userDataBase64() {
    return this.getStringAttribute('user_data_base64');
  }
  public set userDataBase64(value: string) {
    this._userDataBase64 = value;
  }
  public resetUserDataBase64() {
    this._userDataBase64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userDataBase64Input() {
    return this._userDataBase64;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRefToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRefToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRefToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRefToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud {
  /**
  * NetworkData contains NoCloud inline cloud-init networkdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#network_data DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#network_data}
  */
  readonly networkData?: string;
  /**
  * NetworkDataBase64 contains NoCloud cloud-init networkdata as a base64 encoded string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#network_data_base64 DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#network_data_base64}
  */
  readonly networkDataBase64?: string;
  /**
  * NetworkDataSecretRef references a k8s secret that contains NoCloud networkdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#network_data_secret_ref DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#network_data_secret_ref}
  */
  readonly networkDataSecretRef?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef;
  /**
  * UserDataSecretRef references a k8s secret that contains NoCloud userdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#secret_ref DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#secret_ref}
  */
  readonly secretRef?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef;
  /**
  * UserData contains NoCloud inline cloud-init userdata.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#user_data DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#user_data}
  */
  readonly userData?: string;
  /**
  * UserDataBase64 contains NoCloud cloud-init userdata as a base64 encoded string.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#user_data_base64 DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#user_data_base64}
  */
  readonly userDataBase64?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    network_data: cdktf.stringToTerraform(struct!.networkData),
    network_data_base64: cdktf.stringToTerraform(struct!.networkDataBase64),
    network_data_secret_ref: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRefToTerraform(struct!.networkDataSecretRef),
    secret_ref: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRefToTerraform(struct!.secretRef),
    user_data: cdktf.stringToTerraform(struct!.userData),
    user_data_base64: cdktf.stringToTerraform(struct!.userDataBase64),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    network_data: {
      value: cdktf.stringToHclTerraform(struct!.networkData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_data_base64: {
      value: cdktf.stringToHclTerraform(struct!.networkDataBase64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    network_data_secret_ref: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRefToHclTerraform(struct!.networkDataSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef",
    },
    secret_ref: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRefToHclTerraform(struct!.secretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef",
    },
    user_data: {
      value: cdktf.stringToHclTerraform(struct!.userData),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_data_base64: {
      value: cdktf.stringToHclTerraform(struct!.userDataBase64),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._networkData !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkData = this._networkData;
    }
    if (this._networkDataBase64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkDataBase64 = this._networkDataBase64;
    }
    if (this._networkDataSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networkDataSecretRef = this._networkDataSecretRef?.internalValue;
    }
    if (this._secretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretRef = this._secretRef?.internalValue;
    }
    if (this._userData !== undefined) {
      hasAnyValues = true;
      internalValueResult.userData = this._userData;
    }
    if (this._userDataBase64 !== undefined) {
      hasAnyValues = true;
      internalValueResult.userDataBase64 = this._userDataBase64;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._networkData = undefined;
      this._networkDataBase64 = undefined;
      this._networkDataSecretRef.internalValue = undefined;
      this._secretRef.internalValue = undefined;
      this._userData = undefined;
      this._userDataBase64 = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._networkData = value.networkData;
      this._networkDataBase64 = value.networkDataBase64;
      this._networkDataSecretRef.internalValue = value.networkDataSecretRef;
      this._secretRef.internalValue = value.secretRef;
      this._userData = value.userData;
      this._userDataBase64 = value.userDataBase64;
    }
  }

  // network_data - computed: false, optional: true, required: false
  private _networkData?: string; 
  public get networkData() {
    return this.getStringAttribute('network_data');
  }
  public set networkData(value: string) {
    this._networkData = value;
  }
  public resetNetworkData() {
    this._networkData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDataInput() {
    return this._networkData;
  }

  // network_data_base64 - computed: false, optional: true, required: false
  private _networkDataBase64?: string; 
  public get networkDataBase64() {
    return this.getStringAttribute('network_data_base64');
  }
  public set networkDataBase64(value: string) {
    this._networkDataBase64 = value;
  }
  public resetNetworkDataBase64() {
    this._networkDataBase64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDataBase64Input() {
    return this._networkDataBase64;
  }

  // network_data_secret_ref - computed: false, optional: true, required: false
  private _networkDataSecretRef = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRefOutputReference(this, "network_data_secret_ref");
  public get networkDataSecretRef() {
    return this._networkDataSecretRef;
  }
  public putNetworkDataSecretRef(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudNetworkDataSecretRef) {
    this._networkDataSecretRef.internalValue = value;
  }
  public resetNetworkDataSecretRef() {
    this._networkDataSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkDataSecretRefInput() {
    return this._networkDataSecretRef.internalValue;
  }

  // secret_ref - computed: false, optional: true, required: false
  private _secretRef = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRefOutputReference(this, "secret_ref");
  public get secretRef() {
    return this._secretRef;
  }
  public putSecretRef(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudSecretRef) {
    this._secretRef.internalValue = value;
  }
  public resetSecretRef() {
    this._secretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretRefInput() {
    return this._secretRef.internalValue;
  }

  // user_data - computed: false, optional: true, required: false
  private _userData?: string; 
  public get userData() {
    return this.getStringAttribute('user_data');
  }
  public set userData(value: string) {
    this._userData = value;
  }
  public resetUserData() {
    this._userData = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userDataInput() {
    return this._userData;
  }

  // user_data_base64 - computed: false, optional: true, required: false
  private _userDataBase64?: string; 
  public get userDataBase64() {
    return this.getStringAttribute('user_data_base64');
  }
  public set userDataBase64(value: string) {
    this._userDataBase64 = value;
  }
  public resetUserDataBase64() {
    this._userDataBase64 = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userDataBase64Input() {
    return this._userDataBase64;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name?: string;
  /**
  * Specify whether the ConfigMap or it's keys must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#optional DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
  /**
  * The volume label of the resulting disk inside the VMI. Different bootstrapping mechanisms require different values. Typical values are 'cidata' (cloud-init), 'config-2' (cloud-init) or 'OEMDRV' (kickstart).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#volume_label DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#volume_label}
  */
  readonly volumeLabel?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMapToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    optional: cdktf.booleanToTerraform(struct!.optional),
    volume_label: cdktf.stringToTerraform(struct!.volumeLabel),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMapToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    volume_label: {
      value: cdktf.stringToHclTerraform(struct!.volumeLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    if (this._volumeLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeLabel = this._volumeLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._optional = undefined;
      this._volumeLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._optional = value.optional;
      this._volumeLabel = value.volumeLabel;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }

  // volume_label - computed: false, optional: true, required: false
  private _volumeLabel?: string; 
  public get volumeLabel() {
    return this.getStringAttribute('volume_label');
  }
  public set volumeLabel(value: string) {
    this._volumeLabel = value;
  }
  public resetVolumeLabel() {
    this._volumeLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeLabelInput() {
    return this._volumeLabel;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk {
  /**
  * Image is the name of the image with the embedded disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#image DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#image}
  */
  readonly image: string;
  /**
  * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#image_pull_policy DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#image_pull_policy}
  */
  readonly imagePullPolicy?: string;
  /**
  * ImagePullSecret is the name of the Docker registry secret required to pull the image. The secret must already exist.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#image_pull_secret DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#image_pull_secret}
  */
  readonly imagePullSecret?: string;
  /**
  * Path defines the path to disk file in the container
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#path DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#path}
  */
  readonly path?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDiskToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    image: cdktf.stringToTerraform(struct!.image),
    image_pull_policy: cdktf.stringToTerraform(struct!.imagePullPolicy),
    image_pull_secret: cdktf.stringToTerraform(struct!.imagePullSecret),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDiskToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    image: {
      value: cdktf.stringToHclTerraform(struct!.image),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_policy: {
      value: cdktf.stringToHclTerraform(struct!.imagePullPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    image_pull_secret: {
      value: cdktf.stringToHclTerraform(struct!.imagePullSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._image !== undefined) {
      hasAnyValues = true;
      internalValueResult.image = this._image;
    }
    if (this._imagePullPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullPolicy = this._imagePullPolicy;
    }
    if (this._imagePullSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.imagePullSecret = this._imagePullSecret;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._image = undefined;
      this._imagePullPolicy = undefined;
      this._imagePullSecret = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._image = value.image;
      this._imagePullPolicy = value.imagePullPolicy;
      this._imagePullSecret = value.imagePullSecret;
      this._path = value.path;
    }
  }

  // image - computed: false, optional: false, required: true
  private _image?: string; 
  public get image() {
    return this.getStringAttribute('image');
  }
  public set image(value: string) {
    this._image = value;
  }
  // Temporarily expose input value. Use with caution.
  public get imageInput() {
    return this._image;
  }

  // image_pull_policy - computed: false, optional: true, required: false
  private _imagePullPolicy?: string; 
  public get imagePullPolicy() {
    return this.getStringAttribute('image_pull_policy');
  }
  public set imagePullPolicy(value: string) {
    this._imagePullPolicy = value;
  }
  public resetImagePullPolicy() {
    this._imagePullPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullPolicyInput() {
    return this._imagePullPolicy;
  }

  // image_pull_secret - computed: false, optional: true, required: false
  private _imagePullSecret?: string; 
  public get imagePullSecret() {
    return this.getStringAttribute('image_pull_secret');
  }
  public set imagePullSecret(value: string) {
    this._imagePullSecret = value;
  }
  public resetImagePullSecret() {
    this._imagePullSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get imagePullSecretInput() {
    return this._imagePullSecret;
  }

  // path - computed: false, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume {
  /**
  * Hotpluggable indicates whether the volume can be hotplugged and hotunplugged.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#hotpluggable DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#hotpluggable}
  */
  readonly hotpluggable?: boolean | cdktf.IResolvable;
  /**
  * Name of both the DataVolume and the PVC in the same namespace. After PVC population the DataVolume is garbage collected by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolumeToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    hotpluggable: cdktf.booleanToTerraform(struct!.hotpluggable),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolumeToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    hotpluggable: {
      value: cdktf.booleanToHclTerraform(struct!.hotpluggable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolumeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._hotpluggable !== undefined) {
      hasAnyValues = true;
      internalValueResult.hotpluggable = this._hotpluggable;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._hotpluggable = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._hotpluggable = value.hotpluggable;
      this._name = value.name;
    }
  }

  // hotpluggable - computed: false, optional: true, required: false
  private _hotpluggable?: boolean | cdktf.IResolvable; 
  public get hotpluggable() {
    return this.getBooleanAttribute('hotpluggable');
  }
  public set hotpluggable(value: boolean | cdktf.IResolvable) {
    this._hotpluggable = value;
  }
  public resetHotpluggable() {
    this._hotpluggable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hotpluggableInput() {
    return this._hotpluggable;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef {
  /**
  * Version of the schema the FieldPath is written in terms of, defaults to 'v1'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#api_version DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Path of the field to select in the specified API version.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#field_path DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#field_path}
  */
  readonly fieldPath: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRefToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    field_path: cdktf.stringToTerraform(struct!.fieldPath),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRefToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    field_path: {
      value: cdktf.stringToHclTerraform(struct!.fieldPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._fieldPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldPath = this._fieldPath;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiVersion = undefined;
      this._fieldPath = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiVersion = value.apiVersion;
      this._fieldPath = value.fieldPath;
    }
  }

  // api_version - computed: false, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // field_path - computed: false, optional: false, required: true
  private _fieldPath?: string; 
  public get fieldPath() {
    return this.getStringAttribute('field_path');
  }
  public set fieldPath(value: string) {
    this._fieldPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldPathInput() {
    return this._fieldPath;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef {
  /**
  * Container name: required for volumes, optional for env vars
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#container_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#container_name}
  */
  readonly containerName?: string;
  /**
  * Specifies the output format of the exposed resources, defaults to '1'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#divisor DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#divisor}
  */
  readonly divisor?: string;
  /**
  * Required: resource to select
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#resource DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#resource}
  */
  readonly resource: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRefToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    container_name: cdktf.stringToTerraform(struct!.containerName),
    divisor: cdktf.stringToTerraform(struct!.divisor),
    resource: cdktf.stringToTerraform(struct!.resource),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRefToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    divisor: {
      value: cdktf.stringToHclTerraform(struct!.divisor),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource: {
      value: cdktf.stringToHclTerraform(struct!.resource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._divisor !== undefined) {
      hasAnyValues = true;
      internalValueResult.divisor = this._divisor;
    }
    if (this._resource !== undefined) {
      hasAnyValues = true;
      internalValueResult.resource = this._resource;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._containerName = undefined;
      this._divisor = undefined;
      this._resource = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._containerName = value.containerName;
      this._divisor = value.divisor;
      this._resource = value.resource;
    }
  }

  // container_name - computed: false, optional: true, required: false
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  public resetContainerName() {
    this._containerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // divisor - computed: false, optional: true, required: false
  private _divisor?: string; 
  public get divisor() {
    return this.getStringAttribute('divisor');
  }
  public set divisor(value: string) {
    this._divisor = value;
  }
  public resetDivisor() {
    this._divisor = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get divisorInput() {
    return this._divisor;
  }

  // resource - computed: false, optional: false, required: true
  private _resource?: string; 
  public get resource() {
    return this.getStringAttribute('resource');
  }
  public set resource(value: string) {
    this._resource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceInput() {
    return this._resource;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields {
  /**
  * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#field_ref DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#field_ref}
  */
  readonly fieldRef?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef;
  /**
  * Optional: mode bits used to set permissions on this file, must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. YAML accepts both octal and decimal values, JSON requires decimal values for mode bits. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#mode DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#mode}
  */
  readonly mode?: number;
  /**
  * Required: Path is the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#path DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#path}
  */
  readonly path: string;
  /**
  * Selects a resource of the container: only resources limits and requests (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#resource_field_ref DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#resource_field_ref}
  */
  readonly resourceFieldRef?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    field_ref: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRefToTerraform(struct!.fieldRef),
    mode: cdktf.numberToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
    resource_field_ref: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRefToTerraform(struct!.resourceFieldRef),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    field_ref: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRefToHclTerraform(struct!.fieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef",
    },
    mode: {
      value: cdktf.numberToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_field_ref: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRefToHclTerraform(struct!.resourceFieldRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fieldRef = this._fieldRef?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._resourceFieldRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceFieldRef = this._resourceFieldRef?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fieldRef.internalValue = undefined;
      this._mode = undefined;
      this._path = undefined;
      this._resourceFieldRef.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fieldRef.internalValue = value.fieldRef;
      this._mode = value.mode;
      this._path = value.path;
      this._resourceFieldRef.internalValue = value.resourceFieldRef;
    }
  }

  // field_ref - computed: false, optional: true, required: false
  private _fieldRef = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRefOutputReference(this, "field_ref");
  public get fieldRef() {
    return this._fieldRef;
  }
  public putFieldRef(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsFieldRef) {
    this._fieldRef.internalValue = value;
  }
  public resetFieldRef() {
    this._fieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldRefInput() {
    return this._fieldRef.internalValue;
  }

  // mode - computed: false, optional: true, required: false
  private _mode?: number; 
  public get mode() {
    return this.getNumberAttribute('mode');
  }
  public set mode(value: number) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // resource_field_ref - computed: false, optional: true, required: false
  private _resourceFieldRef = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRefOutputReference(this, "resource_field_ref");
  public get resourceFieldRef() {
    return this._resourceFieldRef;
  }
  public putResourceFieldRef(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsResourceFieldRef) {
    this._resourceFieldRef.internalValue = value;
  }
  public resetResourceFieldRef() {
    this._resourceFieldRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceFieldRefInput() {
    return this._resourceFieldRef.internalValue;
  }
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsList extends cdktf.ComplexList {
  public internalValue? : DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsOutputReference {
    return new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi {
  /**
  * Fields is a list of downward API volume file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#fields DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#fields}
  */
  readonly fields?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields[] | cdktf.IResolvable;
  /**
  * The volume label of the resulting disk inside the VMI. Different bootstrapping mechanisms require different values. Typical values are 'cidata' (cloud-init), 'config-2' (cloud-init) or 'OEMDRV' (kickstart).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#volume_label DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#volume_label}
  */
  readonly volumeLabel?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    fields: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsToTerraform, false)(struct!.fields),
    volume_label: cdktf.stringToTerraform(struct!.volumeLabel),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    fields: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsToHclTerraform, false)(struct!.fields),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsList",
    },
    volume_label: {
      value: cdktf.stringToHclTerraform(struct!.volumeLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._fields?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.fields = this._fields?.internalValue;
    }
    if (this._volumeLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeLabel = this._volumeLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._fields.internalValue = undefined;
      this._volumeLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._fields.internalValue = value.fields;
      this._volumeLabel = value.volumeLabel;
    }
  }

  // fields - computed: false, optional: true, required: false
  private _fields = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFieldsList(this, "fields", false);
  public get fields() {
    return this._fields;
  }
  public putFields(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiFields[] | cdktf.IResolvable) {
    this._fields.internalValue = value;
  }
  public resetFields() {
    this._fields.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fieldsInput() {
    return this._fields.internalValue;
  }

  // volume_label - computed: false, optional: true, required: false
  private _volumeLabel?: string; 
  public get volumeLabel() {
    return this.getStringAttribute('volume_label');
  }
  public set volumeLabel(value: string) {
    this._volumeLabel = value;
  }
  public resetVolumeLabel() {
    this._volumeLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeLabelInput() {
    return this._volumeLabel;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk {
  /**
  * Capacity of the sparse disk.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#capacity DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#capacity}
  */
  readonly capacity: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDiskToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    capacity: cdktf.stringToTerraform(struct!.capacity),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDiskToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    capacity: {
      value: cdktf.stringToHclTerraform(struct!.capacity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._capacity !== undefined) {
      hasAnyValues = true;
      internalValueResult.capacity = this._capacity;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._capacity = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._capacity = value.capacity;
    }
  }

  // capacity - computed: false, optional: false, required: true
  private _capacity?: string; 
  public get capacity() {
    return this.getStringAttribute('capacity');
  }
  public set capacity(value: string) {
    this._capacity = value;
  }
  // Temporarily expose input value. Use with caution.
  public get capacityInput() {
    return this._capacity;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim {
  /**
  * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#claim_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#claim_name}
  */
  readonly claimName: string;
  /**
  * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#read_only DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaimToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claim_name: cdktf.stringToTerraform(struct!.claimName),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaimToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claim_name: {
      value: cdktf.stringToHclTerraform(struct!.claimName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaimOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claimName !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimName = this._claimName;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claimName = undefined;
      this._readOnly = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claimName = value.claimName;
      this._readOnly = value.readOnly;
    }
  }

  // claim_name - computed: false, optional: false, required: true
  private _claimName?: string; 
  public get claimName() {
    return this.getStringAttribute('claim_name');
  }
  public set claimName(value: string) {
    this._claimName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get claimNameInput() {
    return this._claimName;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral {
  /**
  * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. Directly attached to the vmi via qemu. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#persistent_volume_claim DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#persistent_volume_claim}
  */
  readonly persistentVolumeClaim?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    persistent_volume_claim: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaimToTerraform(struct!.persistentVolumeClaim),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    persistent_volume_claim: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaimToHclTerraform(struct!.persistentVolumeClaim),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._persistentVolumeClaim?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistentVolumeClaim = this._persistentVolumeClaim?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._persistentVolumeClaim.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._persistentVolumeClaim.internalValue = value.persistentVolumeClaim;
    }
  }

  // persistent_volume_claim - computed: false, optional: true, required: false
  private _persistentVolumeClaim = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaimOutputReference(this, "persistent_volume_claim");
  public get persistentVolumeClaim() {
    return this._persistentVolumeClaim;
  }
  public putPersistentVolumeClaim(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralPersistentVolumeClaim) {
    this._persistentVolumeClaim.internalValue = value;
  }
  public resetPersistentVolumeClaim() {
    this._persistentVolumeClaim.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistentVolumeClaimInput() {
    return this._persistentVolumeClaim.internalValue;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk {
  /**
  * Capacity of the sparse disk
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#capacity DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#capacity}
  */
  readonly capacity?: string;
  /**
  * The path to HostDisk image located on the cluster
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#path DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#path}
  */
  readonly path: string;
  /**
  * Shared indicate whether the path is shared between nodes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#shared DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#shared}
  */
  readonly shared?: boolean | cdktf.IResolvable;
  /**
  * Contains information if disk.img exists or should be created allowed options are 'Disk' and 'DiskOrCreate'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#type DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#type}
  */
  readonly type: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDiskToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    capacity: cdktf.stringToTerraform(struct!.capacity),
    path: cdktf.stringToTerraform(struct!.path),
    shared: cdktf.booleanToTerraform(struct!.shared),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDiskToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    capacity: {
      value: cdktf.stringToHclTerraform(struct!.capacity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    shared: {
      value: cdktf.booleanToHclTerraform(struct!.shared),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._capacity !== undefined) {
      hasAnyValues = true;
      internalValueResult.capacity = this._capacity;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    if (this._shared !== undefined) {
      hasAnyValues = true;
      internalValueResult.shared = this._shared;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._capacity = undefined;
      this._path = undefined;
      this._shared = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._capacity = value.capacity;
      this._path = value.path;
      this._shared = value.shared;
      this._type = value.type;
    }
  }

  // capacity - computed: false, optional: true, required: false
  private _capacity?: string; 
  public get capacity() {
    return this.getStringAttribute('capacity');
  }
  public set capacity(value: string) {
    this._capacity = value;
  }
  public resetCapacity() {
    this._capacity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get capacityInput() {
    return this._capacity;
  }

  // path - computed: false, optional: false, required: true
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }

  // shared - computed: false, optional: true, required: false
  private _shared?: boolean | cdktf.IResolvable; 
  public get shared() {
    return this.getBooleanAttribute('shared');
  }
  public set shared(value: boolean | cdktf.IResolvable) {
    this._shared = value;
  }
  public resetShared() {
    this._shared = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sharedInput() {
    return this._shared;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump {
  /**
  * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#claim_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#claim_name}
  */
  readonly claimName: string;
  /**
  * Hotpluggable indicates whether the volume can be hotplugged and hotunplugged.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#hotpluggable DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#hotpluggable}
  */
  readonly hotpluggable?: boolean | cdktf.IResolvable;
  /**
  * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#read_only DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDumpToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claim_name: cdktf.stringToTerraform(struct!.claimName),
    hotpluggable: cdktf.booleanToTerraform(struct!.hotpluggable),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDumpToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claim_name: {
      value: cdktf.stringToHclTerraform(struct!.claimName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hotpluggable: {
      value: cdktf.booleanToHclTerraform(struct!.hotpluggable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDumpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claimName !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimName = this._claimName;
    }
    if (this._hotpluggable !== undefined) {
      hasAnyValues = true;
      internalValueResult.hotpluggable = this._hotpluggable;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claimName = undefined;
      this._hotpluggable = undefined;
      this._readOnly = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claimName = value.claimName;
      this._hotpluggable = value.hotpluggable;
      this._readOnly = value.readOnly;
    }
  }

  // claim_name - computed: false, optional: false, required: true
  private _claimName?: string; 
  public get claimName() {
    return this.getStringAttribute('claim_name');
  }
  public set claimName(value: string) {
    this._claimName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get claimNameInput() {
    return this._claimName;
  }

  // hotpluggable - computed: false, optional: true, required: false
  private _hotpluggable?: boolean | cdktf.IResolvable; 
  public get hotpluggable() {
    return this.getBooleanAttribute('hotpluggable');
  }
  public set hotpluggable(value: boolean | cdktf.IResolvable) {
    this._hotpluggable = value;
  }
  public resetHotpluggable() {
    this._hotpluggable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hotpluggableInput() {
    return this._hotpluggable;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim {
  /**
  * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#claim_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#claim_name}
  */
  readonly claimName: string;
  /**
  * Hotpluggable indicates whether the volume can be hotplugged and hotunplugged.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#hotpluggable DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#hotpluggable}
  */
  readonly hotpluggable?: boolean | cdktf.IResolvable;
  /**
  * readOnly Will force the ReadOnly setting in VolumeMounts. Default false.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#read_only DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#read_only}
  */
  readonly readOnly?: boolean | cdktf.IResolvable;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaimToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    claim_name: cdktf.stringToTerraform(struct!.claimName),
    hotpluggable: cdktf.booleanToTerraform(struct!.hotpluggable),
    read_only: cdktf.booleanToTerraform(struct!.readOnly),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaimToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    claim_name: {
      value: cdktf.stringToHclTerraform(struct!.claimName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hotpluggable: {
      value: cdktf.booleanToHclTerraform(struct!.hotpluggable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    read_only: {
      value: cdktf.booleanToHclTerraform(struct!.readOnly),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaimOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._claimName !== undefined) {
      hasAnyValues = true;
      internalValueResult.claimName = this._claimName;
    }
    if (this._hotpluggable !== undefined) {
      hasAnyValues = true;
      internalValueResult.hotpluggable = this._hotpluggable;
    }
    if (this._readOnly !== undefined) {
      hasAnyValues = true;
      internalValueResult.readOnly = this._readOnly;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._claimName = undefined;
      this._hotpluggable = undefined;
      this._readOnly = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._claimName = value.claimName;
      this._hotpluggable = value.hotpluggable;
      this._readOnly = value.readOnly;
    }
  }

  // claim_name - computed: false, optional: false, required: true
  private _claimName?: string; 
  public get claimName() {
    return this.getStringAttribute('claim_name');
  }
  public set claimName(value: string) {
    this._claimName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get claimNameInput() {
    return this._claimName;
  }

  // hotpluggable - computed: false, optional: true, required: false
  private _hotpluggable?: boolean | cdktf.IResolvable; 
  public get hotpluggable() {
    return this.getBooleanAttribute('hotpluggable');
  }
  public set hotpluggable(value: boolean | cdktf.IResolvable) {
    this._hotpluggable = value;
  }
  public resetHotpluggable() {
    this._hotpluggable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hotpluggableInput() {
    return this._hotpluggable;
  }

  // read_only - computed: false, optional: true, required: false
  private _readOnly?: boolean | cdktf.IResolvable; 
  public get readOnly() {
    return this.getBooleanAttribute('read_only');
  }
  public set readOnly(value: boolean | cdktf.IResolvable) {
    this._readOnly = value;
  }
  public resetReadOnly() {
    this._readOnly = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readOnlyInput() {
    return this._readOnly;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret {
  /**
  * Specify whether the Secret or it's keys must be defined
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#optional DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#optional}
  */
  readonly optional?: boolean | cdktf.IResolvable;
  /**
  * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#secret_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#secret_name}
  */
  readonly secretName?: string;
  /**
  * The volume label of the resulting disk inside the VMI. Different bootstrapping mechanisms require different values. Typical values are 'cidata' (cloud-init), 'config-2' (cloud-init) or 'OEMDRV' (kickstart).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#volume_label DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#volume_label}
  */
  readonly volumeLabel?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecretToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    optional: cdktf.booleanToTerraform(struct!.optional),
    secret_name: cdktf.stringToTerraform(struct!.secretName),
    volume_label: cdktf.stringToTerraform(struct!.volumeLabel),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecretToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    optional: {
      value: cdktf.booleanToHclTerraform(struct!.optional),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    secret_name: {
      value: cdktf.stringToHclTerraform(struct!.secretName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    volume_label: {
      value: cdktf.stringToHclTerraform(struct!.volumeLabel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._optional !== undefined) {
      hasAnyValues = true;
      internalValueResult.optional = this._optional;
    }
    if (this._secretName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretName = this._secretName;
    }
    if (this._volumeLabel !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumeLabel = this._volumeLabel;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._optional = undefined;
      this._secretName = undefined;
      this._volumeLabel = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._optional = value.optional;
      this._secretName = value.secretName;
      this._volumeLabel = value.volumeLabel;
    }
  }

  // optional - computed: false, optional: true, required: false
  private _optional?: boolean | cdktf.IResolvable; 
  public get optional() {
    return this.getBooleanAttribute('optional');
  }
  public set optional(value: boolean | cdktf.IResolvable) {
    this._optional = value;
  }
  public resetOptional() {
    this._optional = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get optionalInput() {
    return this._optional;
  }

  // secret_name - computed: false, optional: true, required: false
  private _secretName?: string; 
  public get secretName() {
    return this.getStringAttribute('secret_name');
  }
  public set secretName(value: string) {
    this._secretName = value;
  }
  public resetSecretName() {
    this._secretName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretNameInput() {
    return this._secretName;
  }

  // volume_label - computed: false, optional: true, required: false
  private _volumeLabel?: string; 
  public get volumeLabel() {
    return this.getStringAttribute('volume_label');
  }
  public set volumeLabel(value: string) {
    this._volumeLabel = value;
  }
  public resetVolumeLabel() {
    this._volumeLabel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumeLabelInput() {
    return this._volumeLabel;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount {
  /**
  * Name of the service account in the pod's namespace to use. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#service_account_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#service_account_name}
  */
  readonly serviceAccountName?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccountToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    service_account_name: cdktf.stringToTerraform(struct!.serviceAccountName),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccountToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    service_account_name: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccountOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._serviceAccountName !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountName = this._serviceAccountName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._serviceAccountName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._serviceAccountName = value.serviceAccountName;
    }
  }

  // service_account_name - computed: false, optional: true, required: false
  private _serviceAccountName?: string; 
  public get serviceAccountName() {
    return this.getStringAttribute('service_account_name');
  }
  public set serviceAccountName(value: string) {
    this._serviceAccountName = value;
  }
  public resetServiceAccountName() {
    this._serviceAccountName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountNameInput() {
    return this._serviceAccountName;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMapToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMapToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMapOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret {
  /**
  * Name of the referent. This field is effectively required, but due to backwards compatibility is allowed to be empty. Instances of this type with an empty value here are almost certainly wrong. TODO: Add other useful fields. apiVersion, kind, uid? More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Drop 'kubebuilder:default' when controller-gen doesn't need it https://github.com/kubernetes-sigs/kubebuilder/issues/3896.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name?: string;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecretToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecretToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecretOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep {
  /**
  * ConfigMap references a ConfigMap that contains Sysprep answer file named autounattend.xml that should be attached as disk of CDROM type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#config_map DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#config_map}
  */
  readonly configMap?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap;
  /**
  * Secret references a k8s Secret that contains Sysprep answer file named autounattend.xml that should be attached as disk of CDROM type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#secret DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#secret}
  */
  readonly secret?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    config_map: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMapToTerraform(struct!.configMap),
    secret: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecretToTerraform(struct!.secret),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    config_map: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap",
    },
    secret: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._configMap.internalValue = undefined;
      this._secret.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._configMap.internalValue = value.configMap;
      this._secret.internalValue = value.secret;
    }
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes {
  /**
  * CloudInitConfigDrive represents a cloud-init Config Drive user-data source. The Config Drive data will be added as a disk to the vmi. A proper cloud-init installation is required inside the guest. More info: https://cloudinit.readthedocs.io/en/latest/topics/datasources/configdrive.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#cloud_init_config_drive DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#cloud_init_config_drive}
  */
  readonly cloudInitConfigDrive?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive;
  /**
  * CloudInitNoCloud represents a cloud-init NoCloud user-data source. The NoCloud data will be added as a disk to the vmi. A proper cloud-init installation is required inside the guest. More info: http://cloudinit.readthedocs.io/en/latest/topics/datasources/nocloud.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#cloud_init_no_cloud DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#cloud_init_no_cloud}
  */
  readonly cloudInitNoCloud?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud;
  /**
  * ConfigMapSource represents a reference to a ConfigMap in the same namespace. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#config_map DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#config_map}
  */
  readonly configMap?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap;
  /**
  * ContainerDisk references a docker image, embedding a qcow or raw disk. More info: https://kubevirt.gitbooks.io/user-guide/registry-disk.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#container_disk DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#container_disk}
  */
  readonly containerDisk?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk;
  /**
  * DataVolume represents the dynamic creation a PVC for this volume as well as the process of populating that PVC with a disk image.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#data_volume DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#data_volume}
  */
  readonly dataVolume?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume;
  /**
  * DownwardAPI represents downward API about the pod that should populate this volume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#downward_api DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#downward_api}
  */
  readonly downwardApi?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi;
  /**
  * DownwardMetrics adds a very small disk to VMIs which contains a limited view of host and guest metrics. The disk content is compatible with vhostmd (https://github.com/vhostmd/vhostmd) and vm-dump-metrics.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#downward_metrics DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#downward_metrics}
  */
  readonly downwardMetrics?: { [key: string]: string };
  /**
  * EmptyDisk represents a temporary disk which shares the vmis lifecycle. More info: https://kubevirt.gitbooks.io/user-guide/disks-and-volumes.html
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#empty_disk DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#empty_disk}
  */
  readonly emptyDisk?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk;
  /**
  * Ephemeral is a special volume source that 'wraps' specified source and provides copy-on-write image on top of it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#ephemeral DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#ephemeral}
  */
  readonly ephemeral?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral;
  /**
  * HostDisk represents a disk created on the cluster level
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#host_disk DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#host_disk}
  */
  readonly hostDisk?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk;
  /**
  * MemoryDump is attached to the virt launcher and is populated with a memory dump of the vmi
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#memory_dump DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#memory_dump}
  */
  readonly memoryDump?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump;
  /**
  * Volume's name. Must be a DNS_LABEL and unique within the vmi. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#name}
  */
  readonly name: string;
  /**
  * PersistentVolumeClaimVolumeSource represents a reference to a PersistentVolumeClaim in the same namespace. Directly attached to the vmi via qemu. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#persistent_volume_claim DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#persistent_volume_claim}
  */
  readonly persistentVolumeClaim?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim;
  /**
  * SecretVolumeSource represents a reference to a secret data in the same namespace. More info: https://kubernetes.io/docs/concepts/configuration/secret/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#secret DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#secret}
  */
  readonly secret?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret;
  /**
  * ServiceAccountVolumeSource represents a reference to a service account. There can only be one volume of this type! More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#service_account DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#service_account}
  */
  readonly serviceAccount?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount;
  /**
  * Represents a Sysprep volume source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#sysprep DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#sysprep}
  */
  readonly sysprep?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cloud_init_config_drive: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveToTerraform(struct!.cloudInitConfigDrive),
    cloud_init_no_cloud: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudToTerraform(struct!.cloudInitNoCloud),
    config_map: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMapToTerraform(struct!.configMap),
    container_disk: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDiskToTerraform(struct!.containerDisk),
    data_volume: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolumeToTerraform(struct!.dataVolume),
    downward_api: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiToTerraform(struct!.downwardApi),
    downward_metrics: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.downwardMetrics),
    empty_disk: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDiskToTerraform(struct!.emptyDisk),
    ephemeral: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralToTerraform(struct!.ephemeral),
    host_disk: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDiskToTerraform(struct!.hostDisk),
    memory_dump: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDumpToTerraform(struct!.memoryDump),
    name: cdktf.stringToTerraform(struct!.name),
    persistent_volume_claim: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaimToTerraform(struct!.persistentVolumeClaim),
    secret: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecretToTerraform(struct!.secret),
    service_account: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccountToTerraform(struct!.serviceAccount),
    sysprep: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepToTerraform(struct!.sysprep),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cloud_init_config_drive: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveToHclTerraform(struct!.cloudInitConfigDrive),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive",
    },
    cloud_init_no_cloud: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudToHclTerraform(struct!.cloudInitNoCloud),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud",
    },
    config_map: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMapToHclTerraform(struct!.configMap),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap",
    },
    container_disk: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDiskToHclTerraform(struct!.containerDisk),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk",
    },
    data_volume: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolumeToHclTerraform(struct!.dataVolume),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume",
    },
    downward_api: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiToHclTerraform(struct!.downwardApi),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi",
    },
    downward_metrics: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.downwardMetrics),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    empty_disk: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDiskToHclTerraform(struct!.emptyDisk),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk",
    },
    ephemeral: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralToHclTerraform(struct!.ephemeral),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral",
    },
    host_disk: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDiskToHclTerraform(struct!.hostDisk),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk",
    },
    memory_dump: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDumpToHclTerraform(struct!.memoryDump),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    persistent_volume_claim: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaimToHclTerraform(struct!.persistentVolumeClaim),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim",
    },
    secret: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecretToHclTerraform(struct!.secret),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret",
    },
    service_account: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccountToHclTerraform(struct!.serviceAccount),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount",
    },
    sysprep: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepToHclTerraform(struct!.sysprep),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cloudInitConfigDrive?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudInitConfigDrive = this._cloudInitConfigDrive?.internalValue;
    }
    if (this._cloudInitNoCloud?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cloudInitNoCloud = this._cloudInitNoCloud?.internalValue;
    }
    if (this._configMap?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.configMap = this._configMap?.internalValue;
    }
    if (this._containerDisk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerDisk = this._containerDisk?.internalValue;
    }
    if (this._dataVolume?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataVolume = this._dataVolume?.internalValue;
    }
    if (this._downwardApi?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.downwardApi = this._downwardApi?.internalValue;
    }
    if (this._downwardMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.downwardMetrics = this._downwardMetrics;
    }
    if (this._emptyDisk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDisk = this._emptyDisk?.internalValue;
    }
    if (this._ephemeral?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ephemeral = this._ephemeral?.internalValue;
    }
    if (this._hostDisk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostDisk = this._hostDisk?.internalValue;
    }
    if (this._memoryDump?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memoryDump = this._memoryDump?.internalValue;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._persistentVolumeClaim?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistentVolumeClaim = this._persistentVolumeClaim?.internalValue;
    }
    if (this._secret?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret?.internalValue;
    }
    if (this._serviceAccount?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccount = this._serviceAccount?.internalValue;
    }
    if (this._sysprep?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sysprep = this._sysprep?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cloudInitConfigDrive.internalValue = undefined;
      this._cloudInitNoCloud.internalValue = undefined;
      this._configMap.internalValue = undefined;
      this._containerDisk.internalValue = undefined;
      this._dataVolume.internalValue = undefined;
      this._downwardApi.internalValue = undefined;
      this._downwardMetrics = undefined;
      this._emptyDisk.internalValue = undefined;
      this._ephemeral.internalValue = undefined;
      this._hostDisk.internalValue = undefined;
      this._memoryDump.internalValue = undefined;
      this._name = undefined;
      this._persistentVolumeClaim.internalValue = undefined;
      this._secret.internalValue = undefined;
      this._serviceAccount.internalValue = undefined;
      this._sysprep.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cloudInitConfigDrive.internalValue = value.cloudInitConfigDrive;
      this._cloudInitNoCloud.internalValue = value.cloudInitNoCloud;
      this._configMap.internalValue = value.configMap;
      this._containerDisk.internalValue = value.containerDisk;
      this._dataVolume.internalValue = value.dataVolume;
      this._downwardApi.internalValue = value.downwardApi;
      this._downwardMetrics = value.downwardMetrics;
      this._emptyDisk.internalValue = value.emptyDisk;
      this._ephemeral.internalValue = value.ephemeral;
      this._hostDisk.internalValue = value.hostDisk;
      this._memoryDump.internalValue = value.memoryDump;
      this._name = value.name;
      this._persistentVolumeClaim.internalValue = value.persistentVolumeClaim;
      this._secret.internalValue = value.secret;
      this._serviceAccount.internalValue = value.serviceAccount;
      this._sysprep.internalValue = value.sysprep;
    }
  }

  // cloud_init_config_drive - computed: false, optional: true, required: false
  private _cloudInitConfigDrive = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDriveOutputReference(this, "cloud_init_config_drive");
  public get cloudInitConfigDrive() {
    return this._cloudInitConfigDrive;
  }
  public putCloudInitConfigDrive(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitConfigDrive) {
    this._cloudInitConfigDrive.internalValue = value;
  }
  public resetCloudInitConfigDrive() {
    this._cloudInitConfigDrive.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudInitConfigDriveInput() {
    return this._cloudInitConfigDrive.internalValue;
  }

  // cloud_init_no_cloud - computed: false, optional: true, required: false
  private _cloudInitNoCloud = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloudOutputReference(this, "cloud_init_no_cloud");
  public get cloudInitNoCloud() {
    return this._cloudInitNoCloud;
  }
  public putCloudInitNoCloud(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesCloudInitNoCloud) {
    this._cloudInitNoCloud.internalValue = value;
  }
  public resetCloudInitNoCloud() {
    this._cloudInitNoCloud.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cloudInitNoCloudInput() {
    return this._cloudInitNoCloud.internalValue;
  }

  // config_map - computed: false, optional: true, required: false
  private _configMap = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMapOutputReference(this, "config_map");
  public get configMap() {
    return this._configMap;
  }
  public putConfigMap(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesConfigMap) {
    this._configMap.internalValue = value;
  }
  public resetConfigMap() {
    this._configMap.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get configMapInput() {
    return this._configMap.internalValue;
  }

  // container_disk - computed: false, optional: true, required: false
  private _containerDisk = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDiskOutputReference(this, "container_disk");
  public get containerDisk() {
    return this._containerDisk;
  }
  public putContainerDisk(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesContainerDisk) {
    this._containerDisk.internalValue = value;
  }
  public resetContainerDisk() {
    this._containerDisk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerDiskInput() {
    return this._containerDisk.internalValue;
  }

  // data_volume - computed: false, optional: true, required: false
  private _dataVolume = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolumeOutputReference(this, "data_volume");
  public get dataVolume() {
    return this._dataVolume;
  }
  public putDataVolume(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDataVolume) {
    this._dataVolume.internalValue = value;
  }
  public resetDataVolume() {
    this._dataVolume.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataVolumeInput() {
    return this._dataVolume.internalValue;
  }

  // downward_api - computed: false, optional: true, required: false
  private _downwardApi = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApiOutputReference(this, "downward_api");
  public get downwardApi() {
    return this._downwardApi;
  }
  public putDownwardApi(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesDownwardApi) {
    this._downwardApi.internalValue = value;
  }
  public resetDownwardApi() {
    this._downwardApi.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get downwardApiInput() {
    return this._downwardApi.internalValue;
  }

  // downward_metrics - computed: false, optional: true, required: false
  private _downwardMetrics?: { [key: string]: string }; 
  public get downwardMetrics() {
    return this.getStringMapAttribute('downward_metrics');
  }
  public set downwardMetrics(value: { [key: string]: string }) {
    this._downwardMetrics = value;
  }
  public resetDownwardMetrics() {
    this._downwardMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get downwardMetricsInput() {
    return this._downwardMetrics;
  }

  // empty_disk - computed: false, optional: true, required: false
  private _emptyDisk = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDiskOutputReference(this, "empty_disk");
  public get emptyDisk() {
    return this._emptyDisk;
  }
  public putEmptyDisk(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEmptyDisk) {
    this._emptyDisk.internalValue = value;
  }
  public resetEmptyDisk() {
    this._emptyDisk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDiskInput() {
    return this._emptyDisk.internalValue;
  }

  // ephemeral - computed: false, optional: true, required: false
  private _ephemeral = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeralOutputReference(this, "ephemeral");
  public get ephemeral() {
    return this._ephemeral;
  }
  public putEphemeral(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesEphemeral) {
    this._ephemeral.internalValue = value;
  }
  public resetEphemeral() {
    this._ephemeral.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ephemeralInput() {
    return this._ephemeral.internalValue;
  }

  // host_disk - computed: false, optional: true, required: false
  private _hostDisk = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDiskOutputReference(this, "host_disk");
  public get hostDisk() {
    return this._hostDisk;
  }
  public putHostDisk(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesHostDisk) {
    this._hostDisk.internalValue = value;
  }
  public resetHostDisk() {
    this._hostDisk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostDiskInput() {
    return this._hostDisk.internalValue;
  }

  // memory_dump - computed: false, optional: true, required: false
  private _memoryDump = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDumpOutputReference(this, "memory_dump");
  public get memoryDump() {
    return this._memoryDump;
  }
  public putMemoryDump(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesMemoryDump) {
    this._memoryDump.internalValue = value;
  }
  public resetMemoryDump() {
    this._memoryDump.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryDumpInput() {
    return this._memoryDump.internalValue;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // persistent_volume_claim - computed: false, optional: true, required: false
  private _persistentVolumeClaim = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaimOutputReference(this, "persistent_volume_claim");
  public get persistentVolumeClaim() {
    return this._persistentVolumeClaim;
  }
  public putPersistentVolumeClaim(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesPersistentVolumeClaim) {
    this._persistentVolumeClaim.internalValue = value;
  }
  public resetPersistentVolumeClaim() {
    this._persistentVolumeClaim.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistentVolumeClaimInput() {
    return this._persistentVolumeClaim.internalValue;
  }

  // secret - computed: false, optional: true, required: false
  private _secret = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecretOutputReference(this, "secret");
  public get secret() {
    return this._secret;
  }
  public putSecret(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSecret) {
    this._secret.internalValue = value;
  }
  public resetSecret() {
    this._secret.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret.internalValue;
  }

  // service_account - computed: false, optional: true, required: false
  private _serviceAccount = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccountOutputReference(this, "service_account");
  public get serviceAccount() {
    return this._serviceAccount;
  }
  public putServiceAccount(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesServiceAccount) {
    this._serviceAccount.internalValue = value;
  }
  public resetServiceAccount() {
    this._serviceAccount.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountInput() {
    return this._serviceAccount.internalValue;
  }

  // sysprep - computed: false, optional: true, required: false
  private _sysprep = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprepOutputReference(this, "sysprep");
  public get sysprep() {
    return this._sysprep;
  }
  public putSysprep(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesSysprep) {
    this._sysprep.internalValue = value;
  }
  public resetSysprep() {
    this._sysprep.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sysprepInput() {
    return this._sysprep.internalValue;
  }
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesList extends cdktf.ComplexList {
  public internalValue? : DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesOutputReference {
    return new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec {
  /**
  * Specifies a set of public keys to inject into the vm guest
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#access_credentials DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#access_credentials}
  */
  readonly accessCredentials?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentials[] | cdktf.IResolvable;
  /**
  * If affinity is specifies, obey all the affinity rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#affinity DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#affinity}
  */
  readonly affinity?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinity;
  /**
  * Specifies the architecture of the vm guest you are attempting to run. Defaults to the compiled architecture of the KubeVirt components
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#architecture DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#architecture}
  */
  readonly architecture?: string;
  /**
  * Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#dns_config DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#dns_config}
  */
  readonly dnsConfig?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfig;
  /**
  * Set DNS policy for the pod. Defaults to 'ClusterFirst'. Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#dns_policy DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#dns_policy}
  */
  readonly dnsPolicy?: string;
  /**
  * Specification of the desired behavior of the VirtualMachineInstance on the host.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#domain DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#domain}
  */
  readonly domain: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomain;
  /**
  * EvictionStrategy describes the strategy to follow when a node drain occurs. The possible options are: - 'None': No action will be taken, according to the specified 'RunStrategy' the VirtualMachine will be restarted or shutdown. - 'LiveMigrate': the VirtualMachineInstance will be migrated instead of being shutdown. - 'LiveMigrateIfPossible': the same as 'LiveMigrate' but only if the VirtualMachine is Live-Migratable, otherwise it will behave as 'None'. - 'External': the VirtualMachineInstance will be protected by a PDB and 'vmi.Status.EvacuationNodeName' will be set on eviction. This is mainly useful for cluster-api-provider-kubevirt (capk) which needs a way for VMI's to be blocked from eviction, yet signal capk that eviction has been called on the VMI so the capk controller can handle tearing the VMI down. Details can be found in the commit description https://github.com/kubevirt/kubevirt/commit/c1d77face705c8b126696bac9a3ee3825f27f1fa.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#eviction_strategy DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#eviction_strategy}
  */
  readonly evictionStrategy?: string;
  /**
  * Specifies the hostname of the vmi If not specified, the hostname will be set to the name of the vmi, if dhcp or cloud-init is configured properly.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#hostname DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#hostname}
  */
  readonly hostname?: string;
  /**
  * Periodic probe of VirtualMachineInstance liveness. VirtualmachineInstances will be stopped if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#liveness_probe DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#liveness_probe}
  */
  readonly livenessProbe?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbe;
  /**
  * List of networks that can be attached to a vm's virtual interface.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#networks DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#networks}
  */
  readonly networks?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworks[] | cdktf.IResolvable;
  /**
  * NodeSelector is a selector which must be true for the vmi to fit on a node. Selector which must match a node's labels for the vmi to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#node_selector DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#node_selector}
  */
  readonly nodeSelector?: { [key: string]: string };
  /**
  * If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#priority_class_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#priority_class_name}
  */
  readonly priorityClassName?: string;
  /**
  * Periodic probe of VirtualMachineInstance service readiness. VirtualmachineInstances will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#readiness_probe DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#readiness_probe}
  */
  readonly readinessProbe?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe;
  /**
  * If specified, the VMI will be dispatched by specified scheduler. If not specified, the VMI will be dispatched by default scheduler.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#scheduler_name DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#scheduler_name}
  */
  readonly schedulerName?: string;
  /**
  * StartStrategy can be set to 'Paused' if Virtual Machine should be started in paused state.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#start_strategy DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#start_strategy}
  */
  readonly startStrategy?: string;
  /**
  * If specified, the fully qualified vmi hostname will be '<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>'. If not specified, the vmi will not have a domainname at all. The DNS entry will resolve to the vmi, no matter if the vmi itself can pick up a hostname.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#subdomain DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#subdomain}
  */
  readonly subdomain?: string;
  /**
  * Grace period observed after signalling a VirtualMachineInstance to stop after which the VirtualMachineInstance is force terminated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#termination_grace_period_seconds DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#termination_grace_period_seconds}
  */
  readonly terminationGracePeriodSeconds?: number;
  /**
  * If toleration is specified, obey all the toleration rules.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#tolerations DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#tolerations}
  */
  readonly tolerations?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations[] | cdktf.IResolvable;
  /**
  * TopologySpreadConstraints describes how a group of VMIs will be spread across a given topology domains. K8s scheduler will schedule VMI pods in a way which abides by the constraints.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#topology_spread_constraints DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#topology_spread_constraints}
  */
  readonly topologySpreadConstraints?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints[] | cdktf.IResolvable;
  /**
  * List of volumes that can be mounted by disks belonging to the vmi.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#volumes DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#volumes}
  */
  readonly volumes?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes[] | cdktf.IResolvable;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_credentials: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentialsToTerraform, false)(struct!.accessCredentials),
    affinity: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinityToTerraform(struct!.affinity),
    architecture: cdktf.stringToTerraform(struct!.architecture),
    dns_config: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfigToTerraform(struct!.dnsConfig),
    dns_policy: cdktf.stringToTerraform(struct!.dnsPolicy),
    domain: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomainToTerraform(struct!.domain),
    eviction_strategy: cdktf.stringToTerraform(struct!.evictionStrategy),
    hostname: cdktf.stringToTerraform(struct!.hostname),
    liveness_probe: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbeToTerraform(struct!.livenessProbe),
    networks: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworksToTerraform, false)(struct!.networks),
    node_selector: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.nodeSelector),
    priority_class_name: cdktf.stringToTerraform(struct!.priorityClassName),
    readiness_probe: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeToTerraform(struct!.readinessProbe),
    scheduler_name: cdktf.stringToTerraform(struct!.schedulerName),
    start_strategy: cdktf.stringToTerraform(struct!.startStrategy),
    subdomain: cdktf.stringToTerraform(struct!.subdomain),
    termination_grace_period_seconds: cdktf.numberToTerraform(struct!.terminationGracePeriodSeconds),
    tolerations: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsToTerraform, false)(struct!.tolerations),
    topology_spread_constraints: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsToTerraform, false)(struct!.topologySpreadConstraints),
    volumes: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesToTerraform, false)(struct!.volumes),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_credentials: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentialsToHclTerraform, false)(struct!.accessCredentials),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentialsList",
    },
    affinity: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinityToHclTerraform(struct!.affinity),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinity",
    },
    architecture: {
      value: cdktf.stringToHclTerraform(struct!.architecture),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_config: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfigToHclTerraform(struct!.dnsConfig),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfig",
    },
    dns_policy: {
      value: cdktf.stringToHclTerraform(struct!.dnsPolicy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    domain: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomainToHclTerraform(struct!.domain),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomain",
    },
    eviction_strategy: {
      value: cdktf.stringToHclTerraform(struct!.evictionStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hostname: {
      value: cdktf.stringToHclTerraform(struct!.hostname),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    liveness_probe: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbeToHclTerraform(struct!.livenessProbe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbe",
    },
    networks: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworksToHclTerraform, false)(struct!.networks),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworksList",
    },
    node_selector: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.nodeSelector),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    priority_class_name: {
      value: cdktf.stringToHclTerraform(struct!.priorityClassName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    readiness_probe: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeToHclTerraform(struct!.readinessProbe),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe",
    },
    scheduler_name: {
      value: cdktf.stringToHclTerraform(struct!.schedulerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    start_strategy: {
      value: cdktf.stringToHclTerraform(struct!.startStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    subdomain: {
      value: cdktf.stringToHclTerraform(struct!.subdomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    termination_grace_period_seconds: {
      value: cdktf.numberToHclTerraform(struct!.terminationGracePeriodSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tolerations: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsToHclTerraform, false)(struct!.tolerations),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsList",
    },
    topology_spread_constraints: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsToHclTerraform, false)(struct!.topologySpreadConstraints),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsList",
    },
    volumes: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesToHclTerraform, false)(struct!.volumes),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessCredentials?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessCredentials = this._accessCredentials?.internalValue;
    }
    if (this._affinity?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.affinity = this._affinity?.internalValue;
    }
    if (this._architecture !== undefined) {
      hasAnyValues = true;
      internalValueResult.architecture = this._architecture;
    }
    if (this._dnsConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsConfig = this._dnsConfig?.internalValue;
    }
    if (this._dnsPolicy !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsPolicy = this._dnsPolicy;
    }
    if (this._domain?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain?.internalValue;
    }
    if (this._evictionStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.evictionStrategy = this._evictionStrategy;
    }
    if (this._hostname !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostname = this._hostname;
    }
    if (this._livenessProbe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.livenessProbe = this._livenessProbe?.internalValue;
    }
    if (this._networks?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.networks = this._networks?.internalValue;
    }
    if (this._nodeSelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.nodeSelector = this._nodeSelector;
    }
    if (this._priorityClassName !== undefined) {
      hasAnyValues = true;
      internalValueResult.priorityClassName = this._priorityClassName;
    }
    if (this._readinessProbe?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.readinessProbe = this._readinessProbe?.internalValue;
    }
    if (this._schedulerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.schedulerName = this._schedulerName;
    }
    if (this._startStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.startStrategy = this._startStrategy;
    }
    if (this._subdomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.subdomain = this._subdomain;
    }
    if (this._terminationGracePeriodSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.terminationGracePeriodSeconds = this._terminationGracePeriodSeconds;
    }
    if (this._tolerations?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tolerations = this._tolerations?.internalValue;
    }
    if (this._topologySpreadConstraints?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.topologySpreadConstraints = this._topologySpreadConstraints?.internalValue;
    }
    if (this._volumes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumes = this._volumes?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessCredentials.internalValue = undefined;
      this._affinity.internalValue = undefined;
      this._architecture = undefined;
      this._dnsConfig.internalValue = undefined;
      this._dnsPolicy = undefined;
      this._domain.internalValue = undefined;
      this._evictionStrategy = undefined;
      this._hostname = undefined;
      this._livenessProbe.internalValue = undefined;
      this._networks.internalValue = undefined;
      this._nodeSelector = undefined;
      this._priorityClassName = undefined;
      this._readinessProbe.internalValue = undefined;
      this._schedulerName = undefined;
      this._startStrategy = undefined;
      this._subdomain = undefined;
      this._terminationGracePeriodSeconds = undefined;
      this._tolerations.internalValue = undefined;
      this._topologySpreadConstraints.internalValue = undefined;
      this._volumes.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessCredentials.internalValue = value.accessCredentials;
      this._affinity.internalValue = value.affinity;
      this._architecture = value.architecture;
      this._dnsConfig.internalValue = value.dnsConfig;
      this._dnsPolicy = value.dnsPolicy;
      this._domain.internalValue = value.domain;
      this._evictionStrategy = value.evictionStrategy;
      this._hostname = value.hostname;
      this._livenessProbe.internalValue = value.livenessProbe;
      this._networks.internalValue = value.networks;
      this._nodeSelector = value.nodeSelector;
      this._priorityClassName = value.priorityClassName;
      this._readinessProbe.internalValue = value.readinessProbe;
      this._schedulerName = value.schedulerName;
      this._startStrategy = value.startStrategy;
      this._subdomain = value.subdomain;
      this._terminationGracePeriodSeconds = value.terminationGracePeriodSeconds;
      this._tolerations.internalValue = value.tolerations;
      this._topologySpreadConstraints.internalValue = value.topologySpreadConstraints;
      this._volumes.internalValue = value.volumes;
    }
  }

  // access_credentials - computed: false, optional: true, required: false
  private _accessCredentials = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentialsList(this, "access_credentials", false);
  public get accessCredentials() {
    return this._accessCredentials;
  }
  public putAccessCredentials(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAccessCredentials[] | cdktf.IResolvable) {
    this._accessCredentials.internalValue = value;
  }
  public resetAccessCredentials() {
    this._accessCredentials.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessCredentialsInput() {
    return this._accessCredentials.internalValue;
  }

  // affinity - computed: false, optional: true, required: false
  private _affinity = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinityOutputReference(this, "affinity");
  public get affinity() {
    return this._affinity;
  }
  public putAffinity(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecAffinity) {
    this._affinity.internalValue = value;
  }
  public resetAffinity() {
    this._affinity.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get affinityInput() {
    return this._affinity.internalValue;
  }

  // architecture - computed: false, optional: true, required: false
  private _architecture?: string; 
  public get architecture() {
    return this.getStringAttribute('architecture');
  }
  public set architecture(value: string) {
    this._architecture = value;
  }
  public resetArchitecture() {
    this._architecture = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get architectureInput() {
    return this._architecture;
  }

  // dns_config - computed: false, optional: true, required: false
  private _dnsConfig = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfigOutputReference(this, "dns_config");
  public get dnsConfig() {
    return this._dnsConfig;
  }
  public putDnsConfig(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDnsConfig) {
    this._dnsConfig.internalValue = value;
  }
  public resetDnsConfig() {
    this._dnsConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsConfigInput() {
    return this._dnsConfig.internalValue;
  }

  // dns_policy - computed: false, optional: true, required: false
  private _dnsPolicy?: string; 
  public get dnsPolicy() {
    return this.getStringAttribute('dns_policy');
  }
  public set dnsPolicy(value: string) {
    this._dnsPolicy = value;
  }
  public resetDnsPolicy() {
    this._dnsPolicy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsPolicyInput() {
    return this._dnsPolicy;
  }

  // domain - computed: false, optional: false, required: true
  private _domain = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomainOutputReference(this, "domain");
  public get domain() {
    return this._domain;
  }
  public putDomain(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecDomain) {
    this._domain.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain.internalValue;
  }

  // eviction_strategy - computed: false, optional: true, required: false
  private _evictionStrategy?: string; 
  public get evictionStrategy() {
    return this.getStringAttribute('eviction_strategy');
  }
  public set evictionStrategy(value: string) {
    this._evictionStrategy = value;
  }
  public resetEvictionStrategy() {
    this._evictionStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get evictionStrategyInput() {
    return this._evictionStrategy;
  }

  // hostname - computed: false, optional: true, required: false
  private _hostname?: string; 
  public get hostname() {
    return this.getStringAttribute('hostname');
  }
  public set hostname(value: string) {
    this._hostname = value;
  }
  public resetHostname() {
    this._hostname = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostnameInput() {
    return this._hostname;
  }

  // liveness_probe - computed: false, optional: true, required: false
  private _livenessProbe = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbeOutputReference(this, "liveness_probe");
  public get livenessProbe() {
    return this._livenessProbe;
  }
  public putLivenessProbe(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecLivenessProbe) {
    this._livenessProbe.internalValue = value;
  }
  public resetLivenessProbe() {
    this._livenessProbe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get livenessProbeInput() {
    return this._livenessProbe.internalValue;
  }

  // networks - computed: false, optional: true, required: false
  private _networks = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworksList(this, "networks", false);
  public get networks() {
    return this._networks;
  }
  public putNetworks(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecNetworks[] | cdktf.IResolvable) {
    this._networks.internalValue = value;
  }
  public resetNetworks() {
    this._networks.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networksInput() {
    return this._networks.internalValue;
  }

  // node_selector - computed: false, optional: true, required: false
  private _nodeSelector?: { [key: string]: string }; 
  public get nodeSelector() {
    return this.getStringMapAttribute('node_selector');
  }
  public set nodeSelector(value: { [key: string]: string }) {
    this._nodeSelector = value;
  }
  public resetNodeSelector() {
    this._nodeSelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nodeSelectorInput() {
    return this._nodeSelector;
  }

  // priority_class_name - computed: false, optional: true, required: false
  private _priorityClassName?: string; 
  public get priorityClassName() {
    return this.getStringAttribute('priority_class_name');
  }
  public set priorityClassName(value: string) {
    this._priorityClassName = value;
  }
  public resetPriorityClassName() {
    this._priorityClassName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get priorityClassNameInput() {
    return this._priorityClassName;
  }

  // readiness_probe - computed: false, optional: true, required: false
  private _readinessProbe = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbeOutputReference(this, "readiness_probe");
  public get readinessProbe() {
    return this._readinessProbe;
  }
  public putReadinessProbe(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecReadinessProbe) {
    this._readinessProbe.internalValue = value;
  }
  public resetReadinessProbe() {
    this._readinessProbe.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readinessProbeInput() {
    return this._readinessProbe.internalValue;
  }

  // scheduler_name - computed: false, optional: true, required: false
  private _schedulerName?: string; 
  public get schedulerName() {
    return this.getStringAttribute('scheduler_name');
  }
  public set schedulerName(value: string) {
    this._schedulerName = value;
  }
  public resetSchedulerName() {
    this._schedulerName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schedulerNameInput() {
    return this._schedulerName;
  }

  // start_strategy - computed: false, optional: true, required: false
  private _startStrategy?: string; 
  public get startStrategy() {
    return this.getStringAttribute('start_strategy');
  }
  public set startStrategy(value: string) {
    this._startStrategy = value;
  }
  public resetStartStrategy() {
    this._startStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get startStrategyInput() {
    return this._startStrategy;
  }

  // subdomain - computed: false, optional: true, required: false
  private _subdomain?: string; 
  public get subdomain() {
    return this.getStringAttribute('subdomain');
  }
  public set subdomain(value: string) {
    this._subdomain = value;
  }
  public resetSubdomain() {
    this._subdomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get subdomainInput() {
    return this._subdomain;
  }

  // termination_grace_period_seconds - computed: false, optional: true, required: false
  private _terminationGracePeriodSeconds?: number; 
  public get terminationGracePeriodSeconds() {
    return this.getNumberAttribute('termination_grace_period_seconds');
  }
  public set terminationGracePeriodSeconds(value: number) {
    this._terminationGracePeriodSeconds = value;
  }
  public resetTerminationGracePeriodSeconds() {
    this._terminationGracePeriodSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get terminationGracePeriodSecondsInput() {
    return this._terminationGracePeriodSeconds;
  }

  // tolerations - computed: false, optional: true, required: false
  private _tolerations = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerationsList(this, "tolerations", false);
  public get tolerations() {
    return this._tolerations;
  }
  public putTolerations(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTolerations[] | cdktf.IResolvable) {
    this._tolerations.internalValue = value;
  }
  public resetTolerations() {
    this._tolerations.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tolerationsInput() {
    return this._tolerations.internalValue;
  }

  // topology_spread_constraints - computed: false, optional: true, required: false
  private _topologySpreadConstraints = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraintsList(this, "topology_spread_constraints", false);
  public get topologySpreadConstraints() {
    return this._topologySpreadConstraints;
  }
  public putTopologySpreadConstraints(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecTopologySpreadConstraints[] | cdktf.IResolvable) {
    this._topologySpreadConstraints.internalValue = value;
  }
  public resetTopologySpreadConstraints() {
    this._topologySpreadConstraints.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get topologySpreadConstraintsInput() {
    return this._topologySpreadConstraints.internalValue;
  }

  // volumes - computed: false, optional: true, required: false
  private _volumes = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumesList(this, "volumes", false);
  public get volumes() {
    return this._volumes;
  }
  public putVolumes(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecVolumes[] | cdktf.IResolvable) {
    this._volumes.internalValue = value;
  }
  public resetVolumes() {
    this._volumes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumesInput() {
    return this._volumes.internalValue;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#metadata DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#metadata}
  */
  readonly metadata?: { [key: string]: string };
  /**
  * VirtualMachineInstance Spec contains the VirtualMachineInstance specification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#spec DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#spec}
  */
  readonly spec?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.metadata),
    spec: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecToTerraform(struct!.spec),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.metadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    spec: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata?: { [key: string]: string }; 
  public get metadata() {
    return this.getStringMapAttribute('metadata');
  }
  public set metadata(value: { [key: string]: string }) {
    this._metadata = value;
  }
  public resetMetadata() {
    this._metadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec {
  /**
  * dataVolumeTemplates is a list of dataVolumes that the VirtualMachineInstance template can reference. DataVolumes in this list are dynamically created for the VirtualMachine and are tied to the VirtualMachine's life-cycle.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#data_volume_templates DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#data_volume_templates}
  */
  readonly dataVolumeTemplates?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplates[] | cdktf.IResolvable;
  /**
  * InstancetypeMatcher references a instancetype that is used to fill fields in Template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#instancetype DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#instancetype}
  */
  readonly instancetype?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetype;
  /**
  * PreferenceMatcher references a set of preference that is used to fill fields in Template
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#preference DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#preference}
  */
  readonly preference?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreference;
  /**
  * Running state indicates the requested running state of the VirtualMachineInstance mutually exclusive with Running
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#run_strategy DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#run_strategy}
  */
  readonly runStrategy?: string;
  /**
  * Running controls whether the associatied VirtualMachineInstance is created or not Mutually exclusive with RunStrategy
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#running DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#running}
  */
  readonly running?: boolean | cdktf.IResolvable;
  /**
  * Template is the direct specification of VirtualMachineInstance
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#template DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#template}
  */
  readonly template: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    data_volume_templates: cdktf.listMapper(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplatesToTerraform, false)(struct!.dataVolumeTemplates),
    instancetype: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetypeToTerraform(struct!.instancetype),
    preference: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreferenceToTerraform(struct!.preference),
    run_strategy: cdktf.stringToTerraform(struct!.runStrategy),
    running: cdktf.booleanToTerraform(struct!.running),
    template: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateToTerraform(struct!.template),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    data_volume_templates: {
      value: cdktf.listMapperHcl(dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplatesToHclTerraform, false)(struct!.dataVolumeTemplates),
      isBlock: true,
      type: "list",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplatesList",
    },
    instancetype: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetypeToHclTerraform(struct!.instancetype),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetype",
    },
    preference: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreferenceToHclTerraform(struct!.preference),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreference",
    },
    run_strategy: {
      value: cdktf.stringToHclTerraform(struct!.runStrategy),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    running: {
      value: cdktf.booleanToHclTerraform(struct!.running),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    template: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateToHclTerraform(struct!.template),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._dataVolumeTemplates?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataVolumeTemplates = this._dataVolumeTemplates?.internalValue;
    }
    if (this._instancetype?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.instancetype = this._instancetype?.internalValue;
    }
    if (this._preference?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preference = this._preference?.internalValue;
    }
    if (this._runStrategy !== undefined) {
      hasAnyValues = true;
      internalValueResult.runStrategy = this._runStrategy;
    }
    if (this._running !== undefined) {
      hasAnyValues = true;
      internalValueResult.running = this._running;
    }
    if (this._template?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.template = this._template?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._dataVolumeTemplates.internalValue = undefined;
      this._instancetype.internalValue = undefined;
      this._preference.internalValue = undefined;
      this._runStrategy = undefined;
      this._running = undefined;
      this._template.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._dataVolumeTemplates.internalValue = value.dataVolumeTemplates;
      this._instancetype.internalValue = value.instancetype;
      this._preference.internalValue = value.preference;
      this._runStrategy = value.runStrategy;
      this._running = value.running;
      this._template.internalValue = value.template;
    }
  }

  // data_volume_templates - computed: false, optional: true, required: false
  private _dataVolumeTemplates = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplatesList(this, "data_volume_templates", false);
  public get dataVolumeTemplates() {
    return this._dataVolumeTemplates;
  }
  public putDataVolumeTemplates(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecDataVolumeTemplates[] | cdktf.IResolvable) {
    this._dataVolumeTemplates.internalValue = value;
  }
  public resetDataVolumeTemplates() {
    this._dataVolumeTemplates.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dataVolumeTemplatesInput() {
    return this._dataVolumeTemplates.internalValue;
  }

  // instancetype - computed: false, optional: true, required: false
  private _instancetype = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetypeOutputReference(this, "instancetype");
  public get instancetype() {
    return this._instancetype;
  }
  public putInstancetype(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecInstancetype) {
    this._instancetype.internalValue = value;
  }
  public resetInstancetype() {
    this._instancetype.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get instancetypeInput() {
    return this._instancetype.internalValue;
  }

  // preference - computed: false, optional: true, required: false
  private _preference = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreferenceOutputReference(this, "preference");
  public get preference() {
    return this._preference;
  }
  public putPreference(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecPreference) {
    this._preference.internalValue = value;
  }
  public resetPreference() {
    this._preference.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preferenceInput() {
    return this._preference.internalValue;
  }

  // run_strategy - computed: false, optional: true, required: false
  private _runStrategy?: string; 
  public get runStrategy() {
    return this.getStringAttribute('run_strategy');
  }
  public set runStrategy(value: string) {
    this._runStrategy = value;
  }
  public resetRunStrategy() {
    this._runStrategy = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runStrategyInput() {
    return this._runStrategy;
  }

  // running - computed: false, optional: true, required: false
  private _running?: boolean | cdktf.IResolvable; 
  public get running() {
    return this.getBooleanAttribute('running');
  }
  public set running(value: boolean | cdktf.IResolvable) {
    this._running = value;
  }
  public resetRunning() {
    this._running = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get runningInput() {
    return this._running;
  }

  // template - computed: false, optional: false, required: true
  private _template = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplateOutputReference(this, "template");
  public get template() {
    return this._template;
  }
  public putTemplate(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecTemplate) {
    this._template.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get templateInput() {
    return this._template.internalValue;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#metadata DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#metadata}
  */
  readonly metadata?: { [key: string]: string };
  /**
  * VirtualMachineSpec contains the VirtualMachine specification.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#spec DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#spec}
  */
  readonly spec?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    metadata: cdktf.hashMapper(cdktf.stringToTerraform)(struct!.metadata),
    spec: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecToTerraform(struct!.spec),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    metadata: {
      value: cdktf.hashMapperHcl(cdktf.stringToHclTerraform)(struct!.metadata),
      isBlock: false,
      type: "map",
      storageClassType: "stringMap",
    },
    spec: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecToHclTerraform(struct!.spec),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._metadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata;
    }
    if (this._spec?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.spec = this._spec?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._metadata = undefined;
      this._spec.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._metadata = value.metadata;
      this._spec.internalValue = value.spec;
    }
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata?: { [key: string]: string }; 
  public get metadata() {
    return this.getStringMapAttribute('metadata');
  }
  public set metadata(value: { [key: string]: string }) {
    this._metadata = value;
  }
  public resetMetadata() {
    this._metadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata;
  }

  // spec - computed: false, optional: true, required: false
  private _spec = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpecOutputReference(this, "spec");
  public get spec() {
    return this._spec;
  }
  public putSpec(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateSpec) {
    this._spec.internalValue = value;
  }
  public resetSpec() {
    this._spec.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get specInput() {
    return this._spec.internalValue;
  }
}
export interface DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpec {
  /**
  * InfraClusterSecretRef is a reference to a secret with a kubeconfig for external cluster used for infra. When nil, this defaults to the value present in the KubevirtCluster object's spec associated with this machine.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#infra_cluster_secret_ref DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#infra_cluster_secret_ref}
  */
  readonly infraClusterSecretRef?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRef;
  /**
  * ProviderID TBD what to use for Kubevirt
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#provider_id DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#provider_id}
  */
  readonly providerId?: string;
  /**
  * BootstrapCheckSpec defines how the CAPK controller is checking CAPI Sentinel file inside the VM.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#virtual_machine_bootstrap_check DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#virtual_machine_bootstrap_check}
  */
  readonly virtualMachineBootstrapCheck?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheck;
  /**
  * VirtualMachineTemplateSpec defines the desired state of the kubevirt VM.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/metio/k8s/2025.12.15/docs/data-sources/infrastructure_cluster_x_k8s_io_kubevirt_machine_v1alpha1_manifest#virtual_machine_template DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1Manifest#virtual_machine_template}
  */
  readonly virtualMachineTemplate?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate;
}

export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecToTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    infra_cluster_secret_ref: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRefToTerraform(struct!.infraClusterSecretRef),
    provider_id: cdktf.stringToTerraform(struct!.providerId),
    virtual_machine_bootstrap_check: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheckToTerraform(struct!.virtualMachineBootstrapCheck),
    virtual_machine_template: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateToTerraform(struct!.virtualMachineTemplate),
  }
}


export function dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecToHclTerraform(struct?: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    infra_cluster_secret_ref: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRefToHclTerraform(struct!.infraClusterSecretRef),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRef",
    },
    provider_id: {
      value: cdktf.stringToHclTerraform(struct!.providerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    virtual_machine_bootstrap_check: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheckToHclTerraform(struct!.virtualMachineBootstrapCheck),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheck",
    },
    virtual_machine_template: {
      value: dataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateToHclTerraform(struct!.virtualMachineTemplate),
      isBlock: true,
      type: "struct",
      storageClassType: "DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._infraClusterSecretRef?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.infraClusterSecretRef = this._infraClusterSecretRef?.internalValue;
    }
    if (this._providerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.providerId = this._providerId;
    }
    if (this._virtualMachineBootstrapCheck?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualMachineBootstrapCheck = this._virtualMachineBootstrapCheck?.internalValue;
    }
    if (this._virtualMachineTemplate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.virtualMachineTemplate = this._virtualMachineTemplate?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._infraClusterSecretRef.internalValue = undefined;
      this._providerId = undefined;
      this._virtualMachineBootstrapCheck.internalValue = undefined;
      this._virtualMachineTemplate.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._infraClusterSecretRef.internalValue = value.infraClusterSecretRef;
      this._providerId = value.providerId;
      this._virtualMachineBootstrapCheck.internalValue = value.virtualMachineBootstrapCheck;
      this._virtualMachineTemplate.internalValue = value.virtualMachineTemplate;
    }
  }

  // infra_cluster_secret_ref - computed: false, optional: true, required: false
  private _infraClusterSecretRef = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRefOutputReference(this, "infra_cluster_secret_ref");
  public get infraClusterSecretRef() {
    return this._infraClusterSecretRef;
  }
  public putInfraClusterSecretRef(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecInfraClusterSecretRef) {
    this._infraClusterSecretRef.internalValue = value;
  }
  public resetInfraClusterSecretRef() {
    this._infraClusterSecretRef.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get infraClusterSecretRefInput() {
    return this._infraClusterSecretRef.internalValue;
  }

  // provider_id - computed: false, optional: true, required: false
  private _providerId?: string; 
  public get providerId() {
    return this.getStringAttribute('provider_id');
  }
  public set providerId(value: string) {
    this._providerId = value;
  }
  public resetProviderId() {
    this._providerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get providerIdInput() {
    return this._providerId;
  }

  // virtual_machine_bootstrap_check - computed: false, optional: true, required: false
  private _virtualMachineBootstrapCheck = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheckOutputReference(this, "virtual_machine_bootstrap_check");
  public get virtualMachineBootstrapCheck() {
    return this._virtualMachineBootstrapCheck;
  }
  public putVirtualMachineBootstrapCheck(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineBootstrapCheck) {
    this._virtualMachineBootstrapCheck.internalValue = value;
  }
  public resetVirtualMachineBootstrapCheck() {
    this._virtualMachineBootstrapCheck.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualMachineBootstrapCheckInput() {
    return this._virtualMachineBootstrapCheck.internalValue;
  }

  // virtual_machine_template - computed: false, optional: true, required: false
  private _virtualMachineTemplate = new DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplateOutputReference(this, "virtual_machine_template");
  public get virtualMachineTemplate() {
    return this._virtualMachineTemplate;
  }
  public putVirtualMachineTemplate(value: DataK8SInfrastructureClusterXK8SIoKubevirtMachineV1Alpha1ManifestSpecVirtualMachineTemplate) {
    this._virtualMachineTemplate.internalValue = value;
  }
  public resetVirtualMachineTemplate() {
    this._virtualMachineTemplate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get virtualMachineTemplateInput() {
    return this._virtualMachineTemplate.internalValue;
  }
}
